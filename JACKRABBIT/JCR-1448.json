{
    "comments": [
        {
            "author": "Christophe Lombart",
            "body": "Fix applied. Thanks \n\nI also add a new unit test based on your example. \nLet me know if something is wrong. \n\n",
            "date": "2008-05-23T20:06:19.863+0000",
            "id": 0
        }
    ],
    "component": "jackrabbit-ocm",
    "description": "Problem occurs when both parent and child beans are versionable.  Jackrabbit creates an nt:versionedChild node that is referenced by the parent node, referencing the childs versionedHistory node of the child.  The current OCM code does not handle this correctly and produces an error:  \"Node type  'nt:versionedChild' does not match descriptor node type 'nt:unstructured'\"\n\nBelow is a example code of the problem and a patch that appears to correctly resolve the problem.\n\n\n Within ObjectConverterImpl created the below method.\n\n        public Node getActualNode(Session session,Node node) throws\n RepositoryException\n        {\n                NodeType type = node.getPrimaryNodeType();\n                if (type.getName().equals(\"nt:versionedChild\"))\n                {\n\n                        String uuid =\n node.getProperty(\"jcr:childVersionHistory\").getValue().getString();\n                        Node actualNode = session.getNodeByUUID(uuid);\n                        String name = actualNode.getName();\n                        actualNode = session.getNodeByUUID(name);\n\n                        return actualNode;\n                }\n\n                return node;\n        }\n\n AND modified the following to call the above method\n\n\n        public Object getObject(Session session, Class clazz, String path)\n        {\n                try {\n                        if (!session.itemExists(path)) {\n                                return null;\n                        }\n\n                        if (requestObjectCache.isCached(path))\n                    {\n                        return requestObjectCache.getObject(path);\n                    }\n\n                        ClassDescriptor classDescriptor =\n getClassDescriptor(clazz);\n\n                        checkNodeType(session, classDescriptor);\n\n                        Node node = (Node) session.getItem(path);\n                        if (!classDescriptor.isInterface()) {\n                                {\n                                node = getActualNode(session,node);\n                                checkCompatiblePrimaryNodeTypes(session,\n node, classDescriptor, true);\n                                }\n                        }\n\n                        ClassDescriptor alternativeDescriptor = null;\n                        if\n (classDescriptor.usesNodeTypePerHierarchyStrategy())\n {\n                                if\n (node.hasProperty(ManagerConstant.DISCRIMINATOR_PROPERTY_NAME))\n {\n                        String className =\n node.getProperty(ManagerConstant.DISCRIMINATOR_PROPERTY_NAME\n ).getValue().getString();\n                        alternativeDescriptor =\n getClassDescriptor(ReflectionUtils.forName(className));\n                                }\n                        } else {\n                                if\n (classDescriptor.usesNodeTypePerConcreteClassStrategy())\n {\n                                        String nodeType =\n node.getPrimaryNodeType().getName();\n                                        if\n (!nodeType.equals(classDescriptor.getJcrType()))\n {\n                                            alternativeDescriptor =\n classDescriptor.getDescendantClassDescriptor(nodeType);\n\n                                            // in case we an alternative\n could not be found by walking\n                                            // the class descriptor\n hierarchy, check whether we\n would\n                                            // have a descriptor for the\n node type directly (which\n                                            // may the case if the class\n descriptor hierarchy is\n                                            // incomplete due to missing\n configuration. See JCR-1145\n                                            // for details.\n                                            if (alternativeDescriptor ==\n null) {\n                                                alternativeDescriptor =\n mapper.getClassDescriptorByNodeType(nodeType);\n                                            }\n                                        }\n                                }\n                        }\n\n                        // if we have an alternative class descriptor,\n check whether its\n                        // extends (or is the same) as the requested class.\n                        if (alternativeDescriptor != null) {\n                            Class alternativeClazz =\n ReflectionUtils.forName(alternativeDescriptor.getClassName());\n                            if (clazz.isAssignableFrom(alternativeClazz)) {\n                                clazz = alternativeClazz;\n                                classDescriptor = alternativeDescriptor;\n                            }\n                        }\n\n                        // ensure class is concrete (neither interface nor\n abstract)\n                        if (clazz.isInterface() ||\n Modifier.isAbstract(clazz.getModifiers())) {\n                            throw new JcrMappingException( \"Cannot\n instantiate non-concrete\n class \" + clazz.getName()\n                        + \" for node \" + path + \" of type \" +\n node.getPrimaryNodeType().getName());\n                        }\n\n            Object object =\n ReflectionUtils.newInstance(classDescriptor.getClassName());\n\n            if (! requestObjectCache.isCached(path))\n            {\n                          requestObjectCache.cache(path, object);\n            }\n\n            simpleFieldsHelp.retrieveSimpleFields(session,\n classDescriptor, node, object);\n                        retrieveBeanFields(session, classDescriptor, node,\n path, object, false);\n                        retrieveCollectionFields(session, classDescriptor,\n node, object, false);\n\n                        return object;\n                } catch (PathNotFoundException pnfe) {\n                        // HINT should never get here\n                        throw new\n ObjectContentManagerException(\"Impossible to get\n the object\n at \" + path, pnfe);\n                } catch (RepositoryException re) {\n                        throw new\n org.apache.jackrabbit.ocm.exception.RepositoryException(\"Impossible to\n get the object at \" + path, re);\n                }\n        }\n\n\n\n\n>\n>\n>\n> > I am building a test application against OCM.  I have the following\n> > classes that are annotated for OCM.  The problem is that when I update\n> and\n> > version the root object PressRelease the Bean Author is versioned to\n> > nt:versionedChild.  While the OCM is checking for node type\n> compatibility\n> > it is throwing the following exception.  It looks like the\n> versionedChild\n> > is not handled correctly.  Any suggestions?\n> >\n> > I also attempted to retrieve the version based on the version name for\n> the\n> > rootVersion but also trapped. From a Version object how should I access\n> > each of the versioned entries?\n> >\n> > Thanks\n> > Wes\n> >\n> > @Node (jcrMixinTypes=\"mix:versionable\")\n> > public class PressRelease\n> > {\n> >       @Field(path=true) String path;\n> >       @Field String title;\n> >       @Field Date pubDate;\n> >       @Field String content;\n> >       @Bean Author author;\n> >       @Collection (elementClassName=Comment.class) List<Comment>\n> comments = new\n> > ArrayList<Comment>();\n> >\n> >       public String getPath() {\n> >               return path;\n> >       }\n> >       public void setPath(String path) {\n> >               this.path = path;\n> >       }\n> >       public String getContent() {\n> >               return content;\n> >       }\n> >       public void setContent(String content) {\n> >               this.content = content;\n> >       }\n> >       public Date getPubDate() {\n> >               return pubDate;\n> >       }\n> >       public void setPubDate(Date pubDate) {\n> >               this.pubDate = pubDate;\n> >       }\n> >       public String getTitle() {\n> >               return title;\n> >       }\n> >       public void setTitle(String title) {\n> >               this.title = title;\n> >       }\n> >       public Author getAuthor() {\n> >               return author;\n> >       }\n> >       public void setAuthor(Author author) {\n> >               this.author = author;\n> >       }\n> >       public List<Comment> getComments() {\n> >               return comments;\n> >       }\n> >       public void setComments(List<Comment> comments) {\n> >               this.comments = comments;\n> >       }\n> >\n> >\n> > }\n> >\n> > @Node (jcrMixinTypes=\"mix:versionable\")\n> > public class Author {\n> >\n> >       @Field(path=true) String path;\n> >       @Field String name;\n> >\n> >\n> >       public String getName() {\n> >               return name;\n> >       }\n> >       public void setName(String name) {\n> >               this.name = name;\n> >       }\n> >       public String getPath() {\n> >               return path;\n> >       }\n> >       public void setPath(String path) {\n> >               this.path = path;\n> >       }\n> >\n> > }\n> >\n> > MAIN\n> >\n> >       while (versionIterator.hasNext())\n> >       {\n> >           Version version = (Version) versionIterator.next();\n> >           System.out.println(\"version found : \"+ version.getName() + \" -\n> \" +\n> >                                 version.getPath() + \" - \" +\n> > version.getCreated().getTime());\n> >\n> >\n> >           if (!version.getName().equals(\"jcr:rootVersion\"))\n> >           {\n> >\n> > //      Get the object matching to the first version\n> >           pressRelease = (PressRelease)\n> > ocm.getObject(\"/newtutorial\",version.getName());\n> >\n> >\n> >               System.out.println(\"PressRelease title : \" +\n> pressRelease.getTitle());\n> >               System.out.println(\"             author: \" +\n> > pressRelease.getAuthor().getName());\n> >               System.out.println(\"            content: \" +\n> pressRelease.getContent());\n> >               List comments = pressRelease.getComments();\n> >               Iterator iterator = comments.iterator();\n> >               while (iterator.hasNext())\n> >               {\n> >                       comment = (Comment) iterator.next();\n> >                       System.out.println(\"Comment : <\" + comment.getData()\n> + \">\" +\n> > comment.getText());\n> >               }\n> >           }\n> >       }\n> >\n> >\n> > CONSOLE\n> > version found : jcr:rootVersion -\n> >\n> /jcr:system/jcr:versionStorage/fc/0b/fd/fc0bfd89-c487-4fbe-930f-d837e5dfed79/jcr:rootVersion\n> > - Thu Feb 28 15:54:42 EST 2008\n> > version found : 1.0 -\n> >\n> /jcr:system/jcr:versionStorage/fc/0b/fd/fc0bfd89-c487-4fbe-930f-d837e5dfed79/1.0\n> > - Thu Feb 28 15:54:59 EST 2008\n> > Exception in thread \"main\"\n> > org.apache.jackrabbit.ocm.exception.ObjectContentManagerException:\n> Cannot\n> > map object of type 'com..pc.repository.Author'. Node type\n> > 'nt:versionedChild' does not match descriptor node type\n> 'nt:unstructured'\n> >       at\n> >\n> org.apache.jackrabbit.ocm.manager.objectconverter.impl.ObjectConverterImpl.checkCompatiblePrimaryNodeTypes\n> (ObjectConverterImpl.java:552)\n> >       at\n> >\n> org.apache.jackrabbit.ocm.manager.objectconverter.impl.ObjectConverterImpl.getObject\n> (ObjectConverterImpl.java:361)\n> >       at\n> >\n> org.apache.jackrabbit.ocm.manager.beanconverter.impl.DefaultBeanConverterImpl.getObject\n> (DefaultBeanConverterImpl.java:80)\n> >       at\n> >\n> org.apache.jackrabbit.ocm.manager.objectconverter.impl.ObjectConverterImpl.retrieveBeanField\n> (ObjectConverterImpl.java:666)\n> >       at\n> >\n> org.apache.jackrabbit.ocm.manager.objectconverter.impl.ObjectConverterImpl.retrieveBeanFields\n> (ObjectConverterImpl.java:621)\n> >       at\n> >\n> org.apache.jackrabbit.ocm.manager.objectconverter.impl.ObjectConverterImpl.getObject\n> (ObjectConverterImpl.java:309)\n> >       at\n> >\n> org.apache.jackrabbit.ocm.manager.impl.ObjectContentManagerImpl.getObject(\n> ObjectContentManagerImpl.java:313)\n> >       at com.pc.repository.Main.main(Main.java:345)\n\n\n\n\n\n\n",
    "hasPatch": false,
    "hasScreenshot": false,
    "id": "JCR-1448",
    "issuetypeClassified": "BUG",
    "issuetypeTracker": "BUG",
    "priority": "Major",
    "product": "JACKRABBIT",
    "project": "JACKRABBIT",
    "summary": "nt:versionedChild problem",
    "systemSpecification": true,
    "version": "1.4"
}