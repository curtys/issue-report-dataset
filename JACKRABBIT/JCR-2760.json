{
    "comments": [
        {
            "author": "Jukka Zitting",
            "body": "The attached patch implements the proposed solution.\n\nIt turned out that the BundleBinding class uses only 24 bits of the index number, so this implementation does the same when allocating the index numbers.\n\nThe solution is fully backwards compatible with existing repositories (existing index numbers are used as-is), and avoids hash collisions by explicitly incrementing the index number until no collision occurs.",
            "date": "2010-09-28T16:14:54.220+0000",
            "id": 0
        },
        {
            "author": "Thomas Mueller",
            "body": "I'm not sure if this is really a big problem, so this is just FYI: With 24 bit, the probability of collision is higher. With 1024 entries, the probability is about 3%. The 1% Jukka mentioned is correct for 32 bit. The same formula as for UUIDs applies, see also http://en.wikipedia.org/wiki/Universally_unique_identifier and http://www.h2database.com/html/advanced.html#uuid\n\n2^5=32 probability: 0.003051711246848665%\n2^6=64 probability: 0.012206286222260498%\n2^7=128 probability: 0.04881620601105974%\n2^8=256 probability: 0.19512188925244756%\n2^9=512 probability: 0.7782061739756485%\n2^10=1024 probability: 3.076676552365587%\n2^11=2048 probability: 11.750309741540455%\n2^12=4096 probability: 39.346934028736655%\n2^13=8192 probability: 86.46647167633873%\n2^14=16384 probability: 99.96645373720975%\n\ndouble x = Math.pow(2, 24);\nfor (int i = 5; i < 15; i++) {\n    double n = Math.pow(2, i);\n    double p = 1 - Math.exp(-(n * n) / 2 / x);\n    System.out.println(\"2^\" + i + \"=\" + (1L << i) +\n            \" probability: \" + (p * 100) + \"%\");\n}\n\n",
            "date": "2010-09-29T06:41:15.623+0000",
            "id": 1
        },
        {
            "author": "Marcel Reutegger",
            "body": "+1\n\nlooks good to me.",
            "date": "2010-09-29T14:10:12.847+0000",
            "id": 2
        },
        {
            "author": "Jukka Zitting",
            "body": "Patch committed in revision 1004568.\n\nThe restriction to 24 bits is an unfortunate side-effect of the way the bundle serialization format chops off the first eight bits from the namespace index of the name of the primary type of a node. As mentioned by Thomas, this has a notable effect on the likelihood of collisions, but that seems OK since this only affects the non-standard use case of copying raw workspace data between repositories and even there the chance of problems is pretty low for reasonably sized repositories.\n\nA more complete solution would be to drop the use of namespace and name indexes in favour of a more efficient serialization format.",
            "date": "2010-10-05T08:37:59.046+0000",
            "id": 3
        },
        {
            "author": "Thomas Mueller",
            "body": "+1\n\nlooks good to me for Jackrabbit 2.x. I think for Jackrabbit 3 we should use a different solution (if we still want to use a name index it shouldn't be global). But that's something we can discuss later.\n\nI guess in most cases there are only few namespaces (typically less than 100). For the name index (property names) I'm not sure.",
            "date": "2010-10-05T09:14:31.700+0000",
            "id": 4
        },
        {
            "author": "S\u00e9bastien Launay",
            "body": "These changes are interesting for low-level copies of workspace content across repositories but also for clustering because it was possible to have collision between indexes for the same namespace on two nodes. \n\nI agree with Thomas that a different solution should be considered in JR 3  for sharing namespaces (maybe also for nodetypes) especially for cluster nodes (see JCR-1558).\n",
            "date": "2010-10-06T09:25:25.441+0000",
            "id": 5
        }
    ],
    "component": "jackrabbit-core",
    "description": "We use index numbers instead of namespace URIs or other strings in many places. The two-way mapping between namespace URIs and index numbers is by default stored in the repository-global ns_idx.properties file, and the index numbers are allocated using a linear sequence. The problem with this approach is that two repositories will easily end up with different string index mappings, which makes it practically impossible to make low-level copies of workspace content across repositories.\n\nThe ultimate solution for this problem would be to store the namespace URIs closer to the stored content, ideally as an implementation detail of a persistence manager.\n\nAn easier short-term solution would be to decrease the chances of two repositories having different string index mappings. A simple (and backwards-compatible) way to do this is to use the hash code of a namespace URI as the basis of allocating a new index number. Hash collisions are fairly unlikely, and can be handled by incrementing the intial hash code until the collision is avoided. In the common case of no collisions (with a uniform hash function the chance of a collision is less than 1% even with tousands of registered namespaces) this solution allows workspaces to be copied between repositories without worrying about the namespace index mappings.",
    "hasPatch": true,
    "hasScreenshot": false,
    "id": "JCR-2760",
    "issuetypeClassified": "IMPROVEMENT",
    "issuetypeTracker": "IMPROVEMENT",
    "priority": "Minor",
    "product": "JACKRABBIT",
    "project": "JACKRABBIT",
    "summary": "Use hash codes instead of sequence numbers for string indexes",
    "systemSpecification": true,
    "version": ""
}