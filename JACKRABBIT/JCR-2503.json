{
    "comments": [
        {
            "author": "Bram de Kruijff",
            "body": "Attaching a junit test that reproduces the problem along with a trace on my setup against svn revision 911308. On both the 1.5 and 1.6 branch I get session- and persistent inconsistencies. Did not pay much attention to 2.0/trunk but there also is a problem in the session. However it looks like that one is not persistent(?). \n\nAny thoughts? Hope it is not me doing something really stupid :)",
            "date": "2010-02-18T18:32:02.703+0000",
            "id": 0
        },
        {
            "author": "Martijn Hendriks",
            "body": "We regularly encounter inconsistent Jackrabbit repositories and the problems look very much like the one generated by the attached code. Any help on this is very much appreciated!",
            "date": "2010-02-22T09:14:18.373+0000",
            "id": 1
        },
        {
            "author": "Stephan Huttenhuis",
            "body": "This is a failure-atomicity problem in which the ReferentialIntegrityException leaves the session in an inconsistent state. This issue is closely related to https://issues.apache.org/jira/browse/JCR-288. In JCR-288 the problem is fixed for items that were previously persisted. It does not work for items that never have been persisted.\n\nRougly the following happens:\n- Node P3 is created which was never persisted before and node P1 is removed, but this is not allowed due to referential integrity.\n- Session.save calls ItemImpl.save on the root node.\n- Before calling LocalItemStateManager.update() all item states are disposed by calling SessionItemStateManager.disposeTransientItemState and this invalidates the state and removes it from the transient store.\n- The update call throws a ReferentialIntegrityException\n- The exception causes the transient items to be restored by calling ItemImpl.restoreTransientItems. Restoring is a 3 step process:\n  - retrieve or recreate the item object\n  - add the state to the SessionItemStateManager transient store again\n  - restore the properties in the state object\n\nThe problem is that adding the state to the SessionItemStateManager again is only done for items that where previously persisted (i.e. !isTransient). As a result node P3 transient state no longer exists when the next save is performed and P3 is not created, but its parent contains a child node reference to P3.\n\n\nA possible solution is to:\n- Call NodeImpl.restoreTransient and PropertyImpl.restoreTransient also for transient items.\n- Change the NodeImpl.restoreTransient and PropertyImpl.restoreTransient methods to re-create the state for transient items.\n\nSee attached patch which is based on the 1.5 branch.",
            "date": "2010-02-25T14:48:19.267+0000",
            "id": 2
        },
        {
            "author": "Bram de Kruijff",
            "body": "I can confirm this resolve the problem for me in the 1.5 branch.",
            "date": "2010-03-05T12:22:55.048+0000",
            "id": 3
        },
        {
            "author": "Jukka Zitting",
            "body": "Thanks! Patch committed in revision 944258.",
            "date": "2010-05-14T13:46:39.898+0000",
            "id": 4
        },
        {
            "author": "Jukka Zitting",
            "body": "Merged to the 1.6 branch in revision 944291.",
            "date": "2010-05-14T14:35:35.743+0000",
            "id": 5
        },
        {
            "author": "Julian Reschke",
            "body": "I don't believe this is fully fixed; while investigating JCR-3016 we came across NodeImplTest.testReferentialIntegrityCorruption().\n\nAfter the succesful save() the test case tries various operations on P3, but it does not try nodeP3.getPath(). Adding this:\n\n        try {\n        \tString expectedPath = root.getPath() + \"/P3\";\n            assertEquals(expectedPath, nodeP3.getPath());\n        } catch (Exception e) {\n        \te.printStackTrace();\n            String msg =\n                \"JCR-2503: Getting path of P3. Corrupt session?\";\n            log.error(msg, e);\n            fail(msg);\n        }\n\nmakes the test fail with \n\njavax.jcr.InvalidItemStateException: Item does not exist anymore: ba3ef1ac-fc5a-4e03-b44b-031f5e75c537\n\tat org.apache.jackrabbit.core.ItemImpl.itemSanityCheck(ItemImpl.java:116)\n\tat org.apache.jackrabbit.core.ItemImpl.perform(ItemImpl.java:90)\n\tat org.apache.jackrabbit.core.ItemImpl.getPath(ItemImpl.java:376)\n\tat org.apache.jackrabbit.core.NodeImplTest.testReferentialIntegrityCorruption(NodeImplTest.java:308)\n\n(this in 2.2.4)",
            "date": "2011-07-08T12:06:47.064+0000",
            "id": 6
        },
        {
            "author": "Jukka Zitting",
            "body": "Closing the issue since the fix was already released earlier. Let's use followup issues for any further work.",
            "date": "2011-09-23T11:25:11.115+0000",
            "id": 7
        }
    ],
    "component": "jackrabbit-core",
    "description": "When a ReferentialIntegrityException occurs in a session it seems that subsequent actions on that session may result in a inconsistent session state AND even inconsistent persistent state. The latter will even make jackrabbit fail to bootstrap an index from that persistent state.\n\nTypical rootcause:\n\nCaused by: org.apache.jackrabbit.core.state.NoSuchItemStateException: ddb9d3ea-59c1-4eb4-a83e-332f646d4f40\n        at org.apache.jackrabbit.core.state.SharedItemStateManager.getItemState(SharedItemStateManager.java:270)\n        at org.apache.jackrabbit.core.query.lucene.MultiIndex.createIndex(MultiIndex.java:1082)\n        at org.apache.jackrabbit.core.query.lucene.MultiIndex.createIndex(MultiIndex.java:1088)\n        at org.apache.jackrabbit.core.query.lucene.MultiIndex.createInitialIndex(MultiIndex.java:395)\n\nBootstrap failure:\n\njava.io.IOException: Error indexing workspace\n        at org.apache.jackrabbit.core.query.lucene.MultiIndex.createInitialIndex(MultiIndex.java:402)\n        at org.apache.jackrabbit.core.query.lucene.SearchIndex.doInit(SearchIndex.java:465)\n        at org.apache.jackrabbit.core.query.AbstractQueryHandler.init(AbstractQueryHandler.java:59)\n        at org.apache.jackrabbit.core.SearchManager.initializeQueryHandler(SearchManager.java:553)\n\n",
    "hasPatch": true,
    "hasScreenshot": false,
    "id": "JCR-2503",
    "issuetypeClassified": "BUG",
    "issuetypeTracker": "BUG",
    "priority": "Critical",
    "product": "JACKRABBIT",
    "project": "JACKRABBIT",
    "summary": " inconsistent session and persistent state after ReferentialIntegrityException",
    "systemSpecification": true,
    "version": "1.6.2, 2.1"
}