{
    "comments": [
        {
            "author": null,
            "body": "Created attachment 27375\nExpanded patch\n\nThis expanded patch covers both cluster implementations in 5.5.x and slightly simplifies the proposed patch.",
            "date": "20110811T11:49:22",
            "id": 0
        },
        {
            "author": null,
            "body": "Patch has been applied to 5.5.x and will be included in 5.5.34 onwards.",
            "date": "20110816T13:03:43",
            "id": 1
        }
    ],
    "component": "Catalina:Cluster",
    "description": "Created attachment 27372\nFix (patch), problem description, test case source code.\n\n== Summary:\n\nSession replication fails with ClassNotFoundException when session\nattribute is Java dynamic proxy (java.lang.reflect.Proxy).\n\n== Description:\n\nIn my application I'm storing serializable object in HTTP session\nattribute. One of object references is (serializable) Java dynamic\nproxy (java.lang.reflect.Proxy). Object is properly serializable\n(including proxy) but HTTP session fails to migrate between cluster\nnodes. Receiving node throws ClassNotFoundException on session\ndeserialization.\n\nThis bug is reproducible if session attribute is dynamic proxy itself,\nnot only as part of serialized object graph.\n\n== Cause\n\nTomcat for session migration uses specialized ObjectInputStream\nimplementation:\norg.apache.catalina.cluster.session.ReplicationStream. This class\nproperly overrides #resolveClass(ObjectStreamClass) method to resolve\ndeserialized classes using web application class loader.\n\nHowever deserializing dynamic proxy calls #resolveProxyClass(String[])\nmethod, not #resolveClass(ObjectStreamClass) method. Default\nimplementation of #resolveProxyClass(String[]) in ObjectStreamClass\ncan't see web application classloader that was used to load interfaces\nused by dynamic proxy and deserialization fails with\nClassNotFoundException.\n\n== Solution\n\nReplicationStream#resolveProxyClass(String[]) method should be\noverridden in the same way that #resolveClass(ObjectStreamClass) was.\n\nThis problem was already fixed in Tomcat 6 and Tomcat 7.\n\nAttached patch is modified solution taken from Tomcat 6.0.32.\n\n== Test case\n\n(See attached sample web application for source code, configurations\nand build scripts)\n\nI've got session counter (Counter interface) with two\nimplementations. One is direct implementation (CounterImpl) the other\nis dynamic proxy that uses invocation handler\n(CounterInvocationHandler) that delegates all proxy methods to the\ninstance of direct implementation.\n\nThere are two servlets with single implementation (CounterServlet),\nmapped two different uris. First (mapped to /counter/) creates session\nthat uses direct implementation, second (mapped to\n/counter-with-proxy/) used dynamic proxy implementation.\n\nWhen application is run in the cluster restarting all servers and\naccessing application via /counter/ URL makes session migrate\nproperly.\n\nWhen application is accessed via /counter-with-proxy/ on receiving\nnode ClassNotFoundException is throw:\n\n2011-08-11 09:32:18 org.apache.catalina.cluster.session.SimpleTcpReplicationManager readSession\nSEVERE: Failed to deserialize the session!\njava.lang.ClassNotFoundException: test.Counter\n\tat java.net.URLClassLoader$1.run(URLClassLoader.java:202)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:190)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:306)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:247)\n\tat java.lang.Class.forName0(Native Method)\n\tat java.lang.Class.forName(Class.java:247)\n\tat java.io.ObjectInputStream.resolveProxyClass(ObjectInputStream.java:675)\n\tat java.io.ObjectInputStream.readProxyDesc(ObjectInputStream.java:1530)\n\tat java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1492)\n\tat java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1731)\n\tat java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1328)\n\tat java.io.ObjectInputStream.readObject(ObjectInputStream.java:350)\n\tat org.apache.catalina.session.StandardSession.readObject(StandardSession.java:1459)\n\tat org.apache.catalina.session.StandardSession.readObjectData(StandardSession.java:983)\n\tat org.apache.catalina.cluster.session.ReplicatedSession.readObjectData(ReplicatedSession.java:172)\n\tat org.apache.catalina.cluster.session.SimpleTcpReplicationManager.readSession(SimpleTcpReplicationManager.java:399)\n\tat org.apache.catalina.cluster.session.SimpleTcpReplicationManager.messageReceived(SimpleTcpReplicationManager.java:583)\n\tat org.apache.catalina.cluster.session.SimpleTcpReplicationManager.messageDataReceived(SimpleTcpReplicationManager.java:622)\n\tat org.apache.catalina.cluster.session.ClusterSessionListener.messageReceived(ClusterSessionListener.java:86)\n\tat org.apache.catalina.cluster.tcp.SimpleTcpCluster.receive(SimpleTcpCluster.java:1175)\n\tat org.apache.catalina.cluster.tcp.ClusterReceiverBase.messageDataReceived(ClusterReceiverBase.java:598)\n\tat org.apache.catalina.cluster.io.ObjectReader.execute(ObjectReader.java:108)\n\tat org.apache.catalina.cluster.tcp.TcpReplicationThread.drainChannel(TcpReplicationThread.java:139)\n\tat org.apache.catalina.cluster.tcp.TcpReplicationThread.run(TcpReplicationThread.java:70)\n\n== Steps to reproduce\n\n==== Environment:\n\nLinux Ubuntu:\n\n$ lsb_release -a\nNo LSB modules are available.\nDistributor ID:\tUbuntu\nDescription:\tUbuntu 10.04.3 LTS\nRelease:\t10.04\nCodename:\tlucid\n\nJava (Sun JDK 1.6):\n\n$ /usr/lib/jvm/java-6-sun/bin/java -version\njava version \"1.6.0_26\"\nJava(TM) SE Runtime Environment (build 1.6.0_26-b03)\nJava HotSpot(TM) Server VM (build 20.1-b02, mixed mode)\n\n==== Cluster setup\n\n1. Choose cluster virtual host name and setup it in DNS or /etc/hosts\n   file.\n\n2. Change server names appropriately in provided configuration files:\n\n   - n1/conf/server.xml (cluster node 1 config):\n       - <Engine> defaultHost\n       - <Host> name\n       - <Cluster> clusterName\n\n   - n2/conf/server.xml (cluster node 2 config):\n       - <Engine> defaultHost\n       - <Host> name\n       - <Cluster> clusterName\n\n   - tomcat-cluster.tskutnik.lan.e-point.pl (Apache2 site definition):\n       - ErrorLog location for <VirtualHost: *:80> and <VirtualHost: *:443>\n       - CustomLog location for <VirtualHost: *:80> and <VirtualHost: *:443>\n\n   - workers.properties\n       - worker.servlet-cluster-n1.host\n       - worker.servlet-cluster-n2.host\n\n3. Install modified tomcat-cluster.tskutnik.lan.e-point.pl file\n   as Apache2 site definition (e.g. by putting\n   it in /etc/apache2/sites-enabled/)\n\n4. Install modified workers.properties as mod_jk configuration for\n   Apache2 (e.g. by putting it in /etc/libapache2-mod-jk/)\n\n5. Create two node cluster. Cluster configuration is provided\n   in n1/conf/server.xml and n2/conf/server.xml file.\n\n5.1. Unpack Tomcat 5.5.33 archive in two identical, co-located\n     directories:\n\n   $ mkdir -p ~/work/tomcat-clusters/tomcat-testcase/\n   $ cd ~/work/tomcat-clusters/tomcat-testcase/\n   $ tar zxf ~/Downloads/apache-tomcat-5.5.33.tar.gz\n   $ cp -r apache-tomcat-5.5.33 n1\n   $ mv apache-tomcat-5.5.33 n2\n\n5.2. Install modified configuration files:\n\n   $ cp n1/conf/server.xml ~/work/tomcat-clusters/tomcat-testcase/n1/conf\n   $ cp n2/conf/server.xml ~/work/tomcat-clusters/tomcat-testcase/n2/conf\n\n6. Build sample application:\n\n   $ ./war.sh\n\n   This should build WAR archive placed in file /tmp/et.war. Cluster\n   nodes use this file to load test case application. If you want to\n   put this file somewhere else you should modify your server.xml\n   files accordingly.\n\n7. Restart Apache2 and verify that virtual hosts properly forwards\n   HTTP request to Tomcat Cluster.\n\n==== Reproducing bug\n\n1. Start both cluster nodes:\n\n   $ cd ~/work/tomcat-clusters/tomcat-testcase/n1\n   $ ./bin/startup.sh\n   $ cd ~/work/tomcat-clusters/tomcat-testcase/n2\n   $ ./bin/startup.sh\n\n2. Access application URL via browser, e.g.:\n\n   http://tomcat-cluster.tskutnik.lan.e-point.pl/counter-with-proxy/\n\n   Use virtual hosts name that you used in step 1.\n\n   Browser should display page similar to:\n\n       --------------------------------------------------\n       Requested Session Id: DD0C9C7681453FD12BDFD7F5380D10BC.servlet-cluster-n1\n       Session Id: C2C45A80C69D26D6C1CA5E2800F86306.servlet-cluster-n1\n       Counter: test.CounterImpl@d16fc1; Counter: 2 on server: n1\n       Using proxy: true\n       Counter serialized+deserialized: test.CounterImpl@94257f\n       Server name: n1\n       --------------------------------------------------\n\n   Counter increases by 1 on every request.\n\n   Using proxy determines if counter implementation is dynamic proxy.\n\n   Counter serialized+deserialized demonstrates that counter\n   is serializable.\n\n   Server name (n1 above) determines main node to which HTTP requests\n   are directed from Apache2 web server instance. If main node is n1\n   than receiver node is n2.\n\n3. Examine catalina.out log on receiver node. You should see\n   ClassNotFoundException, e.g:\n\n        --------------------------------------------------\n        2011-08-11 09:32:18 org.apache.catalina.cluster.session.SimpleTcpReplicationManager readSession\n        SEVERE: Failed to deserialize the session!\n        java.lang.ClassNotFoundException: test.Counter\n        \tat java.net.URLClassLoader$1.run(URLClassLoader.java:202)\n        \tat java.security.AccessController.doPrivileged(Native Method)\n        \tat java.net.URLClassLoader.findClass(URLClassLoader.java:190)\n        \tat java.lang.ClassLoader.loadClass(ClassLoader.java:306)\n        \tat java.lang.ClassLoader.loadClass(ClassLoader.java:247)\n        \tat java.lang.Class.forName0(Native Method)\n        \tat java.lang.Class.forName(Class.java:247)\n        \tat java.io.ObjectInputStream.resolveProxyClass(ObjectInputStream.java:675)\n        \tat java.io.ObjectInputStream.readProxyDesc(ObjectInputStream.java:1530)\n        \tat java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1492)\n        \tat java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1731)\n        \tat java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1328)\n        \tat java.io.ObjectInputStream.readObject(ObjectInputStream.java:350)\n        \tat org.apache.catalina.session.StandardSession.readObject(StandardSession.java:1459)\n        \tat org.apache.catalina.session.StandardSession.readObjectData(StandardSession.java:983)\n        \tat org.apache.catalina.cluster.session.ReplicatedSession.readObjectData(ReplicatedSession.java:172)\n        \tat org.apache.catalina.cluster.session.SimpleTcpReplicationManager.readSession(SimpleTcpReplicationManager.java:399)\n        \tat org.apache.catalina.cluster.session.SimpleTcpReplicationManager.messageReceived(SimpleTcpReplicationManager.java:583)\n        \tat org.apache.catalina.cluster.session.SimpleTcpReplicationManager.messageDataReceived(SimpleTcpReplicationManager.java:622)\n        \tat org.apache.catalina.cluster.session.ClusterSessionListener.messageReceived(ClusterSessionListener.java:86)\n        \tat org.apache.catalina.cluster.tcp.SimpleTcpCluster.receive(SimpleTcpCluster.java:1175)\n        \tat org.apache.catalina.cluster.tcp.ClusterReceiverBase.messageDataReceived(ClusterReceiverBase.java:598)\n        \tat org.apache.catalina.cluster.io.ObjectReader.execute(ObjectReader.java:108)\n        \tat org.apache.catalina.cluster.tcp.TcpReplicationThread.drainChannel(TcpReplicationThread.java:139)\n        \tat org.apache.catalina.cluster.tcp.TcpReplicationThread.run(TcpReplicationThread.java:70)\n        --------------------------------------------------\n\n   Killing main node with \"kill -9\" demonstrates that session DID NOT\n   migrate properly to node2 and counter state WAS LOST.\n\n4. You may restart both cluster nodes and try accessing application\n   using /counter/ URI that does not exhibit this behavior.\n\n   Killing main node with \"kill -9\" demonstrates that session DID\n   migrate properly to node2 and counter state WAS NOT LOST.\n\n== Verifying fix\n\nI did not compile Tomcat from scratch to verify my solution. I've only\nrecompiled single class (ReplicationStream), packaged it in JAR\narchive and \"patched' Tomcat by putting this JAR in common/lib\ndirectory:\n\n$ mkdir bin\n$ javac -classpath </path/to/binary>/server/lib/catalina.jar ./apache-tomcat-5.5.33-src-fix/container/modules/cluster/src/share/org/apache/catalina/cluster/session/ReplicationStream.java\" -d bin\n$ jar cf catalina-proxy-serialization-fix.jar -C bin .\n$ cp catalina-proxy-serialization-fix.jar </path/to/binary/>/common/lib\n\nThese steps fixed the bug.",
    "hasPatch": true,
    "hasScreenshot": false,
    "id": "51647",
    "issuetypeClassified": "BUG",
    "issuetypeTracker": "BUG",
    "priority": "P2 normal",
    "product": "Tomcat 5",
    "project": "TOMCAT",
    "summary": "Session replication fails with ClassNotFoundException when session attribute is Java dynamic proxy (java.lang.reflect.Proxy).",
    "systemSpecification": true,
    "version": "5.5.33"
}