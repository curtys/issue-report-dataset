{
    "comments": [
        {
            "author": null,
            "body": "(In reply to comment #0)\n> Interim results of my own little research:\n> - if I request org.apache.catalina.Globals.SSL_CERTIFICATE_ATTR,\n> org.apache.coyote.tomcat4.CoyoteRequest.getAttribute triggers the\n> org.apache.coyote.ActionCode.ACTION_REQ_SSL_CERTIFICATE re-handshake\n\nThis works in 4.1 & 5.0, but has been removed from 5.5.  You would need your \nown custom Valve to do this in 5.5.\n\n> Open issues I haven't mastered so far:\n> 1) If the application allows for self-signed certificates the user uploads \ninto\n> the DB i.e. her profile, is there a way to use a non-global trustStore to\n> validate? Otherwise, with an increasing user-basis, I foresee scalability\n> problems if I had to import all such certificates into a global trust store?\n\nYou probably want an LDAP-based trustStore (e.g. \njava.security.cert.LDAPCertStoreParameters).  Not hard to implement (at least \nfor JDK 1.5), but so far there hasn't been much demand for it.\n\n> 2) javax.net.ssl.SSLServerSocket.setNeedClientAuth in\n> org.apache.tomcat.util.net.jsse.JSSE14SocketFactory.configureClientAuth \nmight be\n> the basis for an alternative approach, but I wouldn't know how to set that \n(or\n> probably rather\n> org.apache.tomcat.util.net.ServerSocketFactory.setAttribute(\"clientAuth\", \ntrue)\n> before the org.apache.tomcat.util.net.jsse.JSSESocketFactory.acceptSocket has\n> already occurred?\n\nThis is where the clientAuth attribute on the <Connector> eventually ends \nup :).\n\n",
            "date": "20050427T21:37:54",
            "id": 0
        },
        {
            "author": null,
            "body": "> You probably want an LDAP-based trustStore (e.g. \n> java.security.cert.LDAPCertStoreParameters).  Not hard to implement (at least \n> for JDK 1.5), but so far there hasn't been much demand for it.\n\nI have already done this\nhttp://issues.apache.org/bugzilla/show_bug.cgi?id=7831\nbut I dont know how well this version works.\nThough I still use it and can reattach my latest version if wanted.\n\nI dont understand why there is so little demand for it, but maybe the time for\nit might come.",
            "date": "20050427T22:07:56",
            "id": 1
        },
        {
            "author": null,
            "body": "it appears that if the client certificate shall not be asked from all users and\nnot upon the first contact with the given connector, the \"clientAuth\" attribute\nisn't it, irrespective of whether set to \"true\" or \"want\".\n\nThe approach appears to be rather to direct the user to a protected jsp/struts\naction at the point in time you want the client cert auth to happen with \n<security-constraint>\n        <web-resource-collection>\n            <web-resource-name>Client Certificate Auth</web-resource-name>\n            <url-pattern>/certBasedAuth.do</url-pattern>\n        </web-resource-collection>\n        <auth-constraint />\n    </security-constraint>\n    <login-config>\n        <auth-method>CLIENT-CERT</auth-method>\n    </login-config>\n\nBeing flexible with respect to the used certificate remains tricky:\n1) if already knowing the certificate to be expected e.g. by virtue of it being\nin a LDAP truststore, it appears to be impossible to allow for mismatches of the\ncerts[0].getSubjectDN().getName() without replacing the current\norg.apache.catalina.authenticator.SSLAuthenticator\n- one might for example rather use the SHA1 fingerprint to match?\n2) similarly, if you want to be more tolerant on certificate\nexpiration/not-yet-valid, I haven't figured how to get the \"validate=false\" for\norg.apache.catalina.realm.RealmBase.authenticate(X509Certificate[] certs) from a\nconfig file without altering sources.\n3) As for self-signed certificates, I see two approaches \na) be able to create a mini-trust-store on the fly before the ssl-handshake\noccurs in org.apache.tomcat.util.net.jsse.JSSESupport.handShake()  - I have no\nclue how late in an SSLSocket's life its truststore can be altered? A nice\nexample how this can be done a per thread basis (albeit before creating the\nsocket and not when it's already in operation) is Oleg's\norg.apache.commons.httpclient.contrib.ssl.AuthSSLProtocolSocketFactory (see Bug\n34391) - I guess this implies that the web-app programmer in some way (by means\nof an enhanced LoginConfig or an extra parameter of the method or a session\nattribute?) might tell\norg.apache.catalina.authenticator.SSLAuthenticator.authenticate() the\nself-signed cert it should expect when that method starts\nb) alternatively, a less rigid TrustManager might be used in\norg.apache.tomcat.util.net.jsse.JSSE15SocketFactory.getTrustManagers(String \n keystoreType, String algorithm) - some ideas are in\nhttp://forum.java.sun.com/thread.jspa?forumID=2&threadID=411937",
            "date": "20050509T23:49:02",
            "id": 2
        },
        {
            "author": null,
            "body": "Created attachment 14994\npatched SSLAuthenticator.java\n\nThanks to Bill for the help to get it kind of working without the need to\nconfigure a realm - how to do this:\nA) compile the attached and place it in\ntomcat/server/classes/org/apache/catalina/authenticator/ such that the\nclass-loader finds it before the same one in the catalina.jar\nB) the web.xml's <auth-constraint> better has a nested\n     <role-name>*</role-name>\notherwise despite a successful hand-shake, the access control will fail the\nprocess\nC) Till now, my browsers (MSIE6 and firefox1.0.3) after one successful login\ncan always login again despite configuring my CSP to prompt for password upon\neach access to the private key. I attempted to force a re-handshake every time\nand tried to avoid a server-side caching of the principal/certs, but I didn't\nsucceed so far. Closing the browser after logoff avoids the problem.\nNo clue - perhaps the server is clean and it is the browsers that cache the\ncerts as long as the socket lives due to the HTTP-keep-alive. If it were the\nservers fault, I guess it would be adequate that a session.invalidate() would\nalso wipe the certs from a previous cert-based authentication.\nD) If you have multiple private keys and corresponding certificates in your\nbrower's certificate store, the browsers do not offer any self-signed certs to\nuse for client-cert-auth. Haven't tried the remedies brain-stormed in comment 3\nitem 3, but my suspicion is that this is rather due to browser side\nimplementation.",
            "date": "20050511T15:29:15",
            "id": 3
        },
        {
            "author": null,
            "body": "as per comment 4 item D), got (pseudo-)self signed certs working (it is not the\nbrowser's fault), i.e. I first created a self-signed (root9cert), signed the\nuser-cert with it and imported the root-cert into the\n$JAVA_HOME/jre/lib/security/cacerts for tomcat. Since this doesn't scale as\nmentioned in  and in the described in item 3 GUI/application control flow, the\nsession may well exist before the CLIENT-CERT is executed:\ni) register trust-store with user-self-signed cert in session for the user to be\nauthenticated as per Bug 34868\nii) response.sendRedirect(/certBasedAuth.do);\n    now that trust-store would be effective upon the subsequent request doing\nthe auth",
            "date": "20050511T18:28:49",
            "id": 4
        },
        {
            "author": null,
            "body": "Ralf said that <role-name>*</role-name> should be add into the <auth-\nconstraint> element. The inserted element authorizes all the right to access \nthe resource to  the roles defined in this web application.\n\nHe is right, but I think that he is not absolutely right. It is obvious that we \nshould not be forced to authorize the right to all the roles.\n\nI put some information here, I hope that I can help some people to understand \nthe stuff. Let's look at the bigger picture:\nwhen the requested resource is constrained with different roles, we need a map \nbetween the user & the role to access the resource. Even when the resource is \nconstrained with transfering, since the specification starts there is no access \nif no role is defined. In such a case, as Ralf said, we use \"*\" to indicate \nthere is no role constraint.\n\nWe know that only the right persons are allowed to access the constrained \nresource. In a web application, we use two maps to define the right persons:\nOne map (1) is in application descriptor, in the security constraint. the map \nis between the resource & the roles to access it. Another map (2) is in tomcat-\nusers.xml, between persons identified by usernames & the roles.\n\nWhen we use Basic, Digest, & Form, the user inputs his/her username & password \nfor a specific resource. If the input password is same as the one stored with \nus, which is stored in tomcat-users.xml, too. we regard the user who is \nrequiring the resource is the person defined in tomcat-users.xml. Furthermore, \nwe can know his/her roles according to map 2, and we can know whether the user \nhas the right to access the resource. In these cases, actually there is one \nmore map (3) which is between the username & its password.\n\nFor whatever reasons, When we use \"client-authentication\", the relationship is \nnot so clear. The most possible reason is the complication of this \nauthentication. However, authentication is just a method to verify the user is \nthe person he/she claimed to be. In those above cases, as long as the input \npassword is same as the one stored with us, we regard the user as the person \ndefined in tomcat-users.xml. Whether the person has the right to access the \nrequired resource, we will have to check the first two maps mentioned (map 1 & \nmap 2).\n\nIn the case of \"client-auth\", as long as the certificate is verified, we \nbelieve that the user is the person. Now we can see, this authentication \neliminate the neccessity for map 3. However, we still need map 2, the map \nbetween persons & roles. At present, map 2 is undefined.\n\nIn other methods, we use a username to identify a person. When using a \ncertificate, it is not a simple thing to indentify a person (in certificate, \nthey use the term \"subject\", in Java & tomcat, we use the term \"principal\"),\nsince the certificate system has to cover all human beings.\nAnd it seems that the certificate system also introduce a map (4) between \npersons/subjects & certificates. So here, we need map 2 (between persons & \nroles) & map 4 (between persons & certificates). \n\nHowever, since certificates include usage information. So, it is reasonable to \nmap certificates to roles. If we go with this direction, we might lose some \nflexibility, but more security control. Let's name this map as map 5. For \ntomcat, I believe that finally, both of them will be supported.\n\nWhen the system has only a few users, then there is no problem no matter where \nwe put all the certificates. When the system has many users, then we have to \nplan where to put these certificates, and how to verify them in order to have a \nbetter performance.\nWe have at least the following 5 options:\n1. put in the keystore where we put our server authentication certificate.\n2. put into a serie of xml file.\n3. put into a local Database on the same machine or different machine.\n4. put into LDAP on the same machine or different machine.\n5. leave them on the internet\n6. combination of these, for example ca certificate on local, others on the \ninternet.\n\nThe team has developed many realms for us, and here are some extra information.\n\nhttp://issues.apache.org/bugzilla/attachment.cgi?id=6666\nimplemented a class com.ops.webcontrol.tomcat.JNDIRealmCertAD\n\nhttp://issues.apache.org/bugzilla/show_bug.cgi?id=7831\nJDBCRealm\n\nhttp://issues.apache.org/bugzilla/show_bug.cgi?id=34643\n\nhttp://issues.apache.org/bugzilla/attachment.cgi?id=1499\norg.apache.catalina.realm.JNDIRealm\n\nhttp://issues.apache.org/bugzilla/attachment.cgi?id=14994\n\nAbout how complicated it is to identify a subject, please refer to \nhttp://www.ietf.org/rfc/rfc2459.txt for more information.\nFor example, in a X509 certificate, (I am not sure whether there is any other \nkind of certificate system), The \"subject\" field is unique for that the CA \nissuing the certificate, but it might be empty. The \"subjectUniqueID\" field \nmight be also only unique for this specific CA.\n\nFor his item C in comment #4, I guess the \"clear SSL states\" button which is \nbesides the \"certificates\" button might help.\n(In reply to comment #0)\n> http://jakarta.apache.org/tomcat/tomcat-5.5-doc/ssl-howto.html#Edit%20the%\n20Tomcat%20Configuration%20File\n> nicely documents how to enable \"clientAuth\" on a global basis.\n> A web application may well have a mixed user community, some authenticate by\n> means of a password or other authenticators, others have a certificate for\n> authentication.\n> The goal of this RFE is to amend the documentation with how the clientAuth\n> mechanism can be triggered and enforced on a per user basis.\n> Interim results of my own little research:\n> - if I request org.apache.catalina.Globals.SSL_CERTIFICATE_ATTR,\n> org.apache.coyote.tomcat4.CoyoteRequest.getAttribute triggers the\n> org.apache.coyote.ActionCode.ACTION_REQ_SSL_CERTIFICATE re-handshake\n> - to enforce this for a given user, I guess I could store that certificate in\n> the session and for every subsequent request test whether the cert is stored \nor\n> otherwise trigger the re-handshake by asking for SSL_CERTIFICATE_ATTR.\n> Open issues I haven't mastered so far:\n> 1) If the application allows for self-signed certificates the user uploads \ninto\n> the DB i.e. her profile, is there a way to use a non-global trustStore to\n> validate? Otherwise, with an increasing user-basis, I foresee scalability\n> problems if I had to import all such certificates into a global trust store?\n> 2) javax.net.ssl.SSLServerSocket.setNeedClientAuth in\n> org.apache.tomcat.util.net.jsse.JSSE14SocketFactory.configureClientAuth might \nbe\n> the basis for an alternative approach, but I wouldn't know how to set that (or\n> probably rather\n> org.apache.tomcat.util.net.ServerSocketFactory.setAttribute(\"clientAuth\", \ntrue)\n> before the org.apache.tomcat.util.net.jsse.JSSESocketFactory.acceptSocket has\n> already occurred?\n> related mailing list threads probably are:\n> http://marc.theaimsgroup.com/?l=tomcat-user&m=105300671215744&w=2 and\n> http://marc.theaimsgroup.com/?l=tomcat-user&m=104581231518394&w=2\n\n",
            "date": "20051231T17:07:17",
            "id": 5
        },
        {
            "author": null,
            "body": "Ralf said that <role-name>*</role-name> should be add into the <auth-\nconstraint> element. The inserted element authorizes all the right to access \nthe resource to  the roles defined in this web application.\n\nHe is right, but I think that he is not absolutely right. It is obvious that we \nshould not be forced to authorize the right to all the roles.\n\nI put some information here, I hope that I can help some people to understand \nthe stuff. Let's look at the bigger picture:\nwhen the requested resource is constrained with different roles, we need a map \nbetween the user & the role to access the resource. Even when the resource is \nconstrained with transfering, since the specification starts there is no access \nif no role is defined. In such a case, as Ralf said, we use \"*\" to indicate \nthere is no role constraint.\n\nWe know that only the right persons are allowed to access the constrained \nresource. In a web application, we use two maps to define the right persons:\nOne map (1) is in application descriptor, in the security constraint. the map \nis between the resource & the roles to access it. Another map (2) is in tomcat-\nusers.xml, between persons identified by usernames & the roles.\n\nWhen we use Basic, Digest, & Form, the user inputs his/her username & password \nfor a specific resource. If the input password is same as the one stored with \nus, which is stored in tomcat-users.xml, too. we regard the user who is \nrequiring the resource is the person defined in tomcat-users.xml. Furthermore, \nwe can know his/her roles according to map 2, and we can know whether the user \nhas the right to access the resource. In these cases, actually there is one \nmore map (3) which is between the username & its password.\n\nFor whatever reasons, When we use \"client-authentication\", the relationship is \nnot so clear. The most possible reason is the complication of this \nauthentication. However, authentication is just a method to verify the user is \nthe person he/she claimed to be. In those above cases, as long as the input \npassword is same as the one stored with us, we regard the user as the person \ndefined in tomcat-users.xml. Whether the person has the right to access the \nrequired resource, we will have to check the first two maps mentioned (map 1 & \nmap 2).\n\nIn the case of \"client-auth\", as long as the certificate is verified, we \nbelieve that the user is the person. Now we can see, this authentication \neliminate the neccessity for map 3. However, we still need map 2, the map \nbetween persons & roles. At present, map 2 is undefined.\n\nIn other methods, we use a username to identify a person. When using a \ncertificate, it is not a simple thing to indentify a person (in certificate, \nthey use the term \"subject\", in Java & tomcat, we use the term \"principal\"),\nsince the certificate system has to cover all human beings.\nAnd it seems that the certificate system also introduce a map (4) between \npersons/subjects & certificates. So here, we need map 2 (between persons & \nroles) & map 4 (between persons & certificates). \n\nHowever, since certificates include usage information. So, it is reasonable to \nmap certificates to roles. If we go with this direction, we might lose some \nflexibility, but more security control. Let's name this map as map 5. For \ntomcat, I believe that finally, both of them will be supported.\n\nWhen the system has only a few users, then there is no problem no matter where \nwe put all the certificates. When the system has many users, then we have to \nplan where to put these certificates, and how to verify them in order to have a \nbetter performance.\nWe have at least the following 5 options:\n1. put in the keystore where we put our server authentication certificate.\n2. put into a serie of xml file.\n3. put into a local Database on the same machine or different machine.\n4. put into LDAP on the same machine or different machine.\n5. leave them on the internet\n6. combination of these, for example ca certificate on local, others on the \ninternet.\n\nThe team has developed many realms for us, and here are some extra information.\n\nhttp://issues.apache.org/bugzilla/attachment.cgi?id=6666\nimplemented a class com.ops.webcontrol.tomcat.JNDIRealmCertAD\n\nhttp://issues.apache.org/bugzilla/show_bug.cgi?id=7831\nJDBCRealm\n\nhttp://issues.apache.org/bugzilla/show_bug.cgi?id=34643\n\nhttp://issues.apache.org/bugzilla/attachment.cgi?id=1499\norg.apache.catalina.realm.JNDIRealm\n\nhttp://issues.apache.org/bugzilla/attachment.cgi?id=14994\n\nAbout how complicated it is to identify a subject, please refer to \nhttp://www.ietf.org/rfc/rfc2459.txt for more information.\nFor example, in a X509 certificate, (I am not sure whether there is any other \nkind of certificate system), The \"subject\" field is unique for that the CA \nissuing the certificate, but it might be empty. The \"subjectUniqueID\" field \nmight be also only unique for this specific CA.\n\nFor his item C in comment #4, I guess the \"clear SSL states\" button which is \nbesides the \"certificates\" button might help.\n",
            "date": "20051231T17:08:55",
            "id": 6
        },
        {
            "author": null,
            "body": "Jack, \n\nthanks for your explanations.\n\n\"Clear SSL State\" appears to be a MSIE feature - is there a FireFox equivalent ?\nHow about opera, konqueror, etc.\n\nRalf\n\nP.S.: Just FYI, option B of comment 4 no longer works (5.5.17) and apparently is\nagainst the specs (bug 39364)",
            "date": "20060808T15:25:19",
            "id": 7
        },
        {
            "author": null,
            "body": "Ralf and jack: thank you for these great comments and examples.  I've updated\nthe SSL HowTo, and connector configuration reference on clientAuth, and the\nheader comment on SSLAuthenticator.java to link here so that others can benefit\nfrom these insights.  Ralf, since you're a committer now, if you feel like\nfurther documentation changes are required, you can reopen this issue and assign\nit to yourself for further work.",
            "date": "20061224T08:31:17",
            "id": 8
        },
        {
            "author": null,
            "body": "see also bug 41883 ",
            "date": "20070319T01:30:57",
            "id": 9
        },
        {
            "author": null,
            "body": "see also Bug 48157 and Bug 48158",
            "date": "20091107T08:09:50",
            "id": 10
        }
    ],
    "component": "Connector:Coyote",
    "description": "http://jakarta.apache.org/tomcat/tomcat-5.5-doc/ssl-howto.html#Edit%20the%20Tomcat%20Configuration%20File\nnicely documents how to enable \"clientAuth\" on a global basis.\nA web application may well have a mixed user community, some authenticate by\nmeans of a password or other authenticators, others have a certificate for\nauthentication.\n\nThe goal of this RFE is to amend the documentation with how the clientAuth\nmechanism can be triggered and enforced on a per user basis.\n\nInterim results of my own little research:\n- if I request org.apache.catalina.Globals.SSL_CERTIFICATE_ATTR,\norg.apache.coyote.tomcat4.CoyoteRequest.getAttribute triggers the\norg.apache.coyote.ActionCode.ACTION_REQ_SSL_CERTIFICATE re-handshake\n- to enforce this for a given user, I guess I could store that certificate in\nthe session and for every subsequent request test whether the cert is stored or\notherwise trigger the re-handshake by asking for SSL_CERTIFICATE_ATTR.\n\nOpen issues I haven't mastered so far:\n1) If the application allows for self-signed certificates the user uploads into\nthe DB i.e. her profile, is there a way to use a non-global trustStore to\nvalidate? Otherwise, with an increasing user-basis, I foresee scalability\nproblems if I had to import all such certificates into a global trust store?\n2) javax.net.ssl.SSLServerSocket.setNeedClientAuth in\norg.apache.tomcat.util.net.jsse.JSSE14SocketFactory.configureClientAuth might be\nthe basis for an alternative approach, but I wouldn't know how to set that (or\nprobably rather\norg.apache.tomcat.util.net.ServerSocketFactory.setAttribute(\"clientAuth\", true)\nbefore the org.apache.tomcat.util.net.jsse.JSSESocketFactory.acceptSocket has\nalready occurred?\n\nrelated mailing list threads probably are:\nhttp://marc.theaimsgroup.com/?l=tomcat-user&m=105300671215744&w=2 and\nhttp://marc.theaimsgroup.com/?l=tomcat-user&m=104581231518394&w=2",
    "hasPatch": false,
    "hasScreenshot": false,
    "id": "34643",
    "issuetypeClassified": "OTHER",
    "issuetypeTracker": "RFE",
    "priority": "P2 enhancement",
    "product": "Tomcat 5",
    "project": "TOMCAT",
    "summary": "document how to use certificate-based \"clientAuth\" on a per user or per session basis also with self-signed/expired client certs",
    "systemSpecification": true,
    "version": "Nightly Build"
}