{
    "comments": [
        {
            "author": null,
            "body": "I'm guessing that this is a problem with Tomcat not abandoning the mark \nproperly, but haven't confirmed it yet.\n\nIf you try setting a mark on your test case, it might help in getting a \nreproducable case to test this.",
            "date": "20050506T02:19:13",
            "id": 0
        },
        {
            "author": null,
            "body": "That, and please retest in 5.5.9 and let us know.",
            "date": "20050722T14:13:52",
            "id": 1
        },
        {
            "author": null,
            "body": "Reading the OP's comments, the issue is, AFAICT, the same as described in bug 38346.\n\nHaving tested the latest code extensively I can recreate the conditions\ndescribed in this bug but Tomcat always behaves correctly. I am taking this as\nsufficient evidence that the root cause of this issue is the same as that in 38346.",
            "date": "20060927T01:56:50",
            "id": 2
        }
    ],
    "component": "Catalina:Modules",
    "description": "Well...I can supply quite a bit of info, but I can't say you'll have an easy \ntime reproducing the problem.\n\nFirst off, let me provide you with the exception that we experienced.\n\njava.lang.ArrayIndexOutOfBoundsException\n        at java.lang.System.arraycopy(Native Method)\n        at org.apache.tomcat.util.buf.CharChunk.append(CharChunk.java:298)\n        at org.apache.tomcat.util.buf.B2CConverter.convert\n(B2CConverter.java:97)\n        at org.apache.tomcat.util.buf.B2CConverter.convert\n(B2CConverter.java:76)\n        at org.apache.catalina.connector.InputBuffer.realReadChars\n(InputBuffer.java:339)\n        at org.apache.tomcat.util.buf.CharChunk.substract(CharChunk.java:384)\n        at org.apache.catalina.connector.InputBuffer.read(InputBuffer.java:350)\n        at org.apache.catalina.connector.CoyoteReader.read\n(CoyoteReader.java:80)\n        at com.spicer.jdl.MatrixXMLSerializable.decodeMime64\n(MatrixXMLSerializable.java:142)\n        at com.spicer.jdl.MatrixXMLSerializable.parseMime64\n(MatrixXMLSerializable.java:523)\n        at com.spicer.jdl.MatrixXMLSerializable.decodeByteArrayRaw\n(MatrixXMLSerializable.java:710)\n        at com.spicer.jdl.MatrixXMLSerializable.decodeByteArray\n(MatrixXMLSerializable.java:641)\n        at com.spicer.jdl.MatrixXMLDispatch.dispatch_ClientWrapperServer\n(MatrixXMLDispatch.java:109)\n        at com.spicer.jdl.MatrixXMLDispatch.dispatch(MatrixXMLDispatch.java:62)\n        at com.spicer.servlet.MatrixXMLServlet.doPost(Unknown Source)\n        at javax.servlet.http.HttpServlet.service(HttpServlet.java:709)\n        at javax.servlet.http.HttpServlet.service(HttpServlet.java:802)\n        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter\n(ApplicationFilterChain.java:237)\n        at org.apache.catalina.core.ApplicationFilterChain.doFilter\n(ApplicationFilterChain.java:157)\n        at org.apache.catalina.core.StandardWrapperValve.invoke\n(StandardWrapperValve.java:214)\n        at org.apache.catalina.core.StandardContextValve.invoke\n(StandardContextValve.java:178)\n        at org.apache.catalina.core.StandardHostValve.invoke\n(StandardHostValve.java:126)\n        at org.apache.catalina.valves.ErrorReportValve.invoke\n(ErrorReportValve.java:105)\n        at org.apache.catalina.core.StandardEngineValve.invoke\n(StandardEngineValve.java:107)\n        at org.apache.catalina.connector.CoyoteAdapter.service\n(CoyoteAdapter.java:148)\n        at org.apache.coyote.http11.Http11Processor.process\n(Http11Processor.java:825)\n        at \norg.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.processConnecti\non(Http11Protocol.java:731)\n        at org.apache.tomcat.util.net.PoolTcpEndpoint.processSocket\n(PoolTcpEndpoint.java:526)\n        at org.apache.tomcat.util.net.LeaderFollowerWorkerThread.runIt\n(LeaderFollowerWorkerThread.java:80)\n        at org.apache.tomcat.util.threads.ThreadPool$ControlRunnable.run\n(ThreadPool.java:684)\n        at java.lang.Thread.run(Thread.java:595)\n\n\nThis exception occurred in Tomcat 5.5.4 whenever we had a larger post to the \nservlet.\n\nWe have a java based client-server product that uses a servlet when being \ndeployed for internet use.  Essentially, the client converts the calls into an \nXML stream which it posts to the servlet (called MatrixXMLServlet) that then \nconverts the data back into an RMI call for the server portion of the product.\n\nThis servlet has been in use, unchanged, for nearly 4 years and hasn't caused \nan error until now.  It works fine with versions of Tomcat before 5.0, but \ndoesn't with 5.5 (I'm not 100% sure about 5.0 so I'll leave it out).\n\nUsing the FAQ as a guide, I searched for solutions and/or others with the same \nproblem, but was unable to find anything.  So, I traced through the Tomcat \nsource code to see if I could understand the problem...and I'm convinced (with \nlittle doubt) that there is a Tomcat bug...but I'm not sure what causes the \nclasses to be set up this way.  So...I'll describe what I found...maybe it \nwill help.\n\nFirst of all, the doPost() in MatrixXMLServlet does a getReader() on the \nHttpServletRequest it is passed, and this reader is then set in the \nMatrixXMLSerializable object.  Then, in the decodeMime64() method, we loop \nreading one character at a time from the BufferedReader (as supplied by \ngetReader()) and process it until we exhaust the stream.  But, on larger posts \n(I think those greater than 8192 characters), we get the exception listed \nabove when trying to read that single character.\n\nNow, in this case, the BufferedReader supplied is a CoyoteReader which in turn \nhas an InputBuffer, which in turn has a CharChunk, a ByteChunk, and a \nB2CConverter.  For a read, the CoyoteReader does a read on InputBuffer, which \nthen asks CharChunk for the character.  The CharChunk returns the next \ncharacter that it has in its buffer, but if it has reached the end of what is \navailable it asks InputBuffer for x more characters (where x is the amount of \nspace left in its buffer).\n\nNow...here is the problem number 1 ...rather than providing the CharChunk with \nat most x characters (or resetting the CharChunk if x=0), the InputBuffer asks \nB2CConverter to transfer everything that ByteChunk has in its buffer (and then \nrefills ByteChunk).\n\nSo...if there is not enough space left in the CharChunk buffer to add this \nmuch data, it tries to accomodate by filling to the limit with what will fit, \nflushing the buffer and then adding the remainder.  But, this leads to the \nproblem we see, because of what the flush actually does (or more \nprecisely \"doesn't do\").  Essentially, in our case, the start and end pointers \nare at the same place (which is why CharChunk asks for more data in the first \nplace) and so after filling to the end of the buffer, the flush actually does \nnothing (except set a flag in the InputBuffer) and then trying to add the rest \nof the data into the buffer causes it to go past the end of the buffer and \ngenerates our exception.  That is problem number 2.\n\nBUT...if this 2nd insert into the CharChunk buffer doesn't cause the exception \nwe have, then you've lost the data from the 1st insert, because it has been \noverwritten by the 2nd insert...thus losing data out of the input stream.  \nOkay...this is problem number 3.\n\nOne possible solution would be to allow the buffer in CharChunk to \"wrap\" \naround the end...but then you have to be careful that you don't add more to \nthe start of the buffer than can fit, or you have another case of losing data \nfrom the overlap of the 1st insert and the 2nd insert.\n\nAnd...you can't simply reset the start pointer (in CharChunk) upon a flush, \nbecause then you'd loose all the data from the 1st insert again...and that's a \nno-no.\n\nI think the whole thing needs to be examined a little more carefully.\nI suspect that solving problem 1 (and also providing a way to \"reset\" the \nCharChunk...perhaps when it requests x=0 more characters) would make the whole \nthing work as desired.\n\n\nAnyway...we have changed our code in MatrixXMLServlet so that instead of using \ngetReader(), we use getInputStream()...and using \nHttpServletRequest.getCharacterEncoding(), we wrap the input stream inside an \nInputStreamReader, and then wrap that inside a BufferedReader.\nThus, using this alternative way to read the inputstream eliminates the \nproblem for us.\n\n\nNow...to post this bug, I tried to reproduce the problem with a small, and \nsimple, servlet that simply used the getReader() call and then consumed the \ninput stream one character at a time...and then generating sufficiently large \nposts to exceed the 8K size.  But, the problem didn't occur.\n\nSo...I don't know what must happen to exactly cause the setup we see inside \nthe CoyoteReader.  We have a working solution now, and I can't afford anymore \ntime tracing and debugging Tomcat code...so I hope this is of some help to you.\n\nIf you have questions, feel free to ask and I'll answer to the best of my \nknowledge.\n\nThanks.\nGreg",
    "hasPatch": false,
    "hasScreenshot": false,
    "id": "34769",
    "issuetypeClassified": "BUG",
    "issuetypeTracker": "BUG",
    "priority": "P3 normal",
    "product": "Tomcat 5",
    "project": "TOMCAT",
    "summary": "ArrayIndexOutOfBoundsException occurs when reading more than 8192 bytes from the BufferedReader supplied by HttpServletRequest.getReader()",
    "systemSpecification": true,
    "version": "5.5.4"
}