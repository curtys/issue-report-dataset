{
    "comments": [
        {
            "author": null,
            "body": "Created attachment 14964\nThis patch adds IOException trapping to CGIServlet, to ensure process termination. It also adds a watchdog timer to kill off the CGI Process after a configurable timeout.",
            "date": "20050508T06:49:21",
            "id": 0
        },
        {
            "author": null,
            "body": "changing component.",
            "date": "20060417T01:13:54",
            "id": 1
        },
        {
            "author": null,
            "body": "I have applied the IOException part of the patch but left the watchdog element\nfor future consideration. I have changed the severity and summary accordingly.\n",
            "date": "20060722T00:35:25",
            "id": 2
        },
        {
            "author": null,
            "body": "My vote is -0 on the timeout.  Mark, if you feel like doing this, great, I won't\nstand in the way.  But if not, let's close this Bugzilla issue.",
            "date": "20070325T13:52:29",
            "id": 3
        },
        {
            "author": null,
            "body": "Closing this as fixed without applying the watchdog changes.",
            "date": "20110408T17:51:10",
            "id": 4
        }
    ],
    "component": "Servlets:CGI",
    "description": "CGIServlet does not kill CGI child process on IOException, nor terminate child\nafter a timeout.\n\nWe had a problem where a CGI child process (in perl, on windows) remained\nrunning for a long time. In some situations where the client disconnected, an\nIOException was thrown in the servlet, but this did not result in a cleanup of\nthe CGI child process. This was a problem as our CGI program accessed a single\nthreaded resource over TCP, and could therefore lock the system up indefinitly.\n\n===\n\n--- CGIServlet.java\tSun May 08 04:46:05 2005\n+++\nC:\\Temp\\hjakarta-tomcat-5.5.9-src.tar\\jakarta-tomcat-5.5.9-src\\jakarta-tomcat-catalina\\catalina\\src\\share\\org\\apache\\catalina\\servlets\\CGIServlet.java\nSat Mar 26 18:24:02 2005\n@@ -267,8 +267,6 @@\n     private String parameterEncoding = System.getProperty(\"file.encoding\",\n                                                           \"UTF-8\");\n \n-    private long lScriptTimeoutMillis = 2000;\n-\n     /** object used to ensure multiple threads don't try to expand same file */\n     static Object expandFileLock = new Object();\n \n@@ -332,16 +330,10 @@\n             cgiExecutable = value;\n         }\n \n-\n         value = getServletConfig().getInitParameter(\"parameterEncoding\");\n         if (value != null) {\n             parameterEncoding = value;\n         }\n-        // Added by CJD\n-        value = getServletConfig().getInitParameter(\"scriptTimeout\");\n-        if (value != null) {\n-            lScriptTimeoutMillis = Integer.valueOf(value).intValue();\n-        }\n \n         // Identify the internal container resources we need\n         context = config.getServletContext();\n@@ -1440,7 +1432,7 @@\n      */\n \n     protected class CGIRunner {\n-        private Process proc = null;\n+\n         /** script/command to be executed */\n         private String command = null;\n \n@@ -1656,6 +1648,7 @@\n             InputStream cgiOutput = null;\n             BufferedReader commandsStdErr = null;\n             BufferedOutputStream commandsStdIn = null;\n+            Process proc = null;\n             int bufRead = -1;\n \n             //create query arguments\n@@ -1731,200 +1724,138 @@\n             }\n \n             rt = Runtime.getRuntime();\n-            try {\n+            proc = rt.exec(cmdAndArgs.toString(), hashToStringArray(env), wd);\n \n-                proc = rt.exec(cmdAndArgs.toString(), hashToStringArray(env), wd);\n+            if(contentStream != null) {\n+                commandsStdIn = new BufferedOutputStream(proc.getOutputStream());\n+                commandsStdIn.write(contentStream.toByteArray());\n+                commandsStdIn.flush();\n+                commandsStdIn.close();\n+            }\n \n-                if(contentStream != null) {\n-                    commandsStdIn = new\nBufferedOutputStream(proc.getOutputStream());\n-                    commandsStdIn.write(contentStream.toByteArray());\n-                    commandsStdIn.flush();\n-                    commandsStdIn.close();\n-                }\n+            /* we want to wait for the process to exit,  Process.waitFor()\n+             * is useless in our situation; see\n+             * http://developer.java.sun.com/developer/\n+             *                               bugParade/bugs/4223650.html\n+             */\n \n-                /* we want to wait for the process to exit,  Process.waitFor()\n-                 * is useless in our situation; see\n-                 * http://developer.java.sun.com/developer/\n-                 *                               bugParade/bugs/4223650.html\n-                 */\n-\n-                boolean isRunning = true;\n-                commandsStdErr = new BufferedReader\n-                    (new InputStreamReader(proc.getErrorStream()));\n-                BufferedWriter servletContainerStdout = null;\n+            boolean isRunning = true;\n+            commandsStdErr = new BufferedReader\n+                (new InputStreamReader(proc.getErrorStream()));\n+            BufferedWriter servletContainerStdout = null;\n \n-                try {\n-                    if (response.getOutputStream() != null) {\n-                        servletContainerStdout =\n-                            new BufferedWriter(new OutputStreamWriter\n-                                (response.getOutputStream()));\n-                    }\n-                } catch (IOException ignored) {\n-                    //NOOP: no output will be written\n+            try {\n+                if (response.getOutputStream() != null) {\n+                    servletContainerStdout =\n+                        new BufferedWriter(new OutputStreamWriter\n+                            (response.getOutputStream()));\n                 }\n-                final BufferedReader stdErrRdr = commandsStdErr ;\n+            } catch (IOException ignored) {\n+                //NOOP: no output will be written\n+            }\n+            final BufferedReader stdErrRdr = commandsStdErr ;\n \n-                new Thread() {\n-                        public void run () {\n-                            sendToLog(stdErrRdr) ;\n-                        } ;\n-                    }.start() ;\n-\n-\n-                new Thread() {\n-                        public void run () {\n-                            deadProcWatcher(proc,lScriptTimeoutMillis) ;\n-                        } ;\n-                    }.start() ;\n-\n-                InputStream cgiHeaderStream =\n-                    new HTTPHeaderInputStream(proc.getInputStream());\n-                BufferedReader cgiHeaderReader =\n-                    new BufferedReader(new InputStreamReader(cgiHeaderStream));\n-                boolean isBinaryContent = false;\n+            new Thread() {\n+                public void run () {\n+                    sendToLog(stdErrRdr) ;\n+                } ;\n+            }.start() ;\n+\n+            InputStream cgiHeaderStream =\n+                new HTTPHeaderInputStream(proc.getInputStream());\n+            BufferedReader cgiHeaderReader =\n+                new BufferedReader(new InputStreamReader(cgiHeaderStream));\n+            boolean isBinaryContent = false;\n             \n-\n-\n-                while (isRunning) {\n-                    try {\n-                        //set headers\n-                        String line = null;\n-                        while (((line = cgiHeaderReader.readLine()) != null)\n-                               && !(\"\".equals(line))) {\n-                            if (debug >= 2) {\n-                                log(\"runCGI: addHeader(\\\"\" + line + \"\\\")\");\n-                            }\n-                            if (line.startsWith(\"HTTP\")) {\n-                                //TODO: should set status codes (NPH support)\n-                                /*\n-                                 * response.setStatus(getStatusCode(line));\n-                                 */\n-                            } else if (line.indexOf(\":\") >= 0) {\n-                                String header =\n-                                    line.substring(0, line.indexOf(\":\")).trim();\n-                                String value =\n-                                    line.substring(line.indexOf(\":\") + 1).trim(); \n-                                response.addHeader(header , value);\n-                                if ((header.toLowerCase().equals(\"content-type\"))\n-                                    && (!value.toLowerCase().startsWith(\"text\"))) {\n-                                    isBinaryContent = true;\n-                                }\n-                            } else {\n-                                log(\"runCGI: bad header line \\\"\" + line + \"\\\"\");\n+            while (isRunning) {\n+                try {\n+                    //set headers\n+                    String line = null;\n+                    while (((line = cgiHeaderReader.readLine()) != null)\n+                           && !(\"\".equals(line))) {\n+                        if (debug >= 2) {\n+                            log(\"runCGI: addHeader(\\\"\" + line + \"\\\")\");\n+                        }\n+                        if (line.startsWith(\"HTTP\")) {\n+                            //TODO: should set status codes (NPH support)\n+                            /*\n+                             * response.setStatus(getStatusCode(line));\n+                             */\n+                        } else if (line.indexOf(\":\") >= 0) {\n+                            String header =\n+                                line.substring(0, line.indexOf(\":\")).trim();\n+                            String value =\n+                                line.substring(line.indexOf(\":\") + 1).trim(); \n+                            response.addHeader(header , value);\n+                            if ((header.toLowerCase().equals(\"content-type\"))\n+                                && (!value.toLowerCase().startsWith(\"text\"))) {\n+                                isBinaryContent = true;\n                             }\n+                        } else {\n+                            log(\"runCGI: bad header line \\\"\" + line + \"\\\"\");\n                         }\n+                    }\n \n-                        //write output\n-                        if (isBinaryContent) {\n-                            byte[] bBuf = new byte[2048];\n-                            OutputStream out = response.getOutputStream();\n-                            cgiOutput = proc.getInputStream();\n-                            while ((bufRead = cgiOutput.read(bBuf)) != -1) {\n-                                if (debug >= 4) {\n-                                    log(\"runCGI: output \" + bufRead +\n-                                        \" bytes of binary data\");\n-                                }\n-                                out.write(bBuf, 0, bufRead);\n+                    //write output\n+                    if (isBinaryContent) {\n+                        byte[] bBuf = new byte[2048];\n+                        OutputStream out = response.getOutputStream();\n+                        cgiOutput = proc.getInputStream();\n+                        while ((bufRead = cgiOutput.read(bBuf)) != -1) {\n+                            if (debug >= 4) {\n+                                log(\"runCGI: output \" + bufRead +\n+                                    \" bytes of binary data\");\n                             }\n-                        } else {\n-                            commandsStdOut = new BufferedReader\n-                                (new InputStreamReader(proc.getInputStream()));\n+                            out.write(bBuf, 0, bufRead);\n+                        }\n+                    } else {\n+                        commandsStdOut = new BufferedReader\n+                            (new InputStreamReader(proc.getInputStream()));\n \n-                            char[] cBuf = new char[1024];\n-                            try {\n-                                while ((bufRead = commandsStdOut.read(cBuf)) !=\n-1) {\n-                                    if (servletContainerStdout != null) {\n-                                        if (debug >= 4) {\n-                                            log(\"runCGI: write(\\\"\" +\n+                        char[] cBuf = new char[1024];\n+                        try {\n+                            while ((bufRead = commandsStdOut.read(cBuf)) != -1) {\n+                                if (servletContainerStdout != null) {\n+                                    if (debug >= 4) {\n+                                        log(\"runCGI: write(\\\"\" +\n                                                 new String(cBuf, 0, bufRead) +\n\"\\\")\");\n-                                        }\n-                                        servletContainerStdout.write(cBuf, 0,\nbufRead);\n                                     }\n-                                }\n-                            } finally {\n-                                // Attempt to consume any leftover byte if\nsomething bad happens,\n-                                // such as a socket disconnect on the servlet\nside; otherwise, the\n-                                // external process could hang\n-                                if (bufRead != -1) {\n-                                    while ((bufRead =\ncommandsStdOut.read(cBuf)) != -1) {}\n+                                    servletContainerStdout.write(cBuf, 0, bufRead);\n                                 }\n                             }\n-    \n-                            if (servletContainerStdout != null) {\n-                                servletContainerStdout.flush();\n+                        } finally {\n+                            // Attempt to consume any leftover byte if\nsomething bad happens,\n+                            // such as a socket disconnect on the servlet side;\notherwise, the\n+                            // external process could hang\n+                            if (bufRead != -1) {\n+                                while ((bufRead = commandsStdOut.read(cBuf)) !=\n-1) {}\n                             }\n                         }\n-\n-                        proc.exitValue(); // Throws exception if alive\n-\n-                        isRunning = false;\n-\n-                    } catch (IllegalThreadStateException e) {\n-                        try {\n-                            Thread.sleep(500);\n-                        } catch (InterruptedException ignored) {\n+    \n+                        if (servletContainerStdout != null) {\n+                            servletContainerStdout.flush();\n                         }\n                     }\n-               \n-                } //replacement for Process.waitFor()\n-                // Close the output stream used\n-                if (isBinaryContent) {\n-                    cgiOutput.close();\n-                } else {\n-                    commandsStdOut.close();\n-                }\n-            }\n-            catch (IOException e){\n-                log (\"Caught exception \" + e);\n-                System.out.println(\"Caught IOException - printing dump 1\");\n-                e.printStackTrace();\n-                if (proc != null){\n-                    proc.destroy();\n-                    proc = null;\n-                }\n-                throw new IOException (e.toString());\n-            }\n-            finally{\n-                log (\"Running finally block\");\n-                if (proc != null){\n-                    proc.destroy();\n-                    proc = null;\n-                }\n-            }\n-        }\n \n-        private void deadProcWatcher(Process myproc,long lWait){\n-            long processRunDeadline = System.currentTimeMillis() +lWait;\n+                    proc.exitValue(); // Throws exception if alive\n+\n+                    isRunning = false;\n \n-            while(System.currentTimeMillis() < processRunDeadline){\n-                log(\"deadProcWatcher: cgi run:  \" + \n-                    processRunDeadline + \" \" +\n-                    System.currentTimeMillis() +\n-                    \" \" + myproc);\n-                try{\n-                    myproc.exitValue(); // Throws exception if alive\n-                    log(\"deadProcWatcher: exiting normally\");\n-                    return; // child has exited, we can exit\n-                    \n                 } catch (IllegalThreadStateException e) {\n                     try {\n                         Thread.sleep(500);\n                     } catch (InterruptedException ignored) {\n                     }\n                 }\n+            } //replacement for Process.waitFor()\n+            // Close the output stream used\n+            if (isBinaryContent) {\n+                cgiOutput.close();\n+            } else {\n+                commandsStdOut.close();\n             }\n-            if (System.currentTimeMillis() > processRunDeadline){\n-                log(\"Killing process due to timeout\" + \n-                    processRunDeadline + \" \" +\n-                    System.currentTimeMillis() +\n-                    \" \" + myproc);\n-                myproc.destroy();\n-            }\n-            \n         }\n \n-        \n-        \n         private void sendToLog(BufferedReader rdr) {\n             String line = null;\n             int lineCount = 0 ;",
    "hasPatch": true,
    "hasScreenshot": false,
    "id": "34801",
    "issuetypeClassified": "RFE",
    "issuetypeTracker": "RFE",
    "priority": "P3 enhancement",
    "product": "Tomcat 5",
    "project": "TOMCAT",
    "summary": "PATCH: CGIServlet does not terminate child after a timeout",
    "systemSpecification": true,
    "version": "5.5.17"
}