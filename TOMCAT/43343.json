{
    "comments": [
        {
            "author": null,
            "body": "I thought about marking this as a P1 as it could cause some very hard to track\ndown data loss in a web application. What is the difference between P1 and P2\nfor the Tomcat project?",
            "date": "20070910T10:56:10",
            "id": 0
        },
        {
            "author": null,
            "body": "Using a plain Object to synchronize on rather than an Integer(0) would be very\nslightly more efficient.\n",
            "date": "20070910T11:09:30",
            "id": 1
        },
        {
            "author": null,
            "body": "Any reason not to use the Session object itself as the monitor?\n",
            "date": "20070910T13:51:32",
            "id": 2
        },
        {
            "author": null,
            "body": "No real reason I can find. We might want to use an instance variable as the lock\njust in case there are ever any other synchronized methods or sections added to\nthe session where the entire session is locked. That would help if those\nsynchronized session methods would need to be used by other threads and could be\naccessed even during passivation. I only find one place where the session itself\nis locked and that is in the expires method where a synchronized (this) is used.\n So, using the session itself would be OK for now, and it may logically work out\nto be the case that no other action should ever be able to actually be made or\never wanted on the session while it is being cached/passivated. I mentioned it\ncould be used as the lock in the my description some where. So, at least for\nnow, or always if deemed to always be wanted, I don't see any reason why it\nitself can not be the lock.",
            "date": "20070910T14:23:51",
            "id": 3
        },
        {
            "author": null,
            "body": "I have applied a patch to trunk based on the discussion here and proposed it for 6.0.x.",
            "date": "20080501T14:15:49",
            "id": 4
        },
        {
            "author": null,
            "body": "The patch has been applied to 6.0.x and will be in 6.0.17 onwards.\n\nThanks for the suggested patch.",
            "date": "20080515T10:28:56",
            "id": 5
        },
        {
            "author": null,
            "body": "Created attachment 23592\nReproducer, part 1: web application\n\nWeb application for TC 5.5, 6.0 to reproduce the issue",
            "date": "20090501T19:17:56",
            "id": 6
        },
        {
            "author": null,
            "body": "Created attachment 23593\n Reproducer, part 2: client\n\nHTTPClient.\ncommons-httpclient-3.1.jar and its dependencies are not included.\n\nTo run:\n1. Deploy bug43343.war on a web server\n2. Unpack this bug43343_client.zip and put the following libraries into lib subfolder:\ncommons-httpclient-3.1.jar\ncommons-codec-1.3.jar\ncommons-logging-1.1.1.jar\n3. Run client.bat if you are on Windows\n\nThe client creates several (100) instances of HttpClient that connect to \n http://localhost:8080/bug43343/index.jsp?number=nn&loop=ll\n\nEach HttpClient remembers its cookies, and thus connects to a separate session.\nThe number parameter in URL is unique for each HttpClient instance, and loop starts with 0 and increments by 1 for each request from the same client.\n\nThe context.xml file of the web application configures PersistentManager with some low values, to that this issue is more visible.\n\nThe requests are being sent serially, with an interval of at least 4 seconds between request of the same client.\n\nThe client prints out the response of web application, and terminates if status code 500 is received.\n\nExpected result:\nSuccessful run of the client. That is, 150 loops, which needs about 10 minutes to complete.",
            "date": "20090501T19:40:29",
            "id": 7
        },
        {
            "author": null,
            "body": "I am reopening this issue, because:\n1. The fix was not applied to TC 5.5, and the issue can be reproduced with TC 5.5.27.\n2. The fix [1], as applied to 6.0 is not complete, though one may argue.\n\nI am reducing severity to \"normal\".\nThe issue does not apply to the default configuration, where StandardManager is used.\n\n[1] http://svn.apache.org/viewvc?rev=656751&view=rev\n\nOn the issue:\nWhen PersistentManagerBase swaps out a session it performs two actions (see its implementation of swapOut()):\n1. writing session data out\n2. calling session.recycle() which invalidates the session\n\nWhen session that is being used by an active request is being swapped out at the same time (and what is the need for doing that? - you will not be able to free the memory, because there is a reference), two races can occur:\n\nCase A: request writes data to session at the same time as it is being written out and before the recycle() call.\nResult: the update is lost, next request will see the old values.\nThis is the case that is fixed by PersistentManagerBase patch in rev=656751 [1].\n\n\nCase B: request accesses session after session.recycle(), e.g. after swapOut() completes.\nResult: java.lang.IllegalStateException: setAttribute: Session already invalidated,\nthough the session was not invalidated, but just swapped out.\n\n\n---------------------------------------------\nSample output from the client when Case A is observed (with TC 5.5.27):\n\nMethod failed: HTTP/1.1 500 Internal Server Error\n\nError (number=-1509748992, loop=140):\njava.lang.IllegalStateException: Attribute loop is not equal to the expected val\nue.\nExpected: 139\nActual: 138\n\n---------------------------------------------\n\nCase B can be reproduced more easily if you replace\ns/ if (false) { / if (true) { /\non line 57 in file index.jsp of the web application.\n\nSample output from the client when Case B is observed (current tc6.0.x, with the mentioned change of line 57):\n\nMethod failed: HTTP/1.1 500 Internal Server Error\n\nError (number=-1309785265, loop=0):\njava.lang.IllegalStateException: setAttribute: Session already invalidated\n\n\nI have also seen the following NullPointerException when running against TC 5.5.27, and I think that it is the Case B:\n\nThe server encountered an internal error () that prevented it from fulfilling this request.\nexception:\n   org.apache.jasper.JasperException\n        org.apache.jasper.servlet.JspServletWrapper.handleJspException(JspServle\ntWrapper.java:460)\n        org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.ja\nva:373)\n        org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:329)\n        org.apache.jasper.servlet.JspServlet.service(JspServlet.java:265)\n        javax.servlet.http.HttpServlet.service(HttpServlet.java:729)\nroot cause:\n   java.lang.NullPointerException\n        org.apache.catalina.session.StandardSession.setAttribute(StandardSession\n.java:1309)\n        org.apache.catalina.session.StandardSession.setAttribute(StandardSession\n.java:1248)\n        org.apache.catalina.session.StandardSessionFacade.setAttribute(StandardS\nessionFacade.java:130)\n        org.apache.jsp.index_jsp._jspService(index_jsp.java:88)\n        org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:98)\n        javax.servlet.http.HttpServlet.service(HttpServlet.java:729)\n        org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.ja\nva:331)\n        org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:329)\n        org.apache.jasper.servlet.JspServlet.service(JspServlet.java:265)\n        javax.servlet.http.HttpServlet.service(HttpServlet.java:729)\n---------------------------------------------\n\nCase B can be solved by avoiding swapping out sessions that are owned by a request. Synchronizing on a session is not sufficient.\n\nA workaround is to avoid enabling IdleSwap in the configuration (it is disabled by default).",
            "date": "20090501T20:27:25",
            "id": 8
        },
        {
            "author": null,
            "body": "Case B fixed in trunk and proposed for 6.0.x\nComplete fix proposed for 5.5.x.",
            "date": "20090525T15:37:40",
            "id": 9
        },
        {
            "author": null,
            "body": "This has been fixed for 6.0.x and will be included in 6.0.21 onwards.\n\nTransferring to TC5 so it can be used to track the fix there.",
            "date": "20090623T11:32:52",
            "id": 10
        },
        {
            "author": null,
            "body": "This has been fixed in 5.5.x and will be included in 5.5.28 onwards.",
            "date": "20090701T06:19:40",
            "id": 11
        }
    ],
    "component": "Catalina",
    "description": "A user was asking questions on the tomcat users mailing list about TC and how it\nhandled concurrency in sessions and session passivation/object caching of\nsessions when they are inactive etc. I thought, surely this is using locks etc,\nso had responded as such. Then I got curious. I started looking in the code and\nfound that indeed TC has a concurrency issue when the session is to pushed to\ndisk if it is inactive or the max number of live sessions is too high.\n\nThe problem is a user could have a session getting ready to become inactive. The\nserver is beginning to write the session out to disk. The user then comes in on\na request and gets the current session. They set an attribute. The web\napplication and the user think all is OK. But in reality the data they just put\ninto the session will be lost. The server just dumped their session to disk\ncontaining the old data as they updated the copy. So, the next time they come in\nthe session will be pulled from disk with the old values and anything they put\ninto it will have been lost. Depending on the application this could be very bad.\n\nTo see the issue go to the file:\njava/org/apache/catalina/session/PersistentManagerBase.java\n\nmethods:\nswapIn\nswapOut\nwriteSession\nfindSession\n(other related)\nthen the different stores load and save methods. There is nothing keeping this\nfrom happening.\n\nIf a lock is on a per session level this should keep it snappy for all other\nrequests etc. Either the session could be used as the lock or an object instance\nvariable on the session instance.\n\nI noticed there is a comment in the source code for\nPersistentManagerBase.processMaxIdleSwaps which reads:\n// Swap out all sessions idle longer than maxIdleSwap\n// FIXME: What's preventing us from mangling a session during\n// a request?\n\nSo, apparently someone thought of this. Nothing is keeping it from mangling a\nsession currently.\n\nWhat might be a fix is a session is given an instance variable which can be used\nfor a synchronization lock at the session level. In\nPersistentManagerBase.findSession, this lock would be used before the session\ncan be returned. After the session map is accessed it should then return null if\nthe session had been passivating before it was asked to be found. The session\nwould then be loaded from storage again before it was ever given back to be\naccessed had it been passivating. It would also be used in\nPersistentManagerBase.* which call swapOut.\n\nThe code would look like this (might explain it better):\n\nStandardSession:\n\n/**\n Used for locking the session during persistence operations.\n**/\nInteger persistence_locker = new Integer(0);\n\nPersistentManagerBase:\n\n    /**\n     * Return the active Session, associated with this Manager, with the\n     * specified session id (if any); otherwise return <code>null</code>.\n     * This method checks the persistence store if persistence is enabled,\n     * otherwise just uses the functionality from ManagerBase.\n     *\n     * @param id The session id for the session to be returned\n     *\n     * @exception IllegalStateException if a new session cannot be\n     *  instantiated for any reason\n     * @exception IOException if an input/output error occurs while\n     *  processing this request\n     */\n    public Session findSession(String id) throws IOException {\n\n        Session session = super.findSession(id);\n        //OK, at this point, we're not sure if another thread is trying to\n        //remove the session or not so the only way around this is to lock\n        //it (or attempt to) and then try to get it by this session id again.\n        //If the other code ran swapOut, then we should get a null back during\n        //this run, and if not, then by doing this we lock it out and then can\n        //access the session safely and will call access on it to update the\n        //access time and hopefully keep the processes from running swapOut\n        //so, we're adding two accesses to the hashmap instead of one for\n        //each request. But, we know we get the session or null back after\n        //the other process has had a chance to remove it or not.\n        if(session!=null{\n\t        synchronized(session.persistence_locker){\n\t\t\t\tsession = super.findSession(session.getIdInternal());\n\t\t\t\tif(session!=null){\n\t\t\t\t   //we need to do this here\n\t\t\t\t   //to keep any external calling code from messing up the\n\t\t\t\t   //concurrency.\n\t\t\t\t   session.access();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        if (session != null)\n            return (session);\n\n        // See if the Session is in the Store\n        session = swapIn(id);\n        return (session);\n\n    }\n\n    /**\n     * Swap idle sessions out to Store if they are idle too long.\n     */\n    protected void processMaxIdleSwaps() {\n\n        if (!isStarted() || maxIdleSwap < 0)\n            return;\n\n        Session sessions[] = findSessions();\n        long timeNow = System.currentTimeMillis();\n\n        // Swap out all sessions idle longer than maxIdleSwap\n        // FIXME: What's preventing us from mangling a session during\n        // a request?\n        if (maxIdleSwap >= 0) {\n            for (int i = 0; i < sessions.length; i++) {\n                StandardSession session = (StandardSession) sessions[i];\n                synchronized(session.persistence_locker){\n            \t    if (!session.isValid())\n            \t        continue;\n            \t    int timeIdle = // Truncate, do not round up\n            \t        (int) ((timeNow - session.getLastAccessedTime()) / 1000L);\n            \t    if (timeIdle > maxIdleSwap && timeIdle > minIdleSwap) {\n            \t        if (log.isDebugEnabled())\n            \t            log.debug(sm.getString\n            \t                (\"persistentManager.swapMaxIdle\",\n            \t                 session.getIdInternal(), new Integer(timeIdle)));\n            \t        try {\n            \t            swapOut(session);\n            \t        } catch (IOException e) {\n            \t            ;   // This is logged in writeSession()\n            \t        }\n            \t    }\n\t\t\t\t}\n            }\n        }\n\n    }\n\n\n    /**\n     * Swap idle sessions out to Store if too many are active\n     */\n    protected void processMaxActiveSwaps() {\n\n        if (!isStarted() || getMaxActiveSessions() < 0)\n            return;\n\n        Session sessions[] = findSessions();\n\n        // FIXME: Smarter algorithm (LRU)\n        if (getMaxActiveSessions() >= sessions.length)\n            return;\n\n        if(log.isDebugEnabled())\n            log.debug(sm.getString\n                (\"persistentManager.tooManyActive\",\n                 new Integer(sessions.length)));\n\n        int toswap = sessions.length - getMaxActiveSessions();\n        long timeNow = System.currentTimeMillis();\n\n        for (int i = 0; i < sessions.length && toswap > 0; i++) {\n\t\tsynchronized(sessions[i].persistence_locker){\n                    int timeIdle = // Truncate, do not round up\n            \t    (int) ((timeNow - sessions[i].getLastAccessedTime()) / 1000L);\n\t            if (timeIdle > minIdleSwap) {\n\t                if(log.isDebugEnabled())\n\t                    log.debug(sm.getString\n\t                        (\"persistentManager.swapTooManyActive\",\n\t                         sessions[i].getIdInternal(), new Integer(timeIdle)));\n\t                try {\n\t                    swapOut(sessions[i]);\n\t                } catch (IOException e) {\n\t                    ;   // This is logged in writeSession()\n\t                }\n\t                toswap--;\n\t            }\n\t\t\t}\n        }\n\n    }\n\n\n    /**\n     * Back up idle sessions.\n     */\n    protected void processMaxIdleBackups() {\n\n        if (!isStarted() || maxIdleBackup < 0)\n            return;\n\n        Session sessions[] = findSessions();\n        long timeNow = System.currentTimeMillis();\n\n        // Back up all sessions idle longer than maxIdleBackup\n        if (maxIdleBackup >= 0) {\n            for (int i = 0; i < sessions.length; i++) {\n                StandardSession session = (StandardSession) sessions[i];\n                synchronized(session.persistence_locker){\n                    if (!session.isValid())\n                \t    continue;\n                \tint timeIdle = // Truncate, do not round up\n                    \t(int) ((timeNow - session.getLastAccessedTime()) / 1000L);\n                \tif (timeIdle > maxIdleBackup) {\n                    \tif (log.isDebugEnabled())\n                    \t    log.debug(sm.getString\n                    \t        (\"persistentManager.backupMaxIdle\",\n                    \t        session.getIdInternal(), new Integer(timeIdle)));\n\n                    \ttry {\n                        \twriteSession(session);\n                    \t} catch (IOException e) {\n                        \t;   // This is logged in writeSession()\n                    \t}\n                \t}\n            \t}\n        \t}\n\t    }\n\n    }\n\n\n\nSo, currently one could very easily have a session and have some issues. Your\nuser would have a time when they thought they set something or your code could\nthink this then immediately the changes are lost. Anyways, that is what looks to\nbe the issue and a workable fix. The only place I saw other issues was inside of:\njava/org/apache/catalina/valves/PersistentValve.java\n\nwhere it incorrectly grabs the store from the PersistentManager and uses it\ndirectly instead of using the manager API. To me this is bad in that the manager\nis not able to be the manager and this other logic is accessing the store\ndirectly and should never happen...unless it is used only in test cases etc.\n\nThe only way you could possibly *sort of* workaround this issue would be to use\na HttpSessionActivationListener, but even then it would be hard to code up a\n100% reliable solution. You can see how this would *sort of* be a way to work\naround the issue by looking at the class StandardSession method passivate , and\nsee the events will be thrown to alert code the session will passivate, but it\nwould be pretty complicated and ugly to protect the session completely.",
    "hasPatch": false,
    "hasScreenshot": false,
    "id": "43343",
    "issuetypeClassified": "BUG",
    "issuetypeTracker": "BUG",
    "priority": "P2 normal",
    "product": "Tomcat 5",
    "project": "TOMCAT",
    "summary": "Loss of data and concurrency issue with Catalina session persistent storage",
    "systemSpecification": true,
    "version": "5.5.27"
}