{
    "comments": [
        {
            "author": null,
            "body": "This is actually a Micorosft problem, and it is du to the implementation of the \nMS Client, which requests some information against the root \"/\", regardles of \nthe resource and the real root of WebDAV. To solve this problem, I am using a \nsimple Filter to filter the MS WebDAV requests:\n\n/**\n * The webdav interceptor blocks some FrontPage requests and determinate the \nencoding of the underlying request\n *\n */\npublic class WebdavInterceptor implements Filter {\n\n    public static final String MICROSOFT_PROTOCOL_AGENT = \n        \"Microsoft Data Access Internet Publishing Provider Protocol Discovery\";\n\n    /** Creates a new instance of LoginInterceptor */\n    public WebdavInterceptor()\n    {\n    }\n\n    public void init(javax.servlet.FilterConfig filterConfig) throws \njavax.servlet.ServletException\n    {\n    }\n\n    public void destroy()\n    {\n    }\n\n    /** Filter some invalid calls from the Microsoft WebDAV clients (Windows \n2000, Windows XP and Office 2003) */\n    public void doFilter(ServletRequest servletRequest, ServletResponse \nservletResponse, \n        FilterChain filterChain) throws IOException, ServletException\n    {\n        HttpServletRequest request = (HttpServletRequest)servletRequest;\n        String path = request.getServletPath();\n        if (path != null) {\n            if (path.endsWith(\"/index.jsp\")) {\n                // a very strange microsoft webdav handling... (because of the \nfront page extensions!)\n                // Microsoft (protocol discoverer) is asking the root of the \nserver\n                // whether it can handles a WebDAV, so we have to catch it \nhere. Unfortunately we can't\n                // redirect the root URL (\"/\") to a servlet, because we will \nintercept any other\n                // path handling...\n                String agent = request.getHeader(\"user-agent\");\n                if (MICROSOFT_PROTOCOL_AGENT.equals(agent)) {\n                    HttpServletResponse response = (HttpServletResponse)\nservletResponse;\n                    response.addHeader(\"DAV\", \"1,2\");\n\n                    response.addHeader(\"Allow\", \"OPTIONS, TRACE, PROPFIND\");\n                    response.addHeader(\"MS-AUTHOR-VIA\", \"DAV\");\n                    return;\n                }\n            }\n            // block, front page and m$ office extensions requests...\n            if (path.startsWith(\"/_vti\") || path.startsWith(\"/MSOffice\")) {\n                ((HttpServletResponse)servletResponse).setStatus\n(HttpServletResponse.SC_NOT_FOUND);\n                return;\n            }\n        }\n\n        request.setCharacterEncoding(WebdavServlet.getEnconding(request));\n        filterChain.doFilter(servletRequest, servletResponse);\n    }\n\n}\n\nPlease note, that the root \"/\" is mapped to \"/index.jsp\", this is the standard \nwelcome file whithin my container. Thus the filter is mapped to:\n  <filter-mapping>\n    <filter-name>webdavFilter</filter-name>\n    <url-pattern>*.jsp</url-pattern>\n  </filter-mapping>\n\nand also to the WebDAV Servlet:\n  <filter-mapping>\n    <filter-name>webdavFilter</filter-name>\n    <servlet-name>webdav</servlet-name>\n  </filter-mapping>\n\nThe WebDAV servket should map additionaly the following paths:\n  <servlet-mapping>\n    <servlet-name>webdav</servlet-name>\n    <url-pattern>/_vti_inf.html</url-pattern>\n  </servlet-mapping>\n  <servlet-mapping>\n    <servlet-name>webdav</servlet-name>\n    <url-pattern>/_vti_bin/*</url-pattern>\n  </servlet-mapping>\n  <servlet-mapping>\n    <servlet-name>webdav</servlet-name>\n    <url-pattern>/MSOffice/*</url-pattern>\n  </servlet-mapping>\n\n\nI hope, this helps you. My WebDAV root is for instance \"/webdav/*\", and it \nworks within a container togther with a web application.\n\nRegards\nPeter\n",
            "date": "20060908T13:42:28",
            "id": 0
        },
        {
            "author": null,
            "body": "Peter, thank you for posting the filter: I like it as a nice, clean solution to\nan unfortunate (but non-Tomcat) problem.   Andrew, thank you for posting your\nsuggestions: the second one is good and as you've noted, it's already been\nimplemented.  I hope Peter's filter works well for you.  I'm going to link to it\nfrom the actual WebdavServlet class JavaDoc as well.",
            "date": "20061226T06:22:49",
            "id": 1
        }
    ],
    "component": "Servlets:WebDAV",
    "description": "The context path at which the webdav servlet is run must be\n/*. That is, a web.xml entry like the following does\nnot work:\n\n<servlet-mapping>\n<servlet-name>webdavsf</servlet-name>\n<url-pattern>/dav/*</url-pattern>\n</servlet-mapping>\n\nThis is tested on 5.5.17\n\nThis is unfortunate if you want to have one WAR file\ncontaining some other servlets and a dav area with\ncontent autogenerated by the servlets.\n\nI have made patches to \"webdav servlet\" on SourceForge, which is derived from\nthe apache code and has the same problem. My patches seem to fix it, and I\nsuspect that very similar patches would fix the original version. I am not a dav\nexpert though, and I haven't tested it on the original version, nor any locking\netc. So the patches described bel\n\nThere seem to be two reasons for this requirement for /* instead of, say /dav/*\n\n(1) The internal path generated for a null entry is\nwrong. This can be fixed by removing the following\nlines from getRelativePath() [in DefaultServlet]:\n            if (result == null)\n                result = (String) request.getAttribute(\n                                            Globals.INCLUDE_SERVLET_PATH_ATTR);\n\nand\nif (result == null) {\n            result = request.getServletPath();\n        }\nI don't see how these lines could ever help in the WebDav context, though I am\nnot an expert in dav, and they may be important in some other use of DefaultServlet.\n\nThe second required modification that I posted for \"webdav servlet\" on\nsourceforge has already been fixed (or something equivalent) in 5.5.17., so you\nshould be able to ignore that.",
    "hasPatch": false,
    "hasScreenshot": false,
    "id": "40160",
    "issuetypeClassified": "RFE",
    "issuetypeTracker": "RFE",
    "priority": "P2 enhancement",
    "product": "Tomcat 5",
    "project": "TOMCAT",
    "summary": "Webdav Context path must be /*",
    "systemSpecification": true,
    "version": "Unknown"
}