{
    "comments": [
        {
            "author": null,
            "body": "I did some research this evening and found out that, sure enough, Java 5 allows\ninstance final fields to be overwritten but does NOT allow this for static final\nfields.  Therefore my suggestion of simply overwriting the static final\nreference will not work.\n\nI made some modifications to the cleanup code in WebappClassLoader.java, which\ncause it to only nullify fields of descended-into objects if they refer to\nobjects of classes which were loaded by 'this' class loader or one of its\nchildren (if it has any.)  I am attaching the modified source file.  Please take\na look at it and see if it still achieves the desired effect with respect to\nTomcat's cleanup process.  I am new to class loader debugging.",
            "date": "20060209T05:47:13",
            "id": 0
        },
        {
            "author": null,
            "body": "Created attachment 17624\nModified WebappClassLoader.java\n\nModified method nullInstance() and added method loadedByThisOrChild().",
            "date": "20060209T05:50:47",
            "id": 1
        },
        {
            "author": null,
            "body": "The logging setup you are using is broken.\n\nAs for your proposed \"fix\", I am ok with it, as the problem I was trying to\naddress was not caused by classes loaded by the shared classloaders.",
            "date": "20060216T15:19:11",
            "id": 2
        }
    ],
    "component": "Catalina",
    "description": "I have run into an issue with Tomcat's handling of static fields in webapp\nclasses on context shutdown.  On line 1585 of WebappClassLoader.java, Tomcat\nembarks upon a well-intentioned mission to clear static state out of webapp\nclasses as it unloads them.  This can lead to a problem in at least one case; I\nhave run into this problem while attempting to replace Tomcat's use of\ncommons-logging with a solution based upon SLF4J and Log4J.\n\nTomcat would appear to proceed in an innocuous way so long as the fields it\nencounters are static but NOT final.  In these cases, it simply nulls the static\nreference.  Completely harmless since the class that holds it is about to be\nreleased.  However, when a field is encountered which is static AND final, it\ndescends into the referenced object itself and nulls out all of its fields. \nThis is a huge problem when those objects are shared (implying, of course, that\nthey are of classes loaded via the 'shared' or 'common' classloaders.)  As it\niterates over the fields of the referenced objects, it calls \nAccessibleObject.setAccessible() on each Field before it sets the null value,\nmeaning that referenced objects cannot defend themselves even by marking their\ninternal state as final.\n\nThe reason for descending into referenced objects for static final fields would\nappear to be a hedge against the fact that setting the static final reference\nitself to null could fail (obviously: it's final.)  But if Tomcat can--and\nobviously does--overwrite final *instance* state by calling setAccessible() on\nthe *instance* Field, could it not instead call setAccessible() on the *static*\nField and nullify it instead?\n\nTomcat's current behavior can potentially (and DOES) strip state out of living\nobjects.  This is definitely a bad thing.  I will try to describe the scenario.\n\nSLF4J (specifically, its jcl104-over-slf4j.jar) implements all of the\ncommons-logging interface in a static way.  This avoids the various\ncommons-logging classloader issues while still supporting the API.  I have\ndeployed the SLF4J and Log4J jars into the common classloader so that both\nTomcat and my webapps can use it.  This puts SLF4J and its statics and caches\ninto shared space.\n\nSome of the classes in my webapp have static final\norg.apache.commons.logging.Log instances in them.  (This is unavoidable, as in\nmost cases they occur in external libraries, such as Spring Framework.)  SLF4J\nprovides implementations of the LogFactory and Log classes, named\nSLF4JLogFactory and SLF4JLog, respectively.  The problem is that SLF4JLogFactory\nholds a cache of all Log instances that it has created--and as I mentioned\nabove, this cache is held in shared memory.\n\nNow take a look at what happens when a webapp class holding one of these static\nfinal Log instances is unloaded and then reloaded: on first load, the Log\ninstance is created, SLF4J caches it, and it is also stored in the static final\nfield on the webapp class in question.  Now the application is unloaded.  Tomcat\ncomes across that static final field during its cleanup process and descends\ninto the Log (SF4JLog) instance and nulls out all of its fields--one of which is\na wrapped Log4J Logger instance.  Next the application is reloaded.  When\nSLF4J's LogFactory.getLog() method is invoked this second time, it obtains the\nexisting Log instance from the cache and returns it--however, this instance has\nhad its internal state destroyed by Tomcat during the preceding context unload.\n In the particular case of SLF4J, this causes a NullPointerException to be\nthrown the first time that Log instance is used to output a log message.\n\nI have mentioned SLF4J several times in this message, but this is only as an\nexample.  This is NOT an SLF4J issue.  Tomcat should not be trashing the\ninternal state of live objects without their knowledge.  SLF4J just happens to\nbe a victim because of the way it handles its internal caching.  Tomcat is the\nroot of the problem.\n\nI can think of at least two possible fixes for this.  The first would be to call\nsetAccessible(true) on the static final Field and then setting *it* to null\ninstead of descending into the object it references.  If doing so allows\ninstance fields to be modified, wouldn't it also work for static fields?  If so,\nthis problem would disappear.\n\nA second possibility, which may or may not work for Tomcat's purposes, would be\nto check the classloader for an object before trashing its internal state.  Only\ndo the \"nullifying\" if the object is of a class that was loaded by a context\nclassloader.  Unfortunately, this may fail to address the leaks that Tomcat is\ntrying to prevent in the first place.  I am not familiar with this area of Tomcat.\n\nI would be more than happy to supply additional information on request.  I will\nalso do some experimentation with the WebappClassLoader source to see if I can\nput together a patch.\n\nThanks for your time,\n--Matt Jensen",
    "hasPatch": false,
    "hasScreenshot": false,
    "id": "38579",
    "issuetypeClassified": "OTHER",
    "issuetypeTracker": "BUG",
    "priority": "P2 normal",
    "product": "Tomcat 5",
    "project": "TOMCAT",
    "summary": "Tomcat nulling internal state of objects referenced by static finals",
    "systemSpecification": false,
    "version": "Unknown"
}