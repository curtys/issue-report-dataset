{
    "comments": [
        {
            "author": null,
            "body": "Created attachment 14002\ndiff -u results for all modified files",
            "date": "20050114T22:36:39",
            "id": 0
        },
        {
            "author": null,
            "body": "(In reply to comment #0)\n> Patches (diff -u) Follow:\n\nSorry, I didn't realize I'd be given the chance to add an attachment later --\nI've never submitted before...",
            "date": "20050114T22:38:57",
            "id": 1
        },
        {
            "author": null,
            "body": "Re #3 above, there is also a dependency on org.apache.catalina.util classes\nDateTool, StringManager and RequestUtil.",
            "date": "20050115T01:41:51",
            "id": 2
        },
        {
            "author": null,
            "body": "Created attachment 14053\nFixed a null pointer bug if you failed to specify the contentTypes initParam\n\nThe contentTypes initParam in SSIFilter was supposed to default to text/html if\nyou failed to specify it, but it was generating a null pointer exception due to\na misplaced statement.",
            "date": "20050120T19:05:16",
            "id": 3
        },
        {
            "author": null,
            "body": "Mark, as the custodian of the SSI stuff, please let us know if you're\ninteresting in committing this at some point.  Thanks ;)",
            "date": "20050323T16:32:17",
            "id": 4
        },
        {
            "author": null,
            "body": "I'll look at this now, so it should be in place for 5.5.10. I won't back port\nthis to 4.1.x of 5.0.x\n\nDavid, you might want to consider providing some documentation patches otherwise\npeople won't be aware of these enhancements.",
            "date": "20050326T22:25:36",
            "id": 5
        },
        {
            "author": null,
            "body": "I have reviewed the patch and have found one area I would like to see a change.\nThe character encoding used to decode the query string has changed from platform\ndefault to UTF-8. Such a change is likely to break things for existing users.\n\nFYI the Tomcat Coyote connector has a number of configuration options for URI\ndecoding including:\n- use platform default\n- use body encoding\n- use specified encoding\n\nThis could be fixed either by adding a configuration option or by reading the\nsettings from the connector. The downside to using the connector settings is it\nobviously isn't portable.\n\nI'll leave this a week or so and if an alternative approach to the query string\ndecoding isn't submitted I'll commit this patch less that one change.",
            "date": "20050327T14:10:39",
            "id": 6
        },
        {
            "author": null,
            "body": "(In reply to comment #7)\nThanks for the feedback and for being so kind to a new submitter.  :-)  I'll\nwork on the areas you suggest.  Look for updated patches, etc., by next Monday.\n\nThanks!",
            "date": "20050328T19:15:26",
            "id": 7
        },
        {
            "author": null,
            "body": "Sorry guys, but I need more time.  I had a busy week at work and a computer failure this weekend.  I do \nplan on submitting a new set of patches with the issues you raised addressed, doc patches and some \nother minor enhancements.  Can you give me another week?  Thanks!",
            "date": "20050404T04:27:57",
            "id": 8
        },
        {
            "author": null,
            "body": "Not a problem. Take as long as you need. ",
            "date": "20050404T19:15:05",
            "id": 9
        },
        {
            "author": null,
            "body": "Created attachment 14675\nFinal set of diffs\n\nHere it is at long last.  A new set of diffs based on 5.5.9 with the fixes you\nproposed.  I've also included web.xml, build.xml and documentation patches. \nPlease review the section on the query string decoding you had concerns about\nand see if you think I handled it properly.\n\nI've also taken the liberty of making the SSIFilter the default behavior and\ndeprecating the SSIServlet.  I hope this is OK with everyone.",
            "date": "20050411T04:08:09",
            "id": 10
        },
        {
            "author": null,
            "body": "Created attachment 14676\nFull set of modified files\n\nHere are the same set of files, but the full files in case you don't feel like\nmanually applying the patches.",
            "date": "20050411T04:09:24",
            "id": 11
        },
        {
            "author": null,
            "body": "BTW, I also made a few other minor fixes based on my experiences working with\nthese changes in a production environment.  The date parsing of the\nlast-modified header is a bit more robust and the contentType init parameter was\nchanged to a regex pattern for more flexibility.",
            "date": "20050411T04:12:20",
            "id": 12
        },
        {
            "author": null,
            "body": "David,\n\nI can't read you patches in bzip2 format (winzip doesn't recognise it).\n\nCan you re-add the patches in an alternative format (tar.gz would be ok)?",
            "date": "20050412T22:04:46",
            "id": 13
        },
        {
            "author": null,
            "body": "Created attachment 14693\nFinal set of diffs (in gzip)",
            "date": "20050412T22:11:13",
            "id": 14
        },
        {
            "author": null,
            "body": "Created attachment 14694\nFull set of modified files (in gzip)",
            "date": "20050412T22:11:54",
            "id": 15
        },
        {
            "author": null,
            "body": "I have almost completed reviewing and applying your changes. So far, I have only\nmade some minor changes (typos, line lengths etc) and have also re-worked the\nquery string encoding algorithm a bit.\n\nThere is one part of your patch I haven't yet worked out. In\nResponseIncludeWrapper you have intercepted the last-modified and content-type\nheaders. I understand why last-modified but not content-type. Can you explain\nplease?",
            "date": "20050414T19:56:53",
            "id": 16
        },
        {
            "author": null,
            "body": "The SSIFilter uses that same wrapper to capture the normal output.  The filter\napplies SSI processing by content type not file extension.",
            "date": "20050414T20:08:04",
            "id": 17
        },
        {
            "author": null,
            "body": "But why override getContentType()? I don't see what your code gives you that the\nstandard wrapper method doesn't.",
            "date": "20050414T22:23:39",
            "id": 18
        },
        {
            "author": null,
            "body": "(In reply to comment #19)\n> But why override getContentType()? I don't see what your code gives you that the\n> standard wrapper method doesn't.\n\nAhh.  Not all resources (servlets, etc.) explicitly set a mime type, and this\nmethod sometimes returns null, leaving it up to the container to set the content\ntype on the way out.  If this is the case, my method will attempt to look it up\nfrom the container before hand, because I need it *now*...  Not 100% sure on\nTomcat, but I know iPlanet does that.",
            "date": "20050414T22:31:34",
            "id": 19
        },
        {
            "author": null,
            "body": "Almost there, but one slight glitch. After the SSI processing, the\ncontent-length header and the actual content length are different. This causes\nproblems for both FireFox and IE. The easiest way to see it is to do an SSI\ninclude of a file containing a single character.\n\nWhen I do commit your patch, I intend to include the following changes unless\nyou know of a reason not to:\nSSIServlet\n  - Not deprecated. I'd like to give people the option.\nSSIFilter\n  - Format changes for 80 character width.\nResponseIncludeWrapper\n  - Default for lastModified changed to -1 from 0.\nGlobals\n  - Keep the old flag\n  - I need to check why the CGI servlet isn't using it any more\nbuild.xml\n  - Keep jar file name the same for consistency for current users\nweb.xml\n  - Keep servlet mappings\nSSIHowTo\n  - Keep servlet configuration\nSSIServletExternalResolver\n  - Align behaviour with standard Tomcat. Fix posisble NPEs. Code is now:\n\n        } else if (name.equalsIgnoreCase(\"QUERY_STRING_UNESCAPED\")) {\n            String queryString = req.getQueryString();\n            if (queryString != null) {\n                // Use default as a last resort\n            \tString queryStringEncoding =\n                    org.apache.coyote.Constants.DEFAULT_CHARACTER_ENCODING;\n                \n                String uriEncoding = null;\n                boolean useBodyEncodingForURI = false;\n                \n                // Get encoding settings from request / connector if possible\n                String requestEncoding = req.getCharacterEncoding();\n                if (req instanceof Request) {\n                    uriEncoding = ((Request)req).getConnector().getURIEncoding();\n                    useBodyEncodingForURI =\n                        ((Request)req).getConnector().getUseBodyEncodingForURI();\n                }\n                \n                // If valid, apply settings from request / connector\n                if (uriEncoding != null) {\n                \tqueryStringEncoding = uriEncoding;\n                } else if(useBodyEncodingForURI) {\n                    if (requestEncoding != null) {\n                    \tqueryStringEncoding = requestEncoding;\n                    }\n                }\n                \n                try {\n               \t    retVal = URLDecoder.decode(queryString,\nqueryStringEncoding);                       \n\t\t\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t\t\tretVal = queryString;\n\t\t\t\t}\n            }\n\n",
            "date": "20050421T23:33:04",
            "id": 20
        },
        {
            "author": null,
            "body": "Thank you for your follow up on this.  You're right about the content-length\nheader, I didn't notice that in our environment because our server sets the\ncontent-length on the way out to address some other issues.  This could be\nsimply resolved by explicitly resetting the content-length header to the site of\nthe byte wrapper array.  Feel free to make this (and the other changes you\nproposed) unless you'd prefer me to do it.  Thanks a ton for your help in\nworking with a newbie contributor...  :-)",
            "date": "20050421T23:50:43",
            "id": 21
        },
        {
            "author": null,
            "body": "Many thanks for the patch.",
            "date": "20050423T12:24:51",
            "id": 22
        },
        {
            "author": null,
            "body": "Looking in the web cvs view at\nhttp://cvs.apache.org/viewcvs.cgi/jakarta-tomcat-catalina/catalina/src/share/org/apache/catalina/ssi/\nI don't see the SSIFilter.  Am I missing something?  Or does that lag a little\nbit behind the actual CVS checkins?",
            "date": "20050505T06:05:36",
            "id": 23
        },
        {
            "author": null,
            "body": "My fault. I committed the other changes but forgot to add the new file. It is\ndone now.",
            "date": "20050505T19:31:15",
            "id": 24
        },
        {
            "author": null,
            "body": "Created attachment 16065\ncatch exceptions for non-file based urls\n\nWhile testing with the official code merges, I noticed that some exception\ncatching was removed from two file based methods.  If these exceptions are not\ncaught, non-file based includes won't work.  In my case, we do a <!--#include\nvirtual=\"/some/servlet\"--> but because that's not a file, it can't figure out\nthe last modified date because the servlet doesn't set one, and so it throws an\nexception.  This exception needs to be caught, or the include won't work.",
            "date": "20050816T19:38:02",
            "id": 25
        },
        {
            "author": null,
            "body": "Fixed in CVS for 5.5.x and will be included in next release.",
            "date": "20050817T23:15:41",
            "id": 26
        }
    ],
    "component": "Servlets:SSI",
    "description": "I've made some enhancements to the SSI processing package as follows:\n\n1) Created an SSIFilter to use instead of SSIServlet and modified support\nclasses accordingly.  SSIFilter takes a contentTypes initParam to filter out\nresults which shouldn't be processed and removes the buffered initParam since it\nisn't relevant.\n\n2) Modified support classes to allow SSIFilter and SSIServlet to update the\nLast-Modified header with dates from processing directives and include files. \n(This is better than using the Expires header, which is still supported.)\n\n3) Moved Globals.SSI_FLAG_ATTR into SSIProcessor to make it easier to use the\nssi package in other web-servers that don't support SSI processing.  Now there\nare only three external dependencies (IOTools, Strftime, URLEncoder) which I\nrecommend be included in servlets-ssi.jar so someone can just grab that jar and\nbe done with it.  You may want to consider removing the SSI_FLAG_ATTR from\nGlobals since it doesn't seem to be used anywhere else.\n\nPatches (diff -u) Follow:\n--- ./ResponseIncludeWrapper.java\tFri Oct 29 16:13:00 2004\n+++ ../ssi_new/ResponseIncludeWrapper.java\tFri Jan 14 10:34:00 2005\n@@ -13,6 +13,10 @@\n \n import java.io.IOException;\n import java.io.PrintWriter;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+\n import javax.servlet.ServletOutputStream;\n import javax.servlet.http.HttpServletResponse;\n import javax.servlet.http.HttpServletResponseWrapper;\n@@ -24,12 +28,17 @@\n  * @version $Revision: 1.5 $, $Date: 2004/09/01 18:33:33 $\n  */\n public class ResponseIncludeWrapper extends HttpServletResponseWrapper {\n+    private static final String CONTENT_TYPE = \"content-type\";\n+    private static final String LAST_MODIFIED = \"last-modified\";\n+    private DateFormat lmParser = new SimpleDateFormat(\"EEE, d MMM yyyy\nHH:mm:ss z\");\n     /**\n      * Our ServletOutputStream\n      */\n     protected ServletOutputStream originalServletOutputStream;\n     protected ServletOutputStream servletOutputStream;\n     protected PrintWriter printWriter;\n+    protected long lastModified = 0;\n+    private String contentType = null;\n \n \n     /**\n@@ -98,5 +107,85 @@\n             return servletOutputStream;\n         }\n         throw new IllegalStateException();\n+    }\n+\n+\n+    /**\n+     * Returns the value of the <code>last-modified</code> header field. The\nresult is\n+     * the number of milliseconds since January 1, 1970 GMT.\n+     * \n+     * @return the date the resource referenced by this\n<code>ResponseIncludeWrapper</code> was last modified, or 0 if not known.\n+     */\n+    public long getLastModified() {\n+        return lastModified;\n+    }\n+    \n+    \n+    /**\n+     * Returns the value of the <code>content-type</code> header field.\n+     * \n+     * @return the content type of the resource referenced by this\n<code>ResponseIncludeWrapper</code>, or <code>null</code> if not known.\n+     */\n+    public String getContentType()\n+    {\n+        return contentType;\n+    }\n+\n+    \n+    public void addDateHeader(String name, long value) {\n+        super.addDateHeader(name, value);\n+        String lname = name.toLowerCase();\n+        if (lname.equals(LAST_MODIFIED)) {\n+            lastModified = value;\n+        }\n+    }\n+\n+    \n+    public void addHeader(String name, String value) {\n+        super.addHeader(name, value);\n+        String lname = name.toLowerCase();\n+        if (lname.equals(LAST_MODIFIED)) {\n+            try {\n+                lastModified = lmParser.parse(value).getTime();\n+            } catch (ParseException e) {\n+                ;\n+            }\n+        }\n+        else if (lname.equals(CONTENT_TYPE))\n+        {\n+            contentType = value;\n+        }\n+    }\n+\n+    \n+    public void setDateHeader(String name, long value) {\n+        super.setDateHeader(name, value);\n+        String lname = name.toLowerCase();\n+        if (lname.equals(LAST_MODIFIED)) {\n+            lastModified = value;\n+        }\n+    }\n+ \n+    \n+    public void setHeader(String name, String value) {\n+        super.setHeader(name, value);\n+        String lname = name.toLowerCase();\n+        if (lname.equals(LAST_MODIFIED)) {\n+            try {\n+                lastModified = lmParser.parse(value).getTime();\n+            } catch (ParseException e) {\n+                ;\n+            }\n+        }\n+        else if (lname.equals(CONTENT_TYPE))\n+        {\n+            contentType = value;\n+        }\n+    }\n+\n+    public void setContentType(String value)\n+    {\n+        super.setContentType(value);\n+        contentType = value;\n     }\n }\n--- ./SSICommand.java\tFri Oct 29 16:13:00 2004\n+++ ../ssi_new/SSICommand.java\tFri Jan 14 11:37:00 2005\n@@ -34,10 +34,11 @@\n      *            The parameter values\n      * @param writer\n      *            the writer to output to\n+     * @return the most current modified date resulting from any SSI commands\n      * @throws SSIStopProcessingException\n      *             if SSI processing should be aborted\n      */\n-    public void process(SSIMediator ssiMediator, String commandName,\n+    public long process(SSIMediator ssiMediator, String commandName,\n             String[] paramNames, String[] paramValues, PrintWriter writer)\n             throws SSIStopProcessingException;\n }\n--- ./SSIConditional.java\tFri Oct 29 16:13:00 2004\n+++ ../ssi_new/SSIConditional.java\tFri Jan 14 11:47:00 2005\n@@ -23,9 +23,10 @@\n     /**\n      * @see SSICommand\n      */\n-    public void process(SSIMediator ssiMediator, String commandName,\n+    public long process(SSIMediator ssiMediator, String commandName,\n             String[] paramNames, String[] paramValues, PrintWriter writer)\n             throws SSIStopProcessingException {\n+        long lastModified = System.currentTimeMillis();\n         // Retrieve the current state information\n         SSIConditionalState state = ssiMediator.getConditionalState();\n         if (\"if\".equalsIgnoreCase(commandName)) {\n@@ -33,7 +34,7 @@\n             // except count it\n             if (state.processConditionalCommandsOnly) {\n                 state.nestingCount++;\n-                return;\n+                return lastModified;\n             }\n             state.nestingCount = 0;\n             // Evaluate the expression\n@@ -48,12 +49,12 @@\n         } else if (\"elif\".equalsIgnoreCase(commandName)) {\n             // No need to even execute if we are nested in\n             // a false branch\n-            if (state.nestingCount > 0) return;\n+            if (state.nestingCount > 0) return lastModified;\n             // If a branch was already taken in this if block\n             // then disable output and return\n             if (state.branchTaken) {\n                 state.processConditionalCommandsOnly = true;\n-                return;\n+                return lastModified;\n             }\n             // Evaluate the expression\n             if (evaluateArguments(paramNames, paramValues, ssiMediator)) {\n@@ -68,7 +69,7 @@\n         } else if (\"else\".equalsIgnoreCase(commandName)) {\n             // No need to even execute if we are nested in\n             // a false branch\n-            if (state.nestingCount > 0) return;\n+            if (state.nestingCount > 0) return lastModified;\n             // If we've already taken another branch then\n             // disable output otherwise enable it.\n             state.processConditionalCommandsOnly = state.branchTaken;\n@@ -80,7 +81,7 @@\n             // one level on the nesting count\n             if (state.nestingCount > 0) {\n                 state.nestingCount--;\n-                return;\n+                return lastModified;\n             }\n             // Turn output back on\n             state.processConditionalCommandsOnly = false;\n@@ -93,6 +94,7 @@\n             //throw new SsiCommandException( \"Not a conditional command:\" +\n             // cmdName );\n         }\n+        return lastModified;\n     }\n \n \n--- ./SSIConfig.java\tFri Oct 29 16:13:00 2004\n+++ ../ssi_new/SSIConfig.java\tFri Jan 14 11:48:00 2005\n@@ -24,8 +24,9 @@\n     /**\n      * @see SSICommand\n      */\n-    public void process(SSIMediator ssiMediator, String commandName,\n+    public long process(SSIMediator ssiMediator, String commandName,\n             String[] paramNames, String[] paramValues, PrintWriter writer) {\n+        long lastModified = 0;\n         for (int i = 0; i < paramNames.length; i++) {\n             String paramName = paramNames[i];\n             String paramValue = paramValues[i];\n@@ -33,10 +34,13 @@\n                     .substituteVariables(paramValue);\n             if (paramName.equalsIgnoreCase(\"errmsg\")) {\n                 ssiMediator.setConfigErrMsg(substitutedValue);\n+                lastModified = System.currentTimeMillis();\n             } else if (paramName.equalsIgnoreCase(\"sizefmt\")) {\n                 ssiMediator.setConfigSizeFmt(substitutedValue);\n+                lastModified = System.currentTimeMillis();\n             } else if (paramName.equalsIgnoreCase(\"timefmt\")) {\n                 ssiMediator.setConfigTimeFmt(substitutedValue);\n+                lastModified = System.currentTimeMillis();\n             } else {\n                 ssiMediator.log(\"#config--Invalid attribute: \" + paramName);\n                 //We need to fetch this value each time, since it may change\n@@ -46,5 +50,6 @@\n                 writer.write(configErrMsg);\n             }\n         }\n+        return lastModified;\n     }\n }\n--- ./SSIEcho.java\tFri Oct 29 16:13:00 2004\n+++ ../ssi_new/SSIEcho.java\tFri Jan 14 11:49:00 2005\n@@ -28,8 +28,9 @@\n     /**\n      * @see SSICommand\n      */\n-    public void process(SSIMediator ssiMediator, String commandName,\n+    public long process(SSIMediator ssiMediator, String commandName,\n             String[] paramNames, String[] paramValues, PrintWriter writer) {\n+        long lastModified = 0;\n         String encoding = DEFAULT_ENCODING;\n         String errorMessage = ssiMediator.getConfigErrMsg();\n         for (int i = 0; i < paramNames.length; i++) {\n@@ -42,6 +43,7 @@\n                     variableValue = MISSING_VARIABLE_VALUE;\n                 }\n                 writer.write(variableValue);\n+                lastModified = System.currentTimeMillis();\n             } else if (paramName.equalsIgnoreCase(\"encoding\")) {\n                 if (isValidEncoding(paramValue)) {\n                     encoding = paramValue;\n@@ -54,6 +56,7 @@\n                 writer.write(errorMessage);\n             }\n         }\n+        return lastModified;\n     }\n \n \n--- ./SSIExec.java\tFri Oct 29 16:13:00 2004\n+++ ../ssi_new/SSIExec.java\tFri Jan 14 11:51:00 2005\n@@ -15,6 +15,7 @@\n import java.io.IOException;\n import java.io.InputStreamReader;\n import java.io.PrintWriter;\n+\n import org.apache.catalina.util.IOTools;\n /**\n  * Implements the Server-side #exec command\n@@ -33,16 +34,17 @@\n     /**\n      * @see SSICommand\n      */\n-    public void process(SSIMediator ssiMediator, String commandName,\n+    public long process(SSIMediator ssiMediator, String commandName,\n             String[] paramNames, String[] paramValues, PrintWriter writer) {\n+        long lastModified = 0;\n         String configErrMsg = ssiMediator.getConfigErrMsg();\n         String paramName = paramNames[0];\n         String paramValue = paramValues[0];\n         String substitutedValue = ssiMediator.substituteVariables(paramValue);\n         if (paramName.equalsIgnoreCase(\"cgi\")) {\n-            ssiInclude.process(ssiMediator, \"include\",\n-                    new String[]{\"virtual\"}, new String[]{substitutedValue},\n-                    writer);\n+            lastModified = ssiInclude.process(ssiMediator, \"include\",\n+                               new String[]{\"virtual\"}, new\nString[]{substitutedValue},\n+                               writer);\n         } else if (paramName.equalsIgnoreCase(\"cmd\")) {\n             boolean foundProgram = false;\n             try {\n@@ -57,6 +59,7 @@\n                 IOTools.flow(stdErrReader, writer, buf);\n                 IOTools.flow(stdOutReader, writer, buf);\n                 proc.waitFor();\n+                lastModified = System.currentTimeMillis();\n             } catch (InterruptedException e) {\n                 ssiMediator.log(\"Couldn't exec file: \" + substitutedValue, e);\n                 writer.write(configErrMsg);\n@@ -68,5 +71,6 @@\n                 ssiMediator.log(\"Couldn't exec file: \" + substitutedValue, e);\n             }\n         }\n+        return lastModified;\n     }\n }\n--- ./SSIFlastmod.java\tFri Oct 29 16:13:00 2004\n+++ ../ssi_new/SSIFlastmod.java\tFri Jan 14 11:43:00 2005\n@@ -28,8 +28,9 @@\n     /**\n      * @see SSICommand\n      */\n-    public void process(SSIMediator ssiMediator, String commandName,\n+    public long process(SSIMediator ssiMediator, String commandName,\n             String[] paramNames, String[] paramValues, PrintWriter writer) {\n+        long lastModified = 0;\n         String configErrMsg = ssiMediator.getConfigErrMsg();\n         StringBuffer buf = new StringBuffer();\n         for (int i = 0; i < paramNames.length; i++) {\n@@ -41,7 +42,7 @@\n                 if (paramName.equalsIgnoreCase(\"file\")\n                         || paramName.equalsIgnoreCase(\"virtual\")) {\n                     boolean virtual = paramName.equalsIgnoreCase(\"virtual\");\n-                    long lastModified = ssiMediator.getFileLastModified(\n+                    lastModified = ssiMediator.getFileLastModified(\n                             substitutedValue, virtual);\n                     Date date = new Date(lastModified);\n                     String configTimeFmt = ssiMediator.getConfigTimeFmt();\n@@ -58,6 +59,7 @@\n                 writer.write(configErrMsg);\n             }\n         }\n+        return lastModified;\n     }\n \n \n--- ./SSIFsize.java\tFri Oct 29 16:13:00 2004\n+++ ../ssi_new/SSIFsize.java\tFri Jan 14 11:44:00 2005\n@@ -30,8 +30,9 @@\n     /**\n      * @see SSICommand\n      */\n-    public void process(SSIMediator ssiMediator, String commandName,\n+    public long process(SSIMediator ssiMediator, String commandName,\n             String[] paramNames, String[] paramValues, PrintWriter writer) {\n+        long lastModified = 0;\n         String configErrMsg = ssiMediator.getConfigErrMsg();\n         for (int i = 0; i < paramNames.length; i++) {\n             String paramName = paramNames[i];\n@@ -42,6 +43,8 @@\n                 if (paramName.equalsIgnoreCase(\"file\")\n                         || paramName.equalsIgnoreCase(\"virtual\")) {\n                     boolean virtual = paramName.equalsIgnoreCase(\"virtual\");\n+                    lastModified = ssiMediator.getFileLastModified(\n+                        substitutedValue, virtual);\n                     long size = ssiMediator.getFileSize(substitutedValue,\n                             virtual);\n                     String configSizeFmt = ssiMediator.getConfigSizeFmt();\n@@ -56,6 +59,7 @@\n                 writer.write(configErrMsg);\n             }\n         }\n+        return lastModified;\n     }\n \n \n--- ./SSIInclude.java\tFri Oct 29 16:13:00 2004\n+++ ../ssi_new/SSIInclude.java\tFri Jan 14 11:53:00 2005\n@@ -25,8 +25,9 @@\n     /**\n      * @see SSICommand\n      */\n-    public void process(SSIMediator ssiMediator, String commandName,\n+    public long process(SSIMediator ssiMediator, String commandName,\n             String[] paramNames, String[] paramValues, PrintWriter writer) {\n+        long lastModified = 0;\n         String configErrMsg = ssiMediator.getConfigErrMsg();\n         for (int i = 0; i < paramNames.length; i++) {\n             String paramName = paramNames[i];\n@@ -37,6 +38,8 @@\n                 if (paramName.equalsIgnoreCase(\"file\")\n                         || paramName.equalsIgnoreCase(\"virtual\")) {\n                     boolean virtual = paramName.equalsIgnoreCase(\"virtual\");\n+                    lastModified = ssiMediator.getFileLastModified(\n+                        substitutedValue, virtual);\n                     String text = ssiMediator.getFileText(substitutedValue,\n                             virtual);\n                     writer.write(text);\n@@ -51,5 +54,6 @@\n                 writer.write(configErrMsg);\n             }\n         }\n+        return lastModified;\n     }\n }\n--- ./SSIMediator.java\tFri Oct 29 16:13:00 2004\n+++ ../ssi_new/SSIMediator.java\tFri Jan 14 11:26:00 2005\n@@ -41,7 +41,7 @@\n     protected String configSizeFmt = DEFAULT_CONFIG_SIZE_FMT;\n     protected String className = getClass().getName();\n     protected SSIExternalResolver ssiExternalResolver;\n-    protected Date lastModifiedDate;\n+    protected long lastModifiedDate;\n     protected int debug;\n     protected Strftime strftime;\n     protected SSIConditionalState conditionalState = new SSIConditionalState();\n@@ -64,7 +64,7 @@\n \n \n     public SSIMediator(SSIExternalResolver ssiExternalResolver,\n-            Date lastModifiedDate, int debug) {\n+            long lastModifiedDate, int debug) {\n         this.ssiExternalResolver = ssiExternalResolver;\n         this.lastModifiedDate = lastModifiedDate;\n         this.debug = debug;\n@@ -315,7 +315,7 @@\n             setVariableValue(\"DATE_LOCAL\", null);\n             ssiExternalResolver.setVariableValue(className + \".DATE_LOCAL\",\n                     retVal);\n-            retVal = formatDate(lastModifiedDate, null);\n+            retVal = formatDate(new Date(lastModifiedDate), null);\n             setVariableValue(\"LAST_MODIFIED\", null);\n             ssiExternalResolver.setVariableValue(className + \".LAST_MODIFIED\",\n                     retVal);\n--- ./SSIPrintenv.java\tFri Oct 29 16:13:00 2004\n+++ ../ssi_new/SSIPrintenv.java\tFri Jan 14 11:46:00 2005\n@@ -24,8 +24,9 @@\n     /**\n      * @see SSICommand\n      */\n-    public void process(SSIMediator ssiMediator, String commandName,\n+    public long process(SSIMediator ssiMediator, String commandName,\n             String[] paramNames, String[] paramValues, PrintWriter writer) {\n+        long lastModified = 0;\n         //any arguments should produce an error\n         if (paramNames.length > 0) {\n             String errorMessage = ssiMediator.getConfigErrMsg();\n@@ -46,7 +47,9 @@\n                 writer.write('=');\n                 writer.write(variableValue);\n                 writer.write('\\n');\n+                lastModified = System.currentTimeMillis();\n             }\n         }\n+        return lastModified;\n     }\n }\n--- ./SSIProcessor.java\tFri Oct 29 16:13:00 2004\n+++ ../ssi_new/SSIProcessor.java\tFri Jan 14 11:37:00 2005\n@@ -15,9 +15,9 @@\n import java.io.PrintWriter;\n import java.io.Reader;\n import java.io.StringWriter;\n-import java.util.Date;\n import java.util.HashMap;\n import java.util.StringTokenizer;\n+\n import org.apache.catalina.util.IOTools;\n /**\n  * The entry point to SSI processing. This class does the actual parsing,\n@@ -36,7 +36,16 @@\n     protected SSIExternalResolver ssiExternalResolver;\n     protected HashMap commands = new HashMap();\n     protected int debug;\n-\n+    \n+    /**\n+     * The servlet context attribute under which we store a flag used\n+     * to mark this request as having been processed by the SSIServlet.\n+     * We do this because of the pathInfo mangling happening when using\n+     * the CGIServlet in conjunction with the SSI servlet. (value stored\n+     * as an object of type String)\n+     */\n+     public static final String SSI_FLAG_ATTR =\n+         \"org.apache.catalina.ssi.SSIServlet\";\n \n     public SSIProcessor(SSIExternalResolver ssiExternalResolver, int debug) {\n         this.ssiExternalResolver = ssiExternalResolver;\n@@ -76,11 +85,12 @@\n      *            the reader to read the file containing SSIs from\n      * @param writer\n      *            the writer to write the file with the SSIs processed.\n+     * @return the most current modified date resulting from any SSI commands\n      * @throws IOException\n      *             when things go horribly awry. Should be unlikely since the\n      *             SSICommand usually catches 'normal' IOExceptions.\n      */\n-    public void process(Reader reader, Date lastModifiedDate,\n+    public long process(Reader reader, long lastModifiedDate,\n             PrintWriter writer) throws IOException {\n         SSIMediator ssiMediator = new SSIMediator(ssiExternalResolver,\n                 lastModifiedDate, debug);\n@@ -142,8 +152,11 @@\n                             // command is not conditional\n                             if\n(!ssiMediator.getConditionalState().processConditionalCommandsOnly\n                                     || ssiCommand instanceof SSIConditional) {\n-                                ssiCommand.process(ssiMediator, strCmd,\n-                                        paramNames, paramValues, writer);\n+                                long lmd = ssiCommand.process(ssiMediator, strCmd,\n+                                               paramNames, paramValues, writer);\n+                                if (lmd > lastModifiedDate) {\n+                                    lastModifiedDate = lmd;\n+                                }                                    \n                             }\n                         }\n                         if (errorMessage != null) {\n@@ -160,6 +173,7 @@\n             //If we are here, then we have already stopped processing, so all\n             // is good\n         }\n+        return lastModifiedDate;\n     }\n \n \n--- ./SSIServlet.java\tFri Oct 29 16:13:00 2004\n+++ ../ssi_new/SSIServlet.java\tFri Jan 14 11:34:00 2005\n@@ -19,13 +19,12 @@\n import java.io.StringWriter;\n import java.net.URL;\n import java.net.URLConnection;\n-import java.util.Date;\n+\n import javax.servlet.ServletContext;\n import javax.servlet.ServletException;\n import javax.servlet.http.HttpServlet;\n import javax.servlet.http.HttpServletRequest;\n import javax.servlet.http.HttpServletResponse;\n-import org.apache.catalina.Globals;\n /**\n  * Servlet to process SSI requests within a webpage. Mapped to a path from\n  * within web.xml.\n@@ -166,7 +165,7 @@\n             res.setDateHeader(\"Expires\", (new java.util.Date()).getTime()\n                     + expires.longValue() * 1000);\n         }\n-        req.setAttribute(Globals.SSI_FLAG_ATTR, \"true\");\n+        req.setAttribute(SSIProcessor.SSI_FLAG_ATTR, \"true\");\n         processSSI(req, res, resource);\n     }\n \n@@ -174,7 +173,7 @@\n     protected void processSSI(HttpServletRequest req, HttpServletResponse res,\n             URL resource) throws IOException {\n         SSIExternalResolver ssiExternalResolver = new SSIServletExternalResolver(\n-                this, req, res, isVirtualWebappRelative, debug);\n+                getServletContext(), req, res, isVirtualWebappRelative, debug);\n         SSIProcessor ssiProcessor = new SSIProcessor(ssiExternalResolver,\n                 debug);\n         PrintWriter printWriter = null;\n@@ -189,8 +188,10 @@\n         InputStream resourceInputStream = resourceInfo.getInputStream();\n         BufferedReader bufferedReader = new BufferedReader(\n                 new InputStreamReader(resourceInputStream));\n-        Date lastModifiedDate = new Date(resourceInfo.getLastModified());\n-        ssiProcessor.process(bufferedReader, lastModifiedDate, printWriter);\n+        long lastModified = ssiProcessor.process(bufferedReader,\nresourceInfo.getLastModified(), printWriter);\n+        if (lastModified > 0) {\n+            res.setDateHeader(\"Last-Modified\", lastModified);\n+        }\n         if (buffered) {\n             printWriter.flush();\n             String text = stringWriter.toString();\n--- ./SSIServletExternalResolver.java\tFri Oct 29 16:13:00 2004\n+++ ../ssi_new/SSIServletExternalResolver.java\tFri Jan 14 09:31:00 2005\n@@ -12,16 +12,17 @@\n \n \n import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n import java.net.URL;\n import java.net.URLConnection;\n import java.net.URLDecoder;\n import java.util.Collection;\n import java.util.Date;\n import java.util.Enumeration;\n+\n import javax.servlet.RequestDispatcher;\n import javax.servlet.ServletContext;\n import javax.servlet.ServletException;\n-import javax.servlet.http.HttpServlet;\n import javax.servlet.http.HttpServletRequest;\n import javax.servlet.http.HttpServletResponse;\n /**\n@@ -37,17 +38,17 @@\n             \"QUERY_STRING\", \"QUERY_STRING_UNESCAPED\", \"REMOTE_ADDR\",\n             \"REMOTE_HOST\", \"REMOTE_USER\", \"REQUEST_METHOD\", \"SCRIPT_NAME\",\n             \"SERVER_NAME\", \"SERVER_PORT\", \"SERVER_PROTOCOL\", \"SERVER_SOFTWARE\"};\n-    protected HttpServlet servlet;\n+    protected ServletContext context;\n     protected HttpServletRequest req;\n     protected HttpServletResponse res;\n     protected boolean isVirtualWebappRelative;\n     protected int debug;\n \n \n-    public SSIServletExternalResolver(HttpServlet servlet,\n+    public SSIServletExternalResolver(ServletContext context,\n             HttpServletRequest req, HttpServletResponse res,\n             boolean isVirtualWebappRelative, int debug) {\n-        this.servlet = servlet;\n+        this.context = context;\n         this.req = req;\n         this.res = res;\n         this.isVirtualWebappRelative = isVirtualWebappRelative;\n@@ -60,9 +61,9 @@\n         //is the same as Servlet.log( message ), since API\n         //doesn't seem to say so.\n         if (throwable != null) {\n-            servlet.log(message, throwable);\n+            context.log(message, throwable);\n         } else {\n-            servlet.log(message);\n+            context.log(message);\n         }\n     }\n \n@@ -160,7 +161,14 @@\n         } else if (name.equalsIgnoreCase(\"QUERY_STRING_UNESCAPED\")) {\n             String queryString = req.getQueryString();\n             if (queryString != null) {\n-                retVal = URLDecoder.decode(queryString);\n+                try\n+                {\n+                    retVal = URLDecoder.decode(queryString, \"UTF-8\");\n+                }\n+                catch (UnsupportedEncodingException e)\n+                {\n+                    retVal = queryString;\n+                }\n             }\n         } else if (name.equalsIgnoreCase(\"REMOTE_ADDR\")) {\n             retVal = req.getRemoteAddr();\n@@ -179,8 +187,7 @@\n         } else if (name.equalsIgnoreCase(\"SERVER_PROTOCOL\")) {\n             retVal = req.getProtocol();\n         } else if (name.equalsIgnoreCase(\"SERVER_SOFTWARE\")) {\n-            ServletContext servletContext = servlet.getServletContext();\n-            retVal = servletContext.getServerInfo();\n+            retVal = context.getServerInfo();\n         }\n         return retVal;\n     }\n@@ -250,26 +257,23 @@\n                     + nonVirtualPath);\n         }\n         String path = getAbsolutePath(nonVirtualPath);\n-        ServletContext servletContext = servlet.getServletContext();\n         ServletContextAndPath csAndP = new ServletContextAndPath(\n-                servletContext, path);\n+                context, path);\n         return csAndP;\n     }\n \n \n     protected ServletContextAndPath getServletContextAndPathFromVirtualPath(\n             String virtualPath) throws IOException {\n-        ServletContext servletContext = servlet.getServletContext();\n-        String path = null;\n         if (!virtualPath.startsWith(\"/\") && !virtualPath.startsWith(\"\\\\\")) {\n-            path = getAbsolutePath(virtualPath);\n+            return new ServletContextAndPath(context,\ngetAbsolutePath(virtualPath));\n         } else {\n             String normalized = SSIServletRequestUtil.normalize(virtualPath);\n             if (isVirtualWebappRelative) {\n-                path = normalized;\n+                return new ServletContextAndPath(context, normalized);\n             } else {\n-                servletContext = servletContext.getContext(normalized);\n-                if (servletContext == null) {\n+                ServletContext normContext = context.getContext(normalized);\n+                if (normContext == null) {\n                     throw new IOException(\"Couldn't get context for path: \"\n                             + normalized);\n                 }\n@@ -277,19 +281,19 @@\n                 // to remove,\n                 // ie:\n                 // '/file1.shtml' vs '/appName1/file1.shtml'\n-                if (!isRootContext(servletContext)) {\n-                    path = getPathWithoutContext(normalized);\n-                    if (path == null) {\n+                if (!isRootContext(normContext)) {\n+                    String noContext = getPathWithoutContext(normalized);\n+                    if (noContext == null) {\n                         throw new IOException(\n                                 \"Couldn't remove context from path: \"\n                                         + normalized);\n                     }\n+                    return new ServletContextAndPath(normContext, noContext);\n                 } else {\n-                    path = normalized;\n+                    return new ServletContextAndPath(normContext, normalized);\n                 }\n             }\n         }\n-        return new ServletContextAndPath(servletContext, path);\n     }\n \n \n--- ./SSISet.java\tFri Oct 29 16:13:00 2004\n+++ ../ssi_new/SSISet.java\tFri Jan 14 11:52:00 2005\n@@ -23,9 +23,10 @@\n     /**\n      * @see SSICommand\n      */\n-    public void process(SSIMediator ssiMediator, String commandName,\n+    public long process(SSIMediator ssiMediator, String commandName,\n             String[] paramNames, String[] paramValues, PrintWriter writer)\n             throws SSIStopProcessingException {\n+        long lastModified = 0;\n         String errorMessage = ssiMediator.getConfigErrMsg();\n         String variableName = null;\n         for (int i = 0; i < paramNames.length; i++) {\n@@ -39,6 +40,7 @@\n                             .substituteVariables(paramValue);\n                     ssiMediator.setVariableValue(variableName,\n                             substitutedValue);\n+                    lastModified = System.currentTimeMillis();\n                 } else {\n                     ssiMediator.log(\"#set--no variable specified\");\n                     writer.write(errorMessage);\n@@ -50,5 +52,6 @@\n                 throw new SSIStopProcessingException();\n             }\n         }\n+        return lastModified;\n     }\n }\n--- SSIFilter.java\tFri Jan 14 13:25:44 2005\n+++ ../ssi_new/SSIFilter.java\tFri Jan 14 13:30:06 2005\n@@ -0,0 +1,189 @@\n+/*\n+ * Copyright 1999,2004 The Apache Software Foundation. Licensed under the\n+ * Apache License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable\n+ * law or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the specific language\n+ * governing permissions and limitations under the License.\n+ */\n+package org.apache.catalina.ssi;\n+\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterChain;\n+import javax.servlet.FilterConfig;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+/**\n+ * Filter to process SSI requests within a webpage. Mapped to a content types from\n+ * within web.xml.\n+ *\n+ * Based on code from <code>org.apache.catalina.ssi.SSIServlet</code>.\n+ * \n+ * @author David Becker\n+ * @version $Revision: 1.0 $, $Date: 2005/01/14 13:28:00 $\n+ * @see org.apache.catalina.ssi.SSIServlet\n+ */\n+public class SSIFilter implements Filter {\n+    /** Configuration for this filter. */\n+    protected FilterConfig config = null;\n+    /** Debug level for this filter. */\n+    protected int debug = 0;\n+    /** Expiration time in seconds for the doc. */\n+    protected Long expires = null;\n+    /** virtual path can be webapp-relative */\n+    protected boolean isVirtualWebappRelative = false;\n+    /** content types allowed for SSI processing */\n+    protected List contentTypes = new ArrayList();\n+    /** should all content types be allowed */\n+    protected boolean allowAllContentTypes = false;\n+\n+\n+    //----------------- Public methods.\n+    /**\n+     * Initialize this filter.\n+     * \n+     * @exception ServletException\n+     *                if an error occurs\n+     */\n+    public void init(FilterConfig config) throws ServletException {\n+        this.config = config;\n+        String value = null;\n+        try {\n+            value = config.getInitParameter(\"debug\");\n+            debug = Integer.parseInt(value);\n+        } catch (Throwable t) {\n+            ;\n+        }\n+        try {\n+            value = config.getInitParameter(\n+                    \"isVirtualWebappRelative\");\n+            isVirtualWebappRelative = Integer.parseInt(value) > 0?true:false;\n+        } catch (Throwable t) {\n+            ;\n+        }\n+        try {\n+            value = config.getInitParameter(\"expires\");\n+            expires = Long.valueOf(value);\n+        } catch (NumberFormatException e) {\n+            expires = null;\n+            config.getServletContext().log(\"Invalid format for expires\ninitParam; expected integer (seconds)\");\n+        } catch (Throwable t) {\n+            ;\n+        }\n+        try {\n+            String types = config.getInitParameter(\"contentTypes\");\n+            allowAllContentTypes = (types.equals(\"*\") || types.equals(\"*/*\"));\n+            if ((types != null) && !types.equals(\"\"))\n+            {\n+                contentTypes = Arrays.asList(types.split(\",\"));\n+            }\n+            else\n+            {\n+                contentTypes.add(\"text/html\");\n+                config.getServletContext().log(\"No contentTypes initParam\nprovided; defaulting to text/html\");\n+            }\n+        } catch (Throwable t) {\n+            ;\n+        }\n+        if (debug > 0)\n+            config.getServletContext().log(\"SSIFilter.init() SSI invoker\nstarted with 'debug'=\" + debug);\n+    }\n+\n+\n+    public void doFilter(ServletRequest request, ServletResponse response,\nFilterChain chain) throws IOException, ServletException {\n+        // cast once\n+        HttpServletRequest req = (HttpServletRequest)request;\n+        HttpServletResponse res = (HttpServletResponse)response;\n+        \n+        // indicate that we're in SSI processing\n+        req.setAttribute(SSIProcessor.SSI_FLAG_ATTR, \"true\");           \n+\n+        // setup to capture output\n+        ByteArrayServletOutputStream basos = new ByteArrayServletOutputStream();\n+        ResponseIncludeWrapper responseIncludeWrapper = new\nResponseIncludeWrapper(res, basos);\n+\n+        // process remainder of filter chain\n+        chain.doFilter(req, responseIncludeWrapper);\n+\n+        // we can't assume the chain flushed its output\n+        responseIncludeWrapper.flushOutputStreamOrWriter();\n+        byte[] bytes = basos.toByteArray();\n+\n+        // get content type\n+        String contentType = responseIncludeWrapper.getContentType();\n+        if ((contentType == null) || contentType.equals(\"\")) {\n+            contentType =\nconfig.getServletContext().getMimeType(req.getRequestURI());\n+            if ((contentType == null) || contentType.equals(\"\")) {\n+                contentType = \"text/html\";\n+            }\n+        }\n+        if (contentType.indexOf(\";\") > -1)\n+        {\n+            contentType = contentType.substring(0, contentType.indexOf(\";\"));\n+        }\n+\n+        // is this an allowed type for SSI processing?\n+        if (allowAllContentTypes || contentTypes.contains(contentType)) {\n+\n+            // set up SSI processing \n+            SSIExternalResolver ssiExternalResolver = new\nSSIServletExternalResolver(\n+                    config.getServletContext(), req, res,\nisVirtualWebappRelative, debug);\n+            SSIProcessor ssiProcessor = new SSIProcessor(ssiExternalResolver,\n+                    debug);\n+            \n+            // prepare readers/writers\n+            Reader reader = new InputStreamReader(new ByteArrayInputStream(bytes));\n+            ByteArrayOutputStream ssiout = new ByteArrayOutputStream();\n+            PrintWriter writer = new PrintWriter(new OutputStreamWriter(ssiout));\n+            \n+            // do SSI processing  \n+            long lastModified = ssiProcessor.process(reader,\nresponseIncludeWrapper.getLastModified(), writer);\n+            \n+            // set output bytes\n+            writer.flush();\n+            bytes = ssiout.toByteArray();\n+            \n+            // override headers\n+            if (expires != null) {\n+                res.setDateHeader(\"Expires\", (new java.util.Date()).getTime()\n+                        + expires.longValue() * 1000);\n+            }\n+            if (lastModified > 0) {\n+                res.setDateHeader(\"Last-Modified\", lastModified);\n+            }\n+        }\n+\n+        // write output\n+        try {\n+            OutputStream out = res.getOutputStream();\n+            out.write(bytes);\n+        } catch (Throwable t) {\n+            Writer out = res.getWriter();\n+            out.write(new String(bytes));\n+        }\n+    }\n+\n+\n+    public void destroy()\n+    {\n+    }\n+}",
    "hasPatch": true,
    "hasScreenshot": false,
    "id": "33106",
    "issuetypeClassified": "IMPROVEMENT",
    "issuetypeTracker": "RFE",
    "priority": "P2 enhancement",
    "product": "Tomcat 5",
    "project": "TOMCAT",
    "summary": "SSI Processing Enhancements (patch provided)",
    "systemSpecification": true,
    "version": "5.5.4"
}