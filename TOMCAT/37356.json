{
    "comments": [
        {
            "author": null,
            "body": "Is something holding a reference to those sessions?\n\nAnd does this happen with 5.0.30 or 5.5.12?",
            "date": "20051128T21:52:01",
            "id": 0
        },
        {
            "author": null,
            "body": "(In reply to comment #1)\n> Is something holding a reference to those sessions?\n> And does this happen with 5.0.30 or 5.5.12?\n\nThanks for the interest.\n\nThis happens with 5.0.28 in production - I cannot reproduce it anywhere else \n(using 5.0.28) and I currently cannot migrate the production system to 5.0.30 \neither. So, in short I cannot say if it happens on anything other than 5.0.28 -\n if someone could say that this behaviour was different in 5.0.30 then I would \nbe able to move forwards but without something more definitive I can't.\n\nI am not sure what you are getting at with the reference holding - if you mean \nis something keeping the session alive i.e. polling or such like then the \nanswer is no. If you mean is a Java object keeping a reference to it - then \naside from what Tomcat does internally (where I expect it must do...) then the \nanswer is also no.\n\nHope this helps. Eddie\n",
            "date": "20051214T13:30:56",
            "id": 1
        },
        {
            "author": null,
            "body": "We have a similar probelm - but only when tomcat (5.0.28 as well) is connected\nthrough ajp13.\n\nAs a difference to the original poster we do keep a reference to the Session\nObjects from within the servlet. This list is updated when we see a new session\nor when the valueUnbound() of an object (which is placed in every session) is\ncalled.\n\nThis problem occurs on Windows (with IIS as frontend) as well as on Linux with\nApache-httpd, but not if Tomcat is beeing run stand-alone (Windows or Linux).\n\n",
            "date": "20060112T16:58:10",
            "id": 2
        },
        {
            "author": null,
            "body": "I have found one problem about the accessCount. \n\nIn some times, it will not decrease to 0 after one request. So the session \nmanger will never invalidate it.\n\nThe Tomcat version is 5.0.19.",
            "date": "20060124T12:59:34",
            "id": 3
        },
        {
            "author": null,
            "body": "(In reply to comment #4)\n> I have found one problem about the accessCount. \n> In some times, it will not decrease to 0 after one request. So the session \n> manger will never invalidate it.\n> The Tomcat version is 5.0.19.\n\nThis sounds like you might be onto something - how did you find that? Can you \nreproduce this at will? ",
            "date": "20060126T17:16:01",
            "id": 4
        },
        {
            "author": null,
            "body": "It's very difficult to recure this problem. I have write a very complex web \napplication. and mostly it will work fine. but some time, it will occur this \nproblem.\n\nThis problem mostly ocurred when two browser access the same page.\n\nAnd the web application will do following things:\n1. APP A will include some pages in other applications.\n2. There is a request wrapper. when include the page in other applications and \ntry to get the session object using request.getSession(), it will get the \nsession which is generated in App A.\n3. The session objects generated in A, will be managed by our system. (of \ncuase , there is one listener to remove the session when it timeout)\nSorry, I can only provide these info for you.",
            "date": "20060207T06:10:38",
            "id": 5
        },
        {
            "author": null,
            "body": "(In reply to comment #6)\n> \n> This problem mostly ocurred when two browser access the same page.\n>\nDo you mean that wo browsers use the same session to access a page, or just the\n( quite usual ) case that two people use the web application?\n \n> And the web application will do following things:\n> 1. APP A will include some pages in other applications.\n> 2. There is a request wrapper. when include the page in other applications and \n> try to get the session object using request.getSession(), it will get the \n> session which is generated in App A.\nThat means in the included application B and C you get the session from\napplication A?\n\nApplication != context for you?\n\n> 3. The session objects generated in A, will be managed by our system. (of \n> cuase , there is one listener to remove the session when it timeout)\n> Sorry, I can only provide these info for you.\n\nSo it seems that the common ground for all of us here is, that we have some\nobjects in the session that implement the HttpSessionBindingListener or\nHttpSessionActivationListener.\n\nMaybe the cause lies within these? ",
            "date": "20060207T09:26:02",
            "id": 6
        },
        {
            "author": null,
            "body": "Do you mean that wo browsers use the same session to access a page, or just the\n( quite usual ) case that two people use the web application?\n\nA: not the same session. Different IE browser will generate differnt session \nID.\n\nThat means in the included application B and C you get the session from\napplication A?\n\nApplication != context for you?\n\nA: yes. \n\n\nSo it seems that the common ground for all of us here is, that we have some\nobjects in the session that implement the HttpSessionBindingListener or\nHttpSessionActivationListener.\n\nA: I did not put any object implement the HttpSessionBindingLisener or \nHttpSessionActivationListener in the session.\n\n\nI think with different thread ( when include the page in other application), \nwhen it will operate the session object, it will not synchronize the session \nobject (or its filed accessCount).",
            "date": "20060207T15:40:53",
            "id": 7
        },
        {
            "author": null,
            "body": "Please check this defect: 28846\n\nI think it should be the same problem. :-)",
            "date": "20060207T15:52:04",
            "id": 8
        },
        {
            "author": null,
            "body": "(In reply to comment #8)\n> Do you mean that wo browsers use the same session to access a page, or just the\n> ( quite usual ) case that two people use the web application?\n> \n> A: not the same session. Different IE browser will generate differnt session \n> ID.\n> \n> That means in the included application B and C you get the session from\n> application A?\n> \n> Application != context for you?\n> \n> A: yes.\n\nOk, so you can replicate the error if:\n1. you have two or more simultaneous users accessing a page in your web application.\n2. you have more than one application (servlet / jsp) within the same context,\nso the session stays the same through all requests.\n3. one of your servlets includes the output from other servlets/jsps\n\nDid I get that right?\n \n> \n> \n> So it seems that the common ground for all of us here is, that we have some\n> objects in the session that implement the HttpSessionBindingListener or\n> HttpSessionActivationListener.\n> \n> A: I did not put any object implement the HttpSessionBindingLisener or \n> HttpSessionActivationListener in the session.\n> \nAh - I had thought so, because you mentioned you remove the objects from the\nsession when it expires. The only way known to me to do this is to implement one\nof those Interfaces (can't remember which one currently)\n\n> \n> I think with different thread ( when include the page in other application), \n> when it will operate the session object, it will not synchronize the session \n> object (or its filed accessCount).\n>\nThat seems reasonable. If the access count is not properly synchronized it will\nindeed become screwed eventually.\nYet it is strange that it will only occur in our application if we use the ajp13\nconnector with SSL requests. \nSSL on tomcat standalone - everyting OK.\nPlain http through Apache httpd (Linux) with ajp13 - everything OK\nSSL through Apache httpd (Linux) with ajp13 - No Session timeouts\nSSL through IIS with ajp13 - No Session timeouts\nBasically the same application on all machines...\n\nI'll try and stress-test my testserver a little and see if I can reproduce it\nwith enough simultaneous requests",
            "date": "20060207T16:03:55",
            "id": 9
        },
        {
            "author": null,
            "body": "(In reply to comment #9)\n> Please check this defect: 28846\n> \n> I think it should be the same problem. :-)\n\nBut that bug applies to the tapestry project.\nIs the engine mentioned in that bug the tapestry engine or the tomcat engine?",
            "date": "20060207T16:15:09",
            "id": 10
        },
        {
            "author": null,
            "body": "(In reply to comment #11)\n> (In reply to comment #9)\n> > Please check this defect: 28846\n> > \n> > I think it should be the same problem. :-)\n> \n> But that bug applies to the tapestry project.\n> Is the engine mentioned in that bug the tapestry engine or the tomcat engine?\n\n\nWe're seeing this same issue, as well.  We're using tomcat 5.5.4, and we appear\nto only see it in environments under heavy load when using the ajp13 connector.\n We have another customer redirecting from IIS and they're not experiencing this\nissue.\n\nI spent a couple hours looking at the code and I didn't see anything weird. \nWhat I can tell you is that for the sessions this occurs on, their inactivity\ntime IS properly set, but they still don't get invalidated.  When I call\ninvalidate on those sessions, they ARE invalidated.\n\nWe're not using the tapestry project at all--just Tomcat and Apache (or Tomcat\nand IIS).\n\nThose sessions which fail to invalidate stay around forever--or seemingly so. \nI've seen inactivity times in the 2500+ minutes range.\n",
            "date": "20060207T18:46:11",
            "id": 11
        },
        {
            "author": null,
            "body": "(In reply to comment #10)\n> (In reply to comment #8)\n> > Do you mean that wo browsers use the same session to access a page, or just the\n> > ( quite usual ) case that two people use the web application?\n> > \n> > A: not the same session. Different IE browser will generate differnt session \n> > ID.\n> > \n> > That means in the included application B and C you get the session from\n> > application A?\n> > \n> > Application != context for you?\n> > \n> > A: yes.\n> \n> Ok, so you can replicate the error if:\n> 1. you have two or more simultaneous users accessing a page in your web\napplication.\n> 2. you have more than one application (servlet / jsp) within the same context,\n> so the session stays the same through all requests.\n> 3. one of your servlets includes the output from other servlets/jsps\n> \n> Did I get that right?\n>  \n> > \n> > \n> > So it seems that the common ground for all of us here is, that we have some\n> > objects in the session that implement the HttpSessionBindingListener or\n> > HttpSessionActivationListener.\n> > \n> > A: I did not put any object implement the HttpSessionBindingLisener or \n> > HttpSessionActivationListener in the session.\n> > \n> Ah - I had thought so, because you mentioned you remove the objects from the\n> session when it expires. The only way known to me to do this is to implement one\n> of those Interfaces (can't remember which one currently)\n> \n> > \n> > I think with different thread ( when include the page in other application), \n> > when it will operate the session object, it will not synchronize the session \n> > object (or its filed accessCount).\n> >\n> That seems reasonable. If the access count is not properly synchronized it will\n> indeed become screwed eventually.\n> Yet it is strange that it will only occur in our application if we use the ajp13\n> connector with SSL requests. \n> SSL on tomcat standalone - everyting OK.\n> Plain http through Apache httpd (Linux) with ajp13 - everything OK\n> SSL through Apache httpd (Linux) with ajp13 - No Session timeouts\n> SSL through IIS with ajp13 - No Session timeouts\n> Basically the same application on all machines...\n> \n> I'll try and stress-test my testserver a little and see if I can reproduce it\n> with enough simultaneous requests\n\nWe're seeing this issue on our NON-SSL Apache ajp13 system...  so I don't think\nSSL is a requirement for this issue to occur.",
            "date": "20060207T18:49:01",
            "id": 12
        },
        {
            "author": null,
            "body": "> We're seeing this issue on our NON-SSL Apache ajp13 system...  so I don't \nthink\n> SSL is a requirement for this issue to occur.\n\nAll sessions to my instance of Tomcat are HTTP - they all come from a Proxy \n(Apache) which translates HTTPS to HTTP - so I produce this bug with no SSL \nand no ajp13.\n",
            "date": "20060208T10:13:28",
            "id": 13
        },
        {
            "author": null,
            "body": "> We're seeing this same issue, as well.  We're using tomcat 5.5.4, and we appear\n> to only see it in environments under heavy load when using the ajp13 connector.\n>  We have another customer redirecting from IIS and they're not experiencing this\n> issue.\n> \n> I spent a couple hours looking at the code and I didn't see anything weird. \n> What I can tell you is that for the sessions this occurs on, their inactivity\n> time IS properly set, but they still don't get invalidated.  When I call\n> invalidate on those sessions, they ARE invalidated.\n> [...] \n> Those sessions which fail to invalidate stay around forever--or seemingly so. \n> I've seen inactivity times in the 2500+ minutes range.\n> \nThis all fits into the threads issue theory.\nTomcat maintians a reference count for each session which is increased at the\nbeginning of a request and decreased at he end of the request.\n\nIf - for whatever reason - this reference count does not reach zero after all\nrequests have finished (e.g. because one thread was increasing while another was\ndecreasing, or an exception occurred which is not propably handled or... )\ntomcat will not invalidate the session because it thinks there is still some\nrequest currently running (which basically is a good thing. I do generally NOT\nwant my session to expire while a request is still running: e.g. a large download )\n\nBut this is still only a theory - I need to find a few free minutes to implement\na test case...",
            "date": "20060208T10:21:07",
            "id": 14
        },
        {
            "author": null,
            "body": "(In reply to comment #15)\n> > We're seeing this same issue, as well.  We're using tomcat 5.5.4, and we appear\n> > to only see it in environments under heavy load when using the ajp13 connector.\n> >  We have another customer redirecting from IIS and they're not experiencing this\n> > issue.\n> > \n> > I spent a couple hours looking at the code and I didn't see anything weird. \n> > What I can tell you is that for the sessions this occurs on, their inactivity\n> > time IS properly set, but they still don't get invalidated.  When I call\n> > invalidate on those sessions, they ARE invalidated.\n> > [...] \n> > Those sessions which fail to invalidate stay around forever--or seemingly so. \n> > I've seen inactivity times in the 2500+ minutes range.\n> > \n> This all fits into the threads issue theory.\n> Tomcat maintians a reference count for each session which is increased at the\n> beginning of a request and decreased at he end of the request.\n> \n> If - for whatever reason - this reference count does not reach zero after all\n> requests have finished (e.g. because one thread was increasing while another was\n> decreasing, or an exception occurred which is not propably handled or... )\n> tomcat will not invalidate the session because it thinks there is still some\n> request currently running (which basically is a good thing. I do generally NOT\n> want my session to expire while a request is still running: e.g. a large\ndownload )\n> \n> But this is still only a theory - I need to find a few free minutes to implement\n> a test case...\n\nI don't mean to throw a wrench in the works, but if that's true, wouldn't that\nmean calling invalidate on the session later would NOT invalidate the session,\nor does invalidate ignore the session access count?\n\nAlso, I just wanted to confirm that there are no large files to download in our\nsystem, so all of these users definately have an inactive connection--we're not\nseeing normal system behavior waiting on files.\n",
            "date": "20060208T18:11:42",
            "id": 15
        },
        {
            "author": null,
            "body": "(In reply to comment #16)\n> I don't mean to throw a wrench in the works, but if that's true, wouldn't that\n> mean calling invalidate on the session later would NOT invalidate the session,\n> or does invalidate ignore the session access count?\n> \n> Also, I just wanted to confirm that there are no large files to download in our\n> system, so all of these users definately have an inactive connection--we're not\n> seeing normal system behavior waiting on files.\n> \nMost of all this happens in org.apache.catalina.session.StandardSession and\norg.apache.catalina.session.StandardManager.\n\nCalling invalidate() on the session more or less directly maps through to\nexpire(), which will simply set the accessCount to 0 and remove the session from\nthe sessionManager.\n\nAfter spending the whole of yesterday afternoon debugging I can also confirm,\nthat it is indeed the accesssCount running out of sync. Alas, I still can not\nreproduce the problem. ( we found the wrong accessCount by running the failing\nproduction machine in debug mode and connecting to it with jdb)\n\nOn my local (Windows XP) development machine with Sun-jdk 1.5.0_06, tomcat\n5.0.28 and apache 2.0.55 connected through ajp13 (same setup as production,\nexcept for the OS) this simply does not occur.\n\nI also have second thoughts about the race condition theory, because one would\nexpect, that such a thing would happen only once in a while - but on the servers\nwe are seeing the issue on, it happens all the time (if not every time)...",
            "date": "20060209T09:57:26",
            "id": 16
        },
        {
            "author": null,
            "body": "Has there been any update on this bug?",
            "date": "20060301T15:51:25",
            "id": 17
        },
        {
            "author": null,
            "body": "I have the same problem, some sessions never expire (tomcat 5.5.12, jdk 1.5.0).\nIt seems that the session accessCount is not correctly decremented.\n\nIn my application, a single web browser can send several asynchronous\nXmlHttpRequests at the same time, so there are concurrent accesses on the server\nsesssion.\n\nI have a look at tomcat source code and it seems that the session validy\nmanagement is not always 'synchronized', so I agree with the \"race condition\ntheory\" ...\n\n\n",
            "date": "20060309T18:22:47",
            "id": 18
        },
        {
            "author": null,
            "body": "(In reply to comment #19)\n> \n> I have a look at tomcat source code and it seems that the session validy\n> management is not always 'synchronized', so I agree with the \"race condition\n> theory\" ...\n> \nYes, that were my thoughts as well, but the ++ and -- operations (as in\nsessionCount++) are atomic because sessionCount is an int. They should not need\nto be synchronized according to the virtual machine specifications.\n\nOn another note: We also recently moved one perfectly well working installation\nto a new server, and suddntly we encounter this issue there as well.\nPrevious installation:\nSingle-Intel-CPU \nSuSE 9.0 Linux with kernel 2.6.11\nTomcat 5.0.29 - standalone\njdk1.5.0_02\n\ncurrent installation:\nDual AMD-x64 CPUs \nSuSE 9.3 (mostly out-of the box) with kernel 2.6.14\nTomcat 5.0.30\nApache httpd\nmod_jk\njdk1.5.0_06 (x64)\n\nSo the trigger has to be either the 64bit CPU / Java or Tomcat and mod_jk, or\nsomething in my configuration (the application is the same .war file)\n\nI do not have local access to any x64 machine, so I cannot debug that here,\nmaybe someone else can jump in?\n ",
            "date": "20060310T08:03:34",
            "id": 19
        },
        {
            "author": null,
            "body": "(In reply to comment #20)\n\n> Yes, that were my thoughts as well, but the ++ and -- operations (as in\n> sessionCount++) are atomic because sessionCount is an int. They should not need\n> to be synchronized according to the virtual machine specifications.\n\nGenerally this is not enough to have thread-safe code. For instance this kind of\ncode is not thread-safe:\n  this.x--;\n  if (this.x == 0) ...\nIn this case AtomicInteger.decrementAndGet can be used.\n\n> \n> So the trigger has to be either the 64bit CPU / Java or Tomcat and mod_jk, or\n> something in my configuration (the application is the same .war file)\n\nThreading problems (ie lack of synchronization) are more visible on multi-CPU or\nmulti-core configurations.\n",
            "date": "20060310T08:40:13",
            "id": 20
        },
        {
            "author": null,
            "body": "> \n> Generally this is not enough to have thread-safe code. For instance this kind of\n> code is not thread-safe:\n>   this.x--;\n>   if (this.x == 0) ...\n> In this case AtomicInteger.decrementAndGet can be used.\n\nOf course, but as far as I could tell, in the tomcat session-management there is\na sessionCount-- for every sessionCount++, so in the end there should be a total\nsessionCount of 0. Maybe one of the checks for sessionCount==0 does not always\nimmediately give the 'correct' result - but in the long run it has always to\nreturn to zero.\n\n\n> \n> > \n> > So the trigger has to be either the 64bit CPU / Java or Tomcat and mod_jk, or\n> > something in my configuration (the application is the same .war file)\n> \n> Threading problems (ie lack of synchronization) are more visible on multi-CPU or\n> multi-core configurations.\n> \nI'll have to check if all machines we see this on are multi-core...",
            "date": "20060310T08:54:36",
            "id": 21
        },
        {
            "author": null,
            "body": "(In reply to comment #19)\n> I have the same problem, some sessions never expire (tomcat 5.5.12, jdk 1.5.0).\n> It seems that the session accessCount is not correctly decremented.\n> \n> In my application, a single web browser can send several asynchronous\n> XmlHttpRequests at the same time, so there are concurrent accesses on the server\n> sesssion.\n> \n> I have a look at tomcat source code and it seems that the session validy\n> management is not always 'synchronized', so I agree with the \"race condition\n> theory\" ...\n> \n\nIt's possible but rare. -1 for adding syncs, though (feel free to use a patched\nTomcat), as accessCount is a gimmick to support stupid usage scenarios\n(basically, people who were using really long running requests with really short\nexpiration times). Either a smarter way of implementing this could be used, or\nthe session could simply be expired if it becomes inactive for a really long\nperiod (say, one hour, or 5 times the regular timeout, whichever is greater).\n",
            "date": "20060310T11:08:43",
            "id": 22
        },
        {
            "author": null,
            "body": "Proposed patch:\n\nin org.apache.catalina.session.StandardSession\n line 284 (tomcat 5.0.28)\n\n    /**\n     * The access count for this session.\n     */\n    protected transient int accessCount = 0;\n\nhas to be replaced by \n\n    /**\n     * The access count for this session.\n     */\n    protected volatile transient int accessCount = 0;\n\nExplanation:\nThe expression accessCount++ is not thread-safe because each thread may hold a\nlocal copy of the variable which does not have to be synchronized with main\nmemory immediately.\nThe volatile keyword forces this synchronization.\n\nSee the discussion on \nhttp://forum.java.sun.com/thread.jspa?threadID=604831&start=30&tstart=0\n\n[quote]\n2) Local vs. main mem: Threads have--or can have--their own local copies of\nshared variables. When T1 writes a value to a variable, if the variable is not\nvolatile and there's no syncing, that new value may live only in T1's local copy\nand may never get written to main mem, which means other threads may never see\nthat new value. Entering and leaving sync blocks forces a reconciliation between\nthe thread's local memory and main mem. Declaring a variable volatile forces\nevery read and write of that variable to go to main mem.\n[end quote]\n\nAnother solution would be to synchronize the code segments.\n\nI have to apologize for my claim that ++ and -- were atomic for int datatypes. \nThis seems to be only true for single-CPU systems (without hyperThreading).",
            "date": "20060310T11:15:53",
            "id": 23
        },
        {
            "author": null,
            "body": "(In reply to comment #24)\n> Proposed patch:\n\n-1. Pretend you read my comment.",
            "date": "20060310T11:28:16",
            "id": 24
        },
        {
            "author": null,
            "body": "(In reply to comment #25)\n> (In reply to comment #24)\n> > Proposed patch:\n> \n> -1. Pretend you read my comment.\n\nWell, apart from the fact that I wrote my comment while you posted yours\n(mid-air-collision)\n\nI don't see any obvious reason against syncing the accessCount with the volatile\nkeyword. The accesscount obviously needs to be synchronized in some way (or be\nremoved, which I don't fancy because of large, time consuming, downloads).\nOf course I would be happy to improve my understanding, so please explain. \n\nFor the \"rare\" issue. We see quite some of these stale sessions. (appx. 2-10 a day)\nI'm not saying that this is a major security issue, but it over time it gives an\nattacker quite a chance to guess some sessionId.\n\nMany people will not even be aware of this issue, because you can only see it if\nyou keep track of sessions yourself. All others might take a look into the\nmanager application and enjoy the number of concurrent users they usually have,\nnot knowing those sessions should have expired a long time ago.",
            "date": "20060310T12:04:24",
            "id": 25
        },
        {
            "author": null,
            "body": "(In reply to comment #26)\n> Well, apart from the fact that I wrote my comment while you posted yours\n> (mid-air-collision)\n> \n> I don't see any obvious reason against syncing the accessCount with the volatile\n> keyword.\n\nAnd you verified it actually fixed this \"issue\" ?\n\n> For the \"rare\" issue. We see quite some of these stale sessions. (appx. 2-10 a\nday)\n> I'm not saying that this is a major security issue, but it over time it gives an\n> attacker quite a chance to guess some sessionId.\n> \n> Many people will not even be aware of this issue, because you can only see it if\n> you keep track of sessions yourself. All others might take a look into the\n> manager application and enjoy the number of concurrent users they usually have,\n> not knowing those sessions should have expired a long time ago.\n\nAs usual, 2-3 useless paragraphs as soon as there's a disagreement with a user.\nSpecial bonus for the security fud ;)",
            "date": "20060310T12:51:51",
            "id": 26
        },
        {
            "author": null,
            "body": "(In reply to comment #24)\n> Proposed patch:\n> \n> in org.apache.catalina.session.StandardSession\n>  line 284 (tomcat 5.0.28)\n> \n>     /**\n>      * The access count for this session.\n>      */\n>     protected transient int accessCount = 0;\n> \n> has to be replaced by \n> \n>     /**\n>      * The access count for this session.\n>      */\n>     protected volatile transient int accessCount = 0;\n> \n> Explanation:\n> The expression accessCount++ is not thread-safe because each thread may hold a\n> local copy of the variable which does not have to be synchronized with main\n> memory immediately.\n> The volatile keyword forces this synchronization.\n> \n> See the discussion on \n> http://forum.java.sun.com/thread.jspa?threadID=604831&start=30&tstart=0\n> \n> [quote]\n> 2) Local vs. main mem: Threads have--or can have--their own local copies of\n> shared variables. When T1 writes a value to a variable, if the variable is not\n> volatile and there's no syncing, that new value may live only in T1's local copy\n> and may never get written to main mem, which means other threads may never see\n> that new value. Entering and leaving sync blocks forces a reconciliation between\n> the thread's local memory and main mem. Declaring a variable volatile forces\n> every read and write of that variable to go to main mem.\n> [end quote]\n> \n> Another solution would be to synchronize the code segments.\n> \n> I have to apologize for my claim that ++ and -- were atomic for int datatypes. \n> This seems to be only true for single-CPU systems (without hyperThreading).\n\nVolatile may not be the best idea.  From the article:\nhttp://cephas.net/blog/2003/02/17/using_the_volatile_keyword_in_java.html\n\n\"Careful, volatile is ignored or at least not implemented properly on many\ncommon JVM's, including (last time I checked) Sun's JVM 1.3.1 for Windows. There\nwas an article on DDJ that could demonstrate this even on single-processor\nmachines...\"\n\nAnd from the article: \nhttp://www.javaperformancetuning.com/tips/volatile.shtml\n\n\"Note however that volatile has been incompletely implemented in most JVMs.\nUsing volatile may not help to achieve the results you desire (yes this is a JVM\nbug, but its been low priority until recently). \"\n\n\nOur environment:\nWe are only seeing this issue for sure on one machine, which is a 4 way (with\nHT--8 virtual CPU's) box.  We see the issue pretty frequently occur there... \nmaybe 20-100 times a day for a total of 2,000-4,000 total sessions.\n\nAlso, this environment is NOT 64-bit.  These are 32-bit HT Xeons.  They are\nrunning the Sun 1.4.2_06 or the 1.4.2_08 JDK...  So we know this issue occurs on\n32 bit systems as well.\n",
            "date": "20060310T16:17:31",
            "id": 27
        },
        {
            "author": null,
            "body": "(In reply to comment #28)\n> Volatile may not be the best idea.  From the article:\n> http://cephas.net/blog/2003/02/17/using_the_volatile_keyword_in_java.html\n\n-1 for sync, and feel free to test volatile (I'm only -0 for it). So the only\noption you have left is simple check to force expiration of sessions which are\nway past the normal timeout (like, ten times).",
            "date": "20060310T16:23:16",
            "id": 28
        },
        {
            "author": null,
            "body": "Per the previous comment: \"-1 for sync, and feel free to test volatile (I'm only\n-0 for it). So the only option you have left is simple check to force expiration\nof sessions which are way past the normal timeout (like, ten times).\", isn't\nthis a violation of the Servlet specification?   The specification states \"The\nsession-timeout element defines the default session timeout interval for all\nsessions created in this web application. The specified timeout must be\nexpressed in a whole number of minutes.  If the timeout is 0 or less, the\ncontainer ensures the default behaviour of sessions is never to time out. If\nthis element is not specified, the container must set its default timeout\nperiod.\"  So in other words, the session-timeout says how many minutes before\nthe session is expired.  To expire in more or less minute than that is a\nviolation of the specification, IMO.\n\nAlso, as a Tomcat user, let me tell you where our users are noticing and\ncomplaining about this bug.  We have a Current User Activity hyperlink in the\napplication that lets the system administrator view which users are online and\nhow long they have been idle.  This lets them see if, for example, see if any\nusers are online so that they know whether they can safely bounce Tomcat.",
            "date": "20060310T16:45:57",
            "id": 29
        },
        {
            "author": null,
            "body": "(In reply to comment #30)\n\nYou know, I do not care about what you think. I am proposing this, and that's\nthe way it will be, I will never accept a fix based on syncs (of course, it's\nOSS, so you are more than welcome to use a custom patch). BTW, this may not have\nanything to do with accessCount thread safety anyway.\n",
            "date": "20060310T17:06:27",
            "id": 30
        },
        {
            "author": null,
            "body": "I'm not trying to say this should be fixed with syncs.  I'm just trying to let\nyou know that there are users out there using this feature and that we would\nlike a fix if possible :)  It doesn't matter to me how the fix is implemented.",
            "date": "20060310T17:15:41",
            "id": 31
        },
        {
            "author": null,
            "body": "and it will be fixed if you can provide us with a test case to reproduce the\nproblem. That way we can fix the real problem, whether it requires sync or not\nsync is not relevant until we have identified the scenario where it happens.\n\nwithout a test case we could patch something different, leading to other\nproblems, and that is what Remy not so eloquently might be trying to explain to you.\n\n",
            "date": "20060310T17:21:03",
            "id": 32
        },
        {
            "author": null,
            "body": "(In reply to comment #33)\n> and it will be fixed if you can provide us with a test case to reproduce the\n> problem. That way we can fix the real problem, whether it requires sync or not\n> sync is not relevant until we have identified the scenario where it happens.\n> \n> without a test case we could patch something different, leading to other\n> problems, and that is what Remy not so eloquently might be trying to explain\nto you.\n> \n> \n\nIf we can get a reproducable test case, I will provide one to you.  As is, we\nare running the exact same software in hundreds of locations and we have only\nseen this at one site.  Attempts to reproduce it on nearly identical hardware\nwith a nearly identical configuration have been unsuccessful.  Our ability to\nreproduce the exact \n\nThanks for your help so far.  If possible, I will look into patching the system\nwith a volatile accessCount, but I don't think this is going to be possible.\n\n",
            "date": "20060310T17:36:55",
            "id": 33
        },
        {
            "author": null,
            "body": "Spare your time. Volatile is not going to save you. While \"x++\" looks somehow\natomic it simply isn't. Read as \"x = x+1\". Whether x is volatile or not simply\ndoesn't matter.\n\nIn order to do correct access counting, you need to synchronize or use the\natomics provided in Java 5. And anyone who opposes that should remove the\nvariable altogether as it doesn't do any good then. And should get some\nconsulting about his fear of synchronization.",
            "date": "20060311T12:10:18",
            "id": 34
        },
        {
            "author": null,
            "body": "Since this a severe bug for our customers (because multiple concurrent sessions\nare not allowed for a single user ID), I use the following simple workaround: \n\n1) A servlet Filter mapped to \"/*\" manages 2 session attributes (*):\n- the end date of the last service() call, which is more interesting than the\naccess date\n- the count of running service() calls\n\n2) An HttpSessionListener maintains a list of all valid sessions.\nIt has a timer that checks at a fixed rate if any session in this list has expired.\nThe inactivity duration is computed from the end date of the last service(), so\nlong running requests are correctly handled.\nSessions that have at least one running service() are not invalidated, they are\nchecked later.\n\n(*) the order of attribute updates is important to avoid a race condition that\ncan occur if the timer checks the session list between the two calls to\nsession.setAttribute().",
            "date": "20060312T14:24:28",
            "id": 35
        },
        {
            "author": null,
            "body": "As an aside it is possible to use atomics from Java 5 in lower versions over Java through the use of this open source library http://dcl.mathcs.emory.edu/util/backport-util-concurrent/\n",
            "date": "20060406T17:42:56",
            "id": 36
        },
        {
            "author": null,
            "body": "Alright, since a workaround has been suggested and the original poster has not\ncome up with a reproducible test case, I'm closing this item for now.  If the\noriginal poster or anyone else comes up with a way to reproduce this, please\nfeel free to reopen this item, attach your new test case, and we will be glad to\nlook at it.",
            "date": "20060413T19:53:51",
            "id": 37
        },
        {
            "author": null,
            "body": "(In reply to comment #38)\n> Alright, since a workaround has been suggested and the original poster has not\n> come up with a reproducible test case, I'm closing this item for now.  If the\n> original poster or anyone else comes up with a way to reproduce this, please\n> feel free to reopen this item, attach your new test case, and we will be glad to\n> look at it.\n\nI respectfully disagree.  A number of people (myself included) have reproduced\nthis bug, quite repeatedly.  I have a very reproducable testcase onsite, I am\njust unable to provide our whole application to a third party.  What we have\nbeen unable to provide is a self-contained testcase to reproduce this issue.\n\nI don't feel this is an issue that only one person has been dealing with--that\nwould justify closing it.  This issue has been seen on a number of environments,\nusing entirely different applications.\n\nThe workaround is to:\n1) Make a container object to hold the tomcat session and track the inactivity\nmanually\n2) Write a background thread to invalidate the session once it times out.\n\nI view this as a very serious bug in tomcat, even if it's difficult to\nreproduce.  I'm not blaming anyone or saying that it needs to get fixed--you\ncan't very well fix an issue you can't reproduce, but closing it when it still\nexists doesn't seem like a good idea.",
            "date": "20060413T20:02:50",
            "id": 38
        },
        {
            "author": null,
            "body": "I am re-opening this bug as I do not believe that marking it as 'works for me -\n fixed' is satisfactory to any of the people who are suffering this bug.\n\nIf it was just one person suffering from the bug then this might be an \nacceptable reply but given that there are multiple people who have reported \nit - and some people who have managed to debug Tomcat and suggest what the \nproblem might be - to just close it without proper investigation is \nunacceptable.\n\nI am aware that I have not provided a reproducable test case but like many \nother contributors I only see this issue in a live well loaded environment - \nin my case in a clients production environment - I simply cannot send you my \nclients entire application to test with and cannot reprodcue it here on our \ndevelopment machines - but this does not mean that there is not a problem.\n\nI look forward to some more in depth investigation and proposals for solving \nthis problem. Thanks, Eddie\n\n",
            "date": "20060503T11:30:22",
            "id": 39
        },
        {
            "author": null,
            "body": "We are seeing this issue in our production environment as well. We are running\n5.5.15 on a dual xeon processor ibm blade. We have seen it for atleast the last\nyear and found the same problem occurring on 5.0.28.  We are running an\nidentical staging configuration which we are unable to reproduce, presumably\nbecause it is only occurring under significant load. We discovered the problem\nwhen we implemented a session monitoring utility for our app.",
            "date": "20060607T18:08:39",
            "id": 40
        },
        {
            "author": null,
            "body": "(In reply to comment #38)\n> Alright, since a workaround has been suggested and the original poster has not\n> come up with a reproducible test case, I'm closing this item for now.  If the\n> original poster or anyone else comes up with a way to reproduce this, please\n> feel free to reopen this item, attach your new test case, and we will be glad to\n> look at it.\n\nIt sounds to me like the reproducible test case is the problem. It is pretty\nnear impossible to provide the application, hardware configuration AND load\nnecessary to reproduce this on a running instance of tomcat. In lieu of this, I\npropose a simple test case which reproduces in separate test code which closely\nmimics the behavior of tomcat. This behavior is essentially multiple requests in\nmultiple threads accessing the int accessCount field in a session object. Each\nthread will increment the accessCount and then decrement it when the request\ncompletes. Here is some sample code to which basically does that:\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class SharedIntTest\n{\n  public AtomicInteger execCount = new AtomicInteger();\n  public AtomicInteger countAtomic = new AtomicInteger();\n  public int count;\n  \n  public static void main( String[] args )\n  {\n    final SharedIntTest shared = new SharedIntTest();\n    int maxThreads = 1000;\n    \n    while ( true )\n    {\n      //Initialize counters\n      shared.countAtomic.set( 0 );\n      shared.execCount.set( 0 );\n      shared.count = 0;\n      \n      for ( int i = 0; i < maxThreads; i++ )\n      {\n        new Thread( new Runnable()\n         {\n              public void run()\n              {  \n                //increment counters\n                shared.countAtomic.incrementAndGet();\n                shared.count++;\n\n                //decrement counters\n                shared.countAtomic.decrementAndGet();\n                --shared.count;\n                \n                //increment execution counter\n                shared.execCount.incrementAndGet();\n              }\n            }\n        ).start();\n      }\n      \n      while ( shared.execCount.get() < maxThreads )\n      {\n        try\n        {\n          Thread.sleep( 10 );\n        }\n        catch( InterruptedException e )\n        {\n        }\n      }\n      \n      if ( shared.count != 0 ) \n        System.out.println( \"Count Error: \" + shared.count + \"/\" +\nshared.countAtomic.get() + \" \" + shared.execCount.get() );\n    }\n  }\n\n}\n\nThe variable count basically represents the accessCount field in the session. In\nthe body of the main method there is a while loop which repeatedly runs the test\ncode. The test code initalizes all of the variables, and then launches a number\nof threads, which represent the requests in tomcat which are all incrementing\nand decrementing accessCount on a given session. All that the threads do is to\nincrement the count variable and then immediately decrement it, basically what\nthe request threads are doing in tomcat. The threads also increment a variable\ncalled execCount which is used to determine the number of completed threads. In\nthe main thread, there is a loop which monitors the execCount to determine when\nall of the threads are completed. To make things interesting I have put an\nAtomicInteger counter in, countAtomic, to determine whether or not the Atomic\nsolution mentioned in comment #21 would resolve the issue.\n\nWhen run on a single processor, this could runs continuously and never prints\nany errors, as we would hope. When I run this code on a dual processor, within a\ncouple of minutes a test will run where the final result of the count variable\nis not zero. The countAtomic variable always has a final result of zero.\n\nIn conclusion, I believe that Matthias Ernst in comment #35 is exactly right,\neither a sync must be done or Atomics must be used. Otherwise the session\nmanagement code as it exists now will be very broken on multiprocessor machines.",
            "date": "20060608T21:16:14",
            "id": 41
        },
        {
            "author": null,
            "body": "Created attachment 18432\nStress Test Framework\n\nHere is complete working WAR application with source included that might be\nuseful to build a real testcase from (or any test cases that only appear under\nstress).\n\nThere is a web-app side, which you can either modify my DefaultServlet or add a\nnew servlet to provide additional code to help trigger the problem.  It would\nbe worth file you building a simple interface into your Session Management\nclasses\n\n\n\nThere is a HTTP traffic generator based around commons-httpclient,\nmulti-threaded.  You can theoretically extract the WAR onto a number of client\nmachines and/or use the same machine thats running Tomcat.\n\nInvokation suggestion:\n\n$ jar -xvf TCBug37356.war\n$ cd WEB-INF \n$ java -cp\nclasses:lib/commons-httpclient-3.0.1.jar:lib/commons-codec-1.3.jar:lib/commons-logging-1.0.4.jar:lib/log4j-1.2.13.jar\ntestpackage/TestClientTomcat\n\n\nPlaces to edit:\n\ntestpackage/TestClientTomcat: Edit the defaults at the top of the class, for\nURL, requests, simultaneous thread count.\n\nTestClientTomcat#startNextThread(): just before the call to #sweepOnce() you\nmight need to modify requests, like every 1000 inject a HTTP request to poll\nyour Session manager (through the servlet) to look for problems and report.\n\nTestClientRunnable#run(): ~around line 177~ Modify this to suit your HTTP\nrequest setup and response parsing.\n\n\nMaybe someone else could attach a cut down version of their session management\ncode for analying the state of TC from within.\n\nFeel free to email me privately for any assistance with it.",
            "date": "20060609T04:48:59",
            "id": 42
        },
        {
            "author": null,
            "body": "(In reply to comment #42)\n> In conclusion, I believe that Matthias Ernst in comment #35 is exactly right,\n> either a sync must be done or Atomics must be used. Otherwise the session\n> management code as it exists now will be very broken on multiprocessor machines.\n\nVery funny. Adding two syncs part of every request just to provide support for a\nreally stupid feature is not acceptable. The actual options are:\n- remove the \"no expire while requests are in progress\" feature by default, with\nan option to use the feature with full syncs for the two people that actually\nneed it\n- force expire of abnormally long sessions regardless of the accessCount value\n(many times over the session expiration time, with a minimum amount of time of a\nfew hours)\n",
            "date": "20060609T06:32:40",
            "id": 43
        },
        {
            "author": null,
            "body": "There seems to be an argument about two separate things. The bug is that session\nmanagement is broken. The poster wants it fixed and I think all the respondents\nwant it fixed. Plain and simple.\n\nThe second thing is that there is this feature to allow long requests with short\nsession expirations, and it happens to be the thing that doesn't work and is\nbreaking the session management. You have made it abundantly clear that you\nthing the feature is utterly idiotic. That's nice, I am glad you can share your\nemotions so freely, but as far as I am concerned, the feature is just breaking\nsomething which should fundamentally just work and it needs to be fixed. \n\nThe bottom line is, I don't think myself or anyone else on this thread wants to\nadd unnecessary syncs just to fix this problem. You keep responding as if that\nis what everyone wants. What people want is a fix. If the \"no expiration while\nrequest is in progress\" feature is an absolute must have, then you must sync. If\nit is not, then kill the feature or make it optional. I am not fighting for this\nfeature. I just want session management to work!\n\n(In reply to comment #44)\n> (In reply to comment #42)\n> > In conclusion, I believe that Matthias Ernst in comment #35 is exactly right,\n> > either a sync must be done or Atomics must be used. Otherwise the session\n> > management code as it exists now will be very broken on multiprocessor machines.\n> \n> Very funny. Adding two syncs part of every request just to provide support for a\n> really stupid feature is not acceptable. The actual options are:\n> - remove the \"no expire while requests are in progress\" feature by default, with\n> an option to use the feature with full syncs for the two people that actually\n> need it\n> - force expire of abnormally long sessions regardless of the accessCount value\n> (many times over the session expiration time, with a minimum amount of time of a\n> few hours)\n> \n\n",
            "date": "20060609T13:50:55",
            "id": 44
        },
        {
            "author": null,
            "body": "(In reply to comment #44)\n\n> Very funny. Adding two syncs part of every request just to provide support for a\n> really stupid feature is not acceptable.\n\nI don't know about calling it \"really stupid\".  Non-standard and not well\ntested, certainly.  Plus, since Sun points at Tomcat as the reference\nimplementation of the Servlet spec, extensions like this should be eliminated as\na matter of course.  In my humble opinion, of course.  =)\n\n> The actual options are:\n> - remove the \"no expire while requests are in progress\" feature by default, with\n> an option to use the feature with full syncs for the two people that actually\n> need it\n> - force expire of abnormally long sessions regardless of the accessCount value\n> (many times over the session expiration time, with a minimum amount of time of a\n> few hours)\n\nBoth of those options are also \"very funny\".  Please don't clutter up the code\nwith yet another config option.  Kill the feature and make folks who want it\nresort to a Filter or a Valve or something.  The thought of adding code to look\nat sessions with nonzero accessCounts and arbitrarily killing off sessions after\n\"many times over the expiration time\" has passed ... yuck.  A bug to fix a bug,\nnow that's non acceptable.  =P",
            "date": "20060609T14:24:27",
            "id": 45
        },
        {
            "author": null,
            "body": "Remy:  \n\nI see two possible options.\n\n1) Remove the code to keep sessions alive if in the middle of downloading and\npast their timeout.  While this is not standard--this very well may be needed in\nmany customer environments, and changing this behavior could break applications\nthat rely on this functionality.\n\n2) Properly synchronize the broken code.\n\nI realize that you object to the performance overhead of a couple synchronize\nblocks.  I'd like to reference the following pages:\nhttp://www-128.ibm.com/developerworks/java/library/j-jtp04223.html\nhttp://www-128.ibm.com/developerworks/java/library/j-threads1.html\n\nBoth of these pages state that synchronization overhead is much less than most\ndevelopers believe, and that modern JVM's are highly optimized to provide fast\nsynchronization.  Furthermore, synchronization is a fixed overhead and barely\nnoticable unless tested with empty or mostly empty methods which are called\nrepeatedly.  Tomcat's request handling does not resemble anything close to an\nempty method, and most likely the overhead of synchronization would be negligable.\n\nThe only way to know the overhead of adding two synchronized blocks for sure\nwould be to add the relevant code and do performance testing.  Perhaps if you\nagreed to consider a proposed patch to properly synchronize based on performance\nresults, someone would be willing to give you the relevant fix.  As things\ncurrently are, session expiration in Tomcat is broken on multi-processor\nsystems.  This is a SEVERE bug and worth a small amount of performance loss to fix.\n\nFurthermore, the synchronization should be performed on the session rather than\nglobally.  The vast majority of all requests would never contend for the\nsynchronization lock in this case--further reducing the overhead even more. \nOnly multiple requests on the same session would be serialized, and this would\nmost likely not limit scalability of Tomcat.\n\nI personally would rather see the appropriate synchronization added and\nperformance testing done to validate that the overhead is minimal.  I believe\nthat this solution would be better than possibly creating a regression in\nbehavior for people who use Tomcat to perform long operations with a \"short\"\ntimeout (for instance: hosting very large files to users on slow connections).\n\nEither way, the problem that needs to be fixed is session management.  Having a\nbroken session management system which does not properly invalidate connections\nis unacceptable.  The workaround for terming very long term sessions also seems\nlike a very bad idea to me.",
            "date": "20060609T15:31:59",
            "id": 46
        },
        {
            "author": null,
            "body": "Reading and posting to bugzilla is really a waste of time. Oh well ... So I will\nimplement option 1.",
            "date": "20060609T18:50:12",
            "id": 47
        },
        {
            "author": null,
            "body": "To Remy:\n\nPlease, don't do this, or provide an option to switch it on! Long running \nrequests are common, like:\n\n1) Downloading large files or items\n2) Uploading large files\n\nThe session MUST be synchronized, please think about multiple processor \nsystems, where parallel requests will be executed within different threads!\n\nI can't see, why you are so ignorant, and why you are insisting on a \nreal \"stupid\" (using our words) insynchronzed solution!\n\nPeter",
            "date": "20060827T13:29:29",
            "id": 48
        },
        {
            "author": null,
            "body": "*** Bug 40305 has been marked as a duplicate of this bug. ***",
            "date": "20060827T14:34:42",
            "id": 49
        },
        {
            "author": null,
            "body": "I have a simple test case that demonstrates this issue. I create two threads\nthat repeatedly call session.access() session.endAccess() on the same session\nobject. After running them for a five seconds, they are stopped and I manually\ncheck session.accessCount. With 1 thread it is zero. With two, it is typically\nin the low 1000s. This demonstrates conclusively that this is a thread-safety\nissue with session.accessCount\n\nUsing volatile sends it through the roof to 100,000s. I am afraid, therefore,\nthat this is not a viable option.\n\nUsing syncs does fix it but slows the access() and endAccess() calls by several\norders of magnitude (60ns total to 5.6ms total). This would have a serious\nperformance impact. I am looking at alternatives. All suggestions welcome.",
            "date": "20061029T18:33:15",
            "id": 50
        },
        {
            "author": null,
            "body": "(In reply to comment #51)\n> I have a simple test case that demonstrates this issue. I create two threads\n> that repeatedly call session.access() session.endAccess() on the same session\n> object. After running them for a five seconds, they are stopped and I manually\n> check session.accessCount. With 1 thread it is zero. With two, it is typically\n> in the low 1000s. This demonstrates conclusively that this is a thread-safety\n> issue with session.accessCount\n\nI'm unclear why there was a question in the first place. We have unsynchronized\naccess to a variable that depends on sane values in a multi-threaded environment.\n\nOddly enough, sessions in Tomcat (in general) appear to be impossible to make\nthreadsafe. Since StandardSession is wrapped in a StandardSessionFacade before\nbeing exposed to servlet code, and the facade is not guaranteed to have a 1-to-1\nmapping with the /real/ session, users cannot even synchronize on the \"session\"\nobject they get back from calling HttpServletRequest.getSession().\n\nI realize that I have brought up a different issue entirely, but the entire\ndiscussion above plus this fact lead me to the conclusion that the maintainers\nof Tomcat place a higher value on speed than thread safety.\n\nWhich is worse... adding a few ns* to calls to a few methods in StandardSession,\nor have sessions piling up on top of one another until you run out of memory?\n\n(*) Note that in the test Mark describes, the object locks are under contention.\nHe doesn't mention if his timings (sync'd vs. unsync'd) were in his\nsingle-thread or dual-thread runs. Uncontended locks are a lot faster than\ncontended locks, so I would expect many sessions to continue with less overhead\nthan those that are apparently getting many simultaneous accesses.",
            "date": "20061030T20:32:42",
            "id": 51
        },
        {
            "author": null,
            "body": "For completeness, with two threads the average difference was 60ns to 50ms.\nFor a single thread it was 75ns to 225ns.\n\nBear in mind all of these figures are somewhat artificial. The real figure will\nvary with webapp, hardware etc.",
            "date": "20061030T21:03:28",
            "id": 52
        },
        {
            "author": null,
            "body": "This has been fixed in SVN and will be in 5.5.21 onwards.\n\nIn summary:\n - accessCount is disabled by default\n - when enabled, access to accessCount is synchronized",
            "date": "20061104T17:12:22",
            "id": 53
        },
        {
            "author": null,
            "body": "Created attachment 19631\nA JSP That can be used to see the accessCount of a session\n\nFor people having doubts and still investigating about this bug, I put in\nattachment a small JSP that you can put at the root of your web application to\nsee if the bug is happening.\nYou can log into your application and call this JSP (e.g.\nhttp://localhost:8080/myWebApp/testSession.jsp) that will display the\naccessCount of your session. Just do some refresh into your application ( on a\nreal page ) and refresh the testSession.jsp.\nIf you have no request pending, the displayed accessCount should be (1), if\nit's greater, you triggered the bug.\nOn some of my applications, the accessCount takes 10 per each page, probably\ntrigggered by numerous GET request made by the browser for getting\nCSS/Javascript files (even in pessimistic cache mode).",
            "date": "20070222T07:40:22",
            "id": 54
        },
        {
            "author": null,
            "body": "if (Globals.STRICT_SERVLET_COMPLIANCE) {\n            synchronized (lock) {\n                accessCount++;\n            }\n        }\n\nIn 5.5.25, it add some synchronized code for the accessCount when ++ and -- \ncases, but did not add synchronized code for reading operation in isValid() \nand recycle() method.\n\npublic boolean isValid() {\n\n        if (this.expiring) {\n            return true;\n        }\n\n        if (!this.isValid ) {\n            return false;\n        }\n\n        if (accessCount > 0) {\n            return true;\n        }\n\n        if (maxInactiveInterval >= 0) { \n            long timeNow = System.currentTimeMillis();\n            int timeIdle = (int) ((timeNow - thisAccessedTime) / 1000L);\n            if (timeIdle >= maxInactiveInterval) {\n                expire(true);\n            }\n        }\n\n        return (this.isValid);\n    }\n\nIn tomcat 6.x, it use the AutomicInteger to fix this issue. Please check!",
            "date": "20080121T01:51:20",
            "id": 55
        },
        {
            "author": null,
            "body": "As a minimum, you need to provide an explanation of why this needs further work\nand ideally a test case that demonstrates this issue. I don't see any immediate\nissues with the reads not being synchronised.",
            "date": "20080121T12:58:37",
            "id": 56
        }
    ],
    "component": "Catalina",
    "description": "I am encountering a problem with Tomcat 5.0.28. I have an application which \ntimes users sessions out after 5 minutes of inactivity. \n\nI have written some extensions to the manager app that allow me to list \nsessions for a given context and also to force an invalidation of sessions \nthat have been idle for over a specified period of time.\n\nUsing these tools I can see that I have a lot of sessions with an idle_time \nfar in excess of 5 minutes - values of over 24 hours are not uncommon.\n\nUsing my manager extensions I am then able to force these sessions to \ninvalidate, at which point my HttpSessionBindingListener class (valueUnbound \nmethod) is invoked and logs the user connected to that session out, before \ninvalidating the session and it being removed from the list of sessions. \n\nThe fact that the user log out can take place without any problems on \nthese 'stale' sessions seems to indicate that the problem is that the session \nhas not been invalidated - as in Tomcat has made no attempt to invalidate the \nsession after the idle expiry time has passed, there are no error messages \nposted in any logs and try as I might I am unable to reproduce this behaviour \non 2 other test systems even when completing the same actions as the \nproduction system users do that cause this problem.\n\nClearly I have checked that the configuration is correct - indeed some \nsessions will be timed out as expected so there cannot be a configuration \nproblem.",
    "hasPatch": false,
    "hasScreenshot": false,
    "id": "37356",
    "issuetypeClassified": "BUG",
    "issuetypeTracker": "BUG",
    "priority": "P2 normal",
    "product": "Tomcat 5",
    "project": "TOMCAT",
    "summary": "Tomcat does not invalidate sessions after session-timeout period has passed.",
    "systemSpecification": true,
    "version": "Nightly Build"
}