{
    "comments": [
        {
            "author": "Thierry Gu\u00e9rin",
            "body": "Here are the diffs against tag 4.0.1 of both httpClient and httpCore",
            "date": "2010-06-08T15:27:44.480+0000",
            "id": 0
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Thierry\n\nWould it be a big deal for you to re-create the diffs against HttpCore trunk [1]? There has been a number of changes in HttpCore since the last official release. In particular HttpEntity contract has been simplified and clarified. It is quite possible you will no longer need to patch HttpCore.\n\nA test case for the bug would also be just great ;-). You might use this class as a starting point [2]   \n\nOleg\n\n[1] http://svn.apache.org/repos/asf/httpcomponents/httpcore/trunk/ \n[2] http://svn.apache.org/repos/asf/httpcomponents/httpclient/trunk/httpclient/src/test/java/org/apache/http/impl/client/TestClientAuthentication.java",
            "date": "2010-06-08T19:29:47.835+0000",
            "id": 1
        },
        {
            "author": "Thierry Gu\u00e9rin",
            "body": "Here are the diffs against the trunk. Reason I did them first against the 4.0.1 tag is that my goal is to use this on a production server, and I'm kind of not inclined to use versions that are labeled alpha ;)\nI also couldn't find if there was a planned bugFix release (4.0.2), do you think this could happen in the somewhat near future?\nAnyway, back to the changes: the new HttpEntity contract indeed clarifies isStreaming, but it raises two new problems:\n* InputStreamEntity does not comply with this (isStreaming still returns !consumed whereas it should always return true)\n* there is no way now to test whether a stream has been consumed or not.\n\nFor now, I kept the fix the same as for 4.0.1 (I'm using isStreaming to check if a stream has been consumed), but I think HttpEntity needs a isConsumed() method, otherwise I don't see how I can make this work without relying on code that doesn't comply with the contract. What do you think?\n\nAs for the test case, thanks for providing the starting point, I must admit I didn't know where to start... I'll try to find the time to do it by the end of the week\n\n",
            "date": "2010-06-09T09:21:30.855+0000",
            "id": 2
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "> I also couldn't find if there was a planned bugFix release (4.0.2), do you think this could happen in the somewhat near future? \n\nAt the moment there are no plans for 4.0.2. I do not see this issue as severe enough to warrant a bug fix release but am willing to reconsider\n\n>  * InputStreamEntity does not comply with this (isStreaming still returns !consumed whereas it should always return true) \n\nI am pretty sure this has been changed in SVN trunk. Just pull the latest code snapshot.\n\n> * there is no way now to test whether a stream has been consumed or not. \n\nThe trouble is we cannot add methods to the existing interfaces including HttpEntity as long as we want to remain 4.x API compatible. Another problem is that there is simply no reliable way of knowing whether an entity has been really consumed without wrapping the underlying content stream, which is something I would like to avoid.\n\n> For now, I kept the fix the same as for 4.0.1 (I'm using isStreaming to check if a stream has been consumed), \n> but I think HttpEntity needs a isConsumed() method, otherwise I don't see how I can make this work without \n> relying on code that doesn't comply with the contract. What do you think? \n\nI think this is the job of the request wrapper object to maintain the conversational state of the current request and to know whether the enclosed entity has been written out to the socket or not. I believe it should be possible to resolve the problem just by tweaking EntityEnclosingRequestWrapper class. That is why it is super-critical that we have a test case for the problem.\n\nOleg",
            "date": "2010-06-09T10:14:29.160+0000",
            "id": 3
        },
        {
            "author": "Thierry Gu\u00e9rin",
            "body": "> At the moment there are no plans for 4.0.2. I do not see this issue as severe enough to warrant a bug fix release but am willing to reconsider\n\nok. As for me I find it a pretty severe bug, because the workaround is to use ByteArrayInputStreams, and this would quickly be a memory hog, but then again, as no one reported this bug before, I guess not many people use the same scenario as me :)\n\n>> * InputStreamEntity does not comply with this (isStreaming still returns !consumed whereas it should always return true)\n\n> I am pretty sure this has been changed in SVN trunk. Just pull the latest code snapshot.\n\nmy bad, didn't update before diffing. getContent is still broken though ;)\n\n>> * there is no way now to test whether a stream has been consumed or not.\n\n>The trouble is we cannot add methods to the existing interfaces including HttpEntity as long as we want to remain 4.x API compatible. Another\n>problem is that there is simply no reliable way of knowing whether an entity has been really consumed without wrapping the underlying\n>content stream, which is something I would like to avoid.\n\n>I think this is the job of the request wrapper object to maintain the conversational state of the current request and to know whether the\n>enclosed entity has been written out to the socket or not. I believe it should be possible to resolve the problem just by tweaking\n>EntityEnclosingRequestWrapper class. \n\nWell, seeing that EntityEnclosingRequestWrapper has no way of knowing what's done with the entity once getEntity has been called, I don't really see how you would know the enclosed entity has been written out to the socket without wrapping the entity itself and overriding writeTo (other than using events but I don't think you want to go there).\nThe solution may lie in RequestWrapper.getExecCount, which only seems targeted at knowing if a request can be repeated (and is the source of the bug in DefaultRequestDirector.tryExecute: \"wrapper.getExecCount() > 1 && !wrapper.isRepeatable()\"). From what I understand, a non repeatable entityEnclosingRequest can be repeated as long as its underlying entity hasn't been consumed; Is this correct? If so, then getExecCount is broken because its sole purpose is to know if an entityEnclosingRequest can be repeated, and it doesn't reflect the entity's status. \n\nWhat do you think?\n\n>That is why it is super-critical that we have a test case for the problem.\n\nHere they are (testClientAuthentication.diff). Unfortunately, the testBasicAuthenticationSuccessOnNonRepeatablePutExpectContinue() test can't pass even if the bug is fixed, because LocalTestServer sends a 100 (instead of a 401) during the handshake when it receives a header with Expect: Continue. I don't feel confident enough with the code to try and fix that, sorry.\nThe second test (testBasicAuthenticationFailureOnNonRepeatablePutDontExpectContinue()) is somewhat  redundant with testBasicAuthenticationFailureOnNonRepeatablePost(), but as it explicitly specifies setBooleanParameter(CoreProtocolPNames.USE_EXPECT_CONTINUE, false), I find it useful. Feel free to discard it.\n\nThierry",
            "date": "2010-06-11T14:35:38.848+0000",
            "id": 4
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "> ok. As for me I find it a pretty severe bug\n\nLook. ASF releases are MAJOR pain in the rectum. It is just not possible for me to cut a new release for each and every bug.  I have a one month old daughter, grumpy wife and lots of other things I need to take care of besides HttpClient. \n\nThere has been a few other bug reports recently, which makes 4.0.2 more likely.\n\n> getContent is still broken though ;)\n\nHuh, why? HttpCore will no longer try to prevent the user from obtaining the same content stream multiple times. It is now up to the user to decide what to do with the content stream.\n\n> a non repeatable entityEnclosingRequest can be repeated as long as its underlying entity hasn't been consumed; Is this correct? \n\nCorrect\n\n> If so, then getExecCount is broken because its sole purpose is to know if an entityEnclosingRequest can be repeated, and it doesn't reflect the entity's status. \n\nI disagree. The exec count is merely a request count. It does what it does.\n\nThe core of the problem is that HttpClient currently can't know whether 'expect-continue' handshake was used or not. There are different ways of addressing the problem without changing the HttpEntity contract. One would be tweaking HttpRequestExecutor in HttpCore. Another one would be wrapping HttpClientConnection and monitoring #sendRequestEntity method.\n\n> because LocalTestServer sends a 100 (instead of a 401) during the handshake when it receives a header with Expect: Continue\n\nThis behaviour can be changed by using a custom expectation verifier. \n\nOleg\n",
            "date": "2010-06-11T19:44:13.750+0000",
            "id": 5
        },
        {
            "author": "Thierry Gu\u00e9rin",
            "body": "> Look. ASF releases are MAJOR pain in the rectum. It is just not possible for me to cut a new release for each and every bug. I have a one month old daughter, \n> grumpy wife and lots of other things I need to take care of besides HttpClient. \nAs always, smileys can't convey entirely one's thoughts, so let me (try to) be more clear: I'd be glad to have a 4.0.2, but I understand that this bug cannot be labeled as breaking the 4.0.1 release and warranting a new release on its own, seeing that it doesn't look to bother anyone but me. And I appreciate the time you're putting into this. I'm just trying to help, please bear with me as English is not my primary language and I know what I'm writing can be tactless. This is not my intent at all.\n\n> Huh, why? HttpCore will no longer try to prevent the user from obtaining the same content stream multiple times. It is now up to the user to decide what to do \n> with the content stream.\nWell, as I told you, I'm no HttpCore/Client expert, so I'm relying on the API and the code, and in httpCore trunk, here's the javaDoc for HttpEntity.getContent():\n     * Creates a new InputStream object of the entity. It is an interface\n     * violation to return the same {@link InputStream} object more than\n     * once. Entities that are not {@link #isRepeatable repeatable}\n     * should throw an exception if this method is called multiple times.\nLooks like it's not up to date, so disregard my comment on getContent being broken.\n\n>> If so, then getExecCount is broken because its sole purpose is to know if an entityEnclosingRequest can be repeated, and it doesn't reflect the entity's status.\n>I disagree. The exec count is merely a request count. It does what it does. \nWhat I meant is that it looked to me that the exec count was created to know if an entityEnclosingRequest could be repeated, as I couldn't find any other uses in the code for it, and so its purpose was not fulfilled. Didn't think it could have been created without this purpose in mind, my bad. \n\n> The core of the problem is that HttpClient currently can't know whether 'expect-continue' handshake was used or not. There are different ways of addressing\n> the problem without changing the HttpEntity contract. One would be tweaking HttpRequestExecutor in HttpCore. Another one would be wrapping\n> HttpClientConnection and monitoring #sendRequestEntity method.\n\n> This behaviour can be changed by using a custom expectation verifier.\n\nThanks for the pointers, I'll look into it next week\n\n",
            "date": "2010-06-11T21:05:09.049+0000",
            "id": 6
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "My apologies for being such a grumpy old man. Thanks for pointing out inconsistencies in Javadocs of the HttpEntity interface I overlooked. Please review the updated version:\n\nhttp://svn.apache.org/viewvc?rev=953893&view=rev\n\nI committed the test cases with some minor tweaks. The testBasicAuthenticationSuccessOnNonRepeatablePutExpectContinue test case now verifies user credentials during the expect-continue phase by means of a custom HttpExpectionVerifier. Please review:\n\nhttp://svn.apache.org/viewvc?rev=953890&view=rev\n\nThanks for all your help and contributions. \n\nOleg\n\n    ",
            "date": "2010-06-11T22:35:00.980+0000",
            "id": 7
        },
        {
            "author": "Thierry Gu\u00e9rin",
            "body": "After looking at HttpRequestExecutor: would it be ok to use the ExecutionContext to store the fact that the request entity has been consumed, just as HttpRequestExecutor does it for the whole http request (cf  line 252: context.setAttribute(ExecutionContext.HTTP_REQ_SENT, Boolean.TRUE))?\nIt would only require to add a constant to ExecutionContext (HTTP_REQ_ENT_CONSUMED for instance) and change the test in DefaultRequestDirector to check for this boolean instead of the wrapper request count. \n\nI did a quick test and it works as expected, what do you think?\n",
            "date": "2010-06-21T09:36:27.573+0000",
            "id": 8
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Thierry,\n\nFeel free to raise a separate JIRA for this change against HttpCore. However, I suggest we go for the entity decorator / wrapper approach, as it would enable us to back-port the fix to 4.0.x branch without too much trouble. \n\nCheers\n\nOleg ",
            "date": "2010-06-21T11:43:35.066+0000",
            "id": 9
        },
        {
            "author": "Thierry Gu\u00e9rin",
            "body": "Oleg,\n\nI'm a bit confused here, as looking at the 4.0.x sources, the code change would be exactly the same (setting a boolean in the HttpContext during HttpRequestExecutor#doSendRequest, and changing DefaultRequestDirector to take that into account). Am I missing something?\n\nStill, if you prefer wrapping the HttpClientConnection, I'll look into it, but I'm not sure I'll have time before mid-July (holidays).",
            "date": "2010-06-21T13:16:34.071+0000",
            "id": 10
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "> Am I missing something? \n\nThe problem is the change would require a release of HttpCore before it could be employed by HttpClient. \n\n> Still, if you prefer wrapping the HttpClientConnection, I'll look into it, but I'm not sure I'll have time before mid-July (holidays). \n\nOf course, my sinister plan was to talk you into seeing the whole issue to some sort of a logical conclusion. No problem, though, I'll come up with a fix within a few days.\n\nOleg",
            "date": "2010-06-21T14:10:01.955+0000",
            "id": 11
        },
        {
            "author": "Thierry Gu\u00e9rin",
            "body": "Oleg,\n\nhad some spare time, so here are the changes using a connection wrapper.\n\nAre you still interested in the diff to core 4.1 that adds the HTTP_REQ_ENT_CONSUMED to the context when the entity? It would avoid having the wrapper and make for nicer code IMHO.\n\ncheers,\n\nThierry",
            "date": "2010-06-22T09:12:22.425+0000",
            "id": 12
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "> had some spare time, so here are the changes using a connection wrapper. \n\nYep. Almost there. I can't help thinking, though, wrapping HttpEntity would probably be somewhat cleaner. I did not like the idea of wrapping the underlying content stream, but wrapping the entity should be perfectly fine.\n\n> Are you still interested in the diff to core 4.1 that adds the HTTP_REQ_ENT_CONSUMED to the context when the entity?\n\nYes, I am. Please raise a separate issue for this change against HttpCore module.\n\nCheers\n\nOleg",
            "date": "2010-06-22T09:33:45.518+0000",
            "id": 13
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Fixed  in SVN trunk and 4.0.x branch. Please review.\n\nOleg",
            "date": "2010-06-22T20:31:47.996+0000",
            "id": 14
        },
        {
            "author": "Richard Bassous",
            "body": "I am using the latest in trunk for both httpClient and httpCore\n\nI am getting this error on some devices (cell phones) , not all\nHere is the code:\n\nInputStreamEntity reqEntity = new InputStreamEntity(\n\t\tnew MyFileInputStream(file,upl), fileLength);\nreqEntity.setContentType(\"binary/octet-stream\");\nreqEntity.setChunked(false);\n\n\t\nhttppost.setEntity(reqEntity);\nHttpResponse response = httpclient.execute(httppost);\t//failure\nHttpEntity resEntity = response.getEntity();\n\n\n\norg.apache.http.client.ClientProtocolException\nat org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:702)\nat org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:625)\nat org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:603)\nCaused by: org.apache.http.client.NonRepeatableRequestException: Cannot retry request with a non-repeatable request entity.  The cause lists the reason the original request failed.\n\n\nAny ideas?????\n",
            "date": "2010-08-21T16:41:37.214+0000",
            "id": 15
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "You can use wire / context logging to find out why the request had to be retried.\n\nhttp://hc.apache.org/httpcomponents-client-4.0.1/logging.html\n\nOleg",
            "date": "2010-08-21T20:37:27.946+0000",
            "id": 16
        },
        {
            "author": "Richard Bassous",
            "body": "Thanks Oleg:\nIt seems to be something with the SSL\nI added the logs:\n\nHere is a sample log from a working upload(I removed the host and IP):\nIt has a lot of debug here (I Think its the file content)\nthen.....\n08-22 12:23:52.979: << \"HTTP/1.1 200 OK[\\r][\\n]\"\n08-22 12:23:52.981: << \"Date: Sun, 22 Aug 2010 16:25:20 GMT[\\r][\\n]\"\n08-22 12:23:52.991: << \"Server: Microsoft-IIS/6.0[\\r][\\n]\"\n08-22 12:23:52.991: << \"X-Powered-By: ASP.NET[\\r][\\n]\"\n08-22 12:23:52.991: << \"X-AspNet-Version: 2.0.50727[\\r][\\n]\"\n08-22 12:23:53.001: << \"Cache-Control: private[\\r][\\n]\"\n08-22 12:23:53.001: << \"Content-Type: text/html; charset=utf-8[\\r][\\n]\"\n08-22 12:23:53.001: << \"Content-Length: 484[\\r][\\n]\"\n08-22 12:23:53.001: << \"[\\r][\\n]\"\n08-22 12:23:53.011: Receiving response: HTTP/1.1 200 OK\n08-22 12:23:53.011: << HTTP/1.1 200 OK\n08-22 12:23:53.011: << Date: Sun, 22 Aug 2010 16:25:20 GMT\n08-22 12:23:53.011: << Server: Microsoft-IIS/6.0\n08-22 12:23:53.011: << X-Powered-By: ASP.NET\n08-22 12:23:53.011: << X-AspNet-Version: 2.0.50727\n08-22 12:23:53.011: << Cache-Control: private\n08-22 12:23:53.011: << Content-Type: text/html; charset=utf-8\n08-22 12:23:53.011: << Content-Length: 484\n08-22 12:23:53.021: Connection can be kept alive for ever\n08-22 12:23:53.021: Shutting down\n08-22 12:23:53.021: Connection closed\n08-22 12:23:53.091: Get connection: HttpRoute[{s}->https://****.com], timeout = 10000\n08-22 12:23:53.091: [HttpRoute[{s}->https://****.com]] total kept alive: 0, total issued: 0, total allocated: 0 out of 20\n08-22 12:23:53.091: No free connections [HttpRoute[{s}->https://****.com]][null]\n08-22 12:23:53.091: Available capacity: 2 out of 2 [HttpRoute[{s}->https://****.com]][null]\n08-22 12:23:53.091: Creating new connection [HttpRoute[{s}->https://****.com]]\n08-22 12:23:53.091: Connecting to ****.com/*.*.*.*:443\n08-22 12:23:53.461: CookieSpec selected: best-match\n08-22 12:23:53.461: Attempt 1 to execute request\n08-22 12:23:53.501: Shutting down\n08-22 12:23:53.501: Sending request: POST /UploadFiles.aspx HTTP/1.1\n08-22 12:23:53.501: >> \"POST /UploadFiles.aspx HTTP/1.1[\\r][\\n]\"\n08-22 12:23:53.501: >> \"Cache-Control: no-cache[\\r][\\n]\"\n08-22 12:23:53.501: >> \"Pragma: no-cache[\\r][\\n]\"\n08-22 12:23:53.501: >> \"Authorization: Basic *****************[\\r][\\n]\"\n08-22 12:23:53.511: >> \"ty: 0[\\r][\\n]\"\n08-22 12:23:53.511: >> \"v: 252[\\r][\\n]\"\n08-22 12:23:53.511: >> \"u: 354957030634904[\\r][\\n]\"\n08-22 12:23:53.511: >> \"postType: 0[\\r][\\n]\"\n08-22 12:23:53.511: >> \"filenum: -999[\\r][\\n]\"\n08-22 12:23:53.511: >> \"pl: 1[\\r][\\n]\"\n08-22 12:23:53.511: >> \"on: 1[\\r][\\n]\"\n08-22 12:23:53.521: >> \"mf: 5[\\r][\\n]\"\n08-22 12:23:53.521: >> \"Transfer-File-Name: **** [\\r][\\n]\"\n08-22 12:23:53.521: >> \"Transfer-File-Chunk-Count: 1[\\r][\\n]\"\n08-22 12:23:53.521: >> \"Transfer-File-Chunk: 0[\\r][\\n]\"\n08-22 12:23:53.521: >> \"filelength: 5120[\\r][\\n]\"\n08-22 12:23:53.521: >> \"Cookie: ASP.NET_SessionId=4eypxj45tsnabe45ficbnd55; path=/; HttpOnly[\\r][\\n]\"\n08-22 12:23:53.521: >> \"Content-Length: 5120[\\r][\\n]\"\n08-22 12:23:53.521: >> \"Content-Type: binary/octet-stream[\\r][\\n]\"\n08-22 12:23:53.521: >> \"Host: ****.com[\\r][\\n]\"\n08-22 12:23:53.521: >> \"Connection: Keep-Alive[\\r][\\n]\"\n08-22 12:23:53.531: >> \"[\\r][\\n]\"\n08-22 12:23:53.531: >> POST /UploadFiles.aspx HTTP/1.1\n08-22 12:23:53.531: >> Cache-Control: no-cache\n08-22 12:23:53.531: >> Pragma: no-cache\n08-22 12:23:53.531: >> Authorization: Basic  *****************\n08-22 12:23:53.531: >> ty: 0\n08-22 12:23:53.531: >> v: 252\n08-22 12:23:53.531: >> u: 354957030634904\n08-22 12:23:53.531: >> postType: 0\n08-22 12:23:53.531: >> filenum: -999\n08-22 12:23:53.531: >> pl: 1\n08-22 12:23:53.531: >> on: 1\n08-22 12:23:53.531: >> mf: 5\n08-22 12:23:53.531: >> Transfer-File-Name: ****\n08-22 12:23:53.531: >> Transfer-File-Chunk-Count: 1\n08-22 12:23:53.531: >> Transfer-File-Chunk: 0\n08-22 12:23:53.531: >> filelength: 5120\n08-22 12:23:53.531: >> Cookie: ASP.NET_SessionId=4eypxj45tsnabe45ficbnd55; path=/; HttpOnly\n08-22 12:23:53.531: >> Content-Length: 5120\n08-22 12:23:53.531: >> Content-Type: binary/octet-stream\n08-22 12:23:53.531: >> Host: ****.com\n08-22 12:23:53.531: >> Connection: Keep-Alive\n\n\n\nAnd here is the same log from a non working device:\nIt has a lot of debug here (I Think its the file content)\nthen.....\n08-22 12:19:18.374 D: Connection closed\n08-22 12:19:18.374 D: Closing the connection.\n08-22 12:19:18.374 D: Connection closed\n08-22 12:19:18.374 I: I/O exception (java.io.IOException) caught when processing request: SSL shutdown failed: I/O error during system call, Broken pipe\n08-22 12:19:18.397 D: SSL shutdown failed: I/O error during system call, Broken pipe\n08-22 12:19:18.397 D: java.io.IOException: SSL shutdown failed: I/O error during system call, Broken pipe\n08-22 12:19:18.397 D:   at org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl.nativeclose(Native Method)\n08-22 12:19:18.397 D:   at org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl.close(OpenSSLSocketImpl.java:958)\n08-22 12:19:18.397 D:   at org.apache41.http.impl.SocketHttpClientConnection.close(SocketHttpClientConnection.java:259)\n08-22 12:19:18.397 D:   at org.apache41.http.impl.conn.DefaultClientConnection.close(DefaultClientConnection.java:162)\n08-22 12:19:18.397 D:   at org.apache41.http.impl.conn.AbstractPooledConnAdapter.close(AbstractPooledConnAdapter.java:152)\n08-22 12:19:18.397 D:   at org.apache41.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:129)\n08-22 12:19:18.397 D:   at org.apache41.http.impl.client.DefaultRequestDirector.tryExecute(DefaultRequestDirector.java:623)\n08-22 12:19:18.397 D:   at org.apache41.http.impl.client.DefaultRequestDirector.execute(DefaultRequestDirector.java:453)\n08-22 12:19:18.397 D:   at org.apache41.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:700)\n08-22 12:19:18.397 D:   at org.apache41.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:625)\n08-22 12:19:18.397 D:   at org.apache41.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:603)\n08-22 12:19:18.397 D:   at hg.a(ProGuard:2446)\n08-22 12:19:18.397 D:   at b.a(ProGuard:1962)\n08-22 12:19:18.397 D:   at b.a(ProGuard:1563)\n08-22 12:19:18.397 D:   at e.run(ProGuard:1509)\n08-22 12:19:18.397 I: Retrying request\n08-22 12:19:18.405 D: Reopening the direct connection.\n08-22 12:19:18.405 D: Connecting to ****.com/*.*.*.*:443\n08-22 12:19:20.288 D: Cannot retry non-repeatable request\n08-22 12:19:20.296 D: Connection shut down\n08-22 12:19:20.296 D: Released connection is not reusable.\n08-22 12:19:20.296 D: Releasing connection [HttpRoute[{s}->https://****.com]][null]\n08-22 12:19:20.296 D: Notifying no-one, there are no waiting threads\n08-22 12:19:20.311 E: null\n08-22 12:19:20.311 E: org.apache41.http.client.ClientProtocolException\n08-22 12:19:20.311 E:   at org.apache41.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:702)\n08-22 12:19:20.311 E:   at org.apache41.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:625)\n08-22 12:19:20.311 E:   at org.apache41.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:603)\n08-22 12:19:20.311 E:   at hg.a(ProGuard:2446)\n08-22 12:19:20.311 E:   at b.a(ProGuard:1962)\n08-22 12:19:20.311 E:   at b.a(ProGuard:1563)\n08-22 12:19:20.311 E:   at e.run(ProGuard:1509)\n08-22 12:19:20.311 E: Caused by: org.apache41.http.client.NonRepeatableRequestException: Cannot retry request with a non-repeatable request entity.  The cause lists the reason the original request failed.\n08-22 12:19:20.311 E:   at org.apache41.http.impl.client.DefaultRequestDirector.tryExecute(DefaultRequestDirector.java:610)\n08-22 12:19:20.311 E:   at org.apache41.http.impl.client.DefaultRequestDirector.execute(DefaultRequestDirector.java:453)\n08-22 12:19:20.311 E:   at org.apache41.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:700)\n08-22 12:19:20.311 E:   ... 6 more\n08-22 12:19:20.311 E: Caused by: java.io.IOException: SSL shutdown failed: I/O error during system call, Broken pipe\n08-22 12:19:20.311 E:   at org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl.nativeclose(Native Method)\n08-22 12:19:20.311 E:   at org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl.close(OpenSSLSocketImpl.java:958)\n08-22 12:19:20.311 E:   at org.apache41.http.impl.SocketHttpClientConnection.close(SocketHttpClientConnection.java:259)\n08-22 12:19:20.311 E:   at org.apache41.http.impl.conn.DefaultClientConnection.close(DefaultClientConnection.java:162)\n08-22 12:19:20.311 E:   at org.apache41.http.impl.conn.AbstractPooledConnAdapter.close(AbstractPooledConnAdapter.java:152)\n08-22 12:19:20.311 E:   at org.apache41.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:129)\n08-22 12:19:20.311 E:   at org.apache41.http.impl.client.DefaultRequestDirector.tryExecute(DefaultRequestDirector.java:623)\n08-22 12:19:20.311 E:   ... 8 more\n08-22 12:19:20.319 D: Shutting down\n08-22 12:19:22.507 D: Shutting down",
            "date": "2010-08-22T18:44:25.593+0000",
            "id": 17
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Richard \n\nThe log does not seem complete. It starts with 'Connection closed' entry, which is strange. What kind of JRE are you using? It is Harmony?\n\nOleg",
            "date": "2010-08-22T20:33:46.715+0000",
            "id": 18
        },
        {
            "author": "Richard Bassous",
            "body": "Oleg\n\nThanks again for the quick reply\nThe log starts with\n---------beginning of /dev/log/main\nthen I see a bunch of unreadable text\nI am assuming its base64 of the file content then\nConnection closed. Message\nThis is running on Android\nIt seems the close is getting called from httpclient\n\nAny more ideas?",
            "date": "2010-08-22T20:56:24.814+0000",
            "id": 19
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Right, but I need to know what leads to that close() method call. Try disabling wire logs, while leaving context / header logs on.\n\nOleg",
            "date": "2010-08-22T21:02:26.318+0000",
            "id": 20
        },
        {
            "author": "Richard Bassous",
            "body": "OK..\n\nThe new log has no wire just context:\n\nit's not failing all the time, just intermittently,  in this case there was one pass and one fail after it.\n\nI am suspecting that the socket is not getting closed properly from the pass?\nalthough I am calling\nhttpclient.getConnectionManager().shutdown();\n\n\nHere are the logs:\n\n08-23 13:11:27.759 D/: Get connection: HttpRoute[{s}->https://.com], timeout = 10000\n08-23 13:11:27.767 D/: [HttpRoute[{s}->https://.com]] total kept alive: 0, total issued: 0, total allocated: 0 out of 20\n08-23 13:11:27.767 D/: No free connections [HttpRoute[{s}->https://.com]][null]\n08-23 13:11:27.767 D/: Available capacity: 2 out of 2 [HttpRoute[{s}->https://.com]][null]\n08-23 13:11:27.767 D/: Creating new connection [HttpRoute[{s}->https://.com]]\n08-23 13:11:27.876 D/: Connecting to .com/*.*.*.*:443\n08-23 13:11:28.509 D/: CookieSpec selected: best-match\n08-23 13:11:28.540 D/: Attempt 1 to execute request\n08-23 13:11:28.540 D/: Sending request: POST /UploadFiles.aspx HTTP/1.1\n08-23 13:11:28.556 D/: >> POST /UploadFiles.aspx HTTP/1.1\n08-23 13:11:28.556 D/: >> Cache-Control: no-cache\n08-23 13:11:28.556 D/: >> Pragma: no-cache\n08-23 13:11:28.556 D/: >> Authorization: Basic ****\n08-23 13:11:28.556 D/: >> ty: 0\n08-23 13:11:28.556 D/: >> v: 252\n08-23 13:11:28.556 D/: >> u: A000002201F102\n08-23 13:11:28.556 D/: >> postType: 1\n08-23 13:11:28.556 D/: >> filenum: 0\n08-23 13:11:28.556 D/: >> pl: 1\n08-23 13:11:28.556 D/: >> on: 1\n08-23 13:11:28.556 D/: >> mf: 5\n08-23 13:11:28.556 D/: >> Transfer-File-Name: file1\n08-23 13:11:28.556 D/: >> Transfer-File-Chunk-Count: 1\n08-23 13:11:28.556 D/: >> Transfer-File-Chunk: 0\n08-23 13:11:28.556 D/: >> filelength: 39024636\n08-23 13:11:28.556 D/: >> Cookie: ASP.NET_SessionId=v2jltw45cmu4wtiznidhavnx; path=/; HttpOnly\n08-23 13:11:28.556 D/: >> Content-Length: 39024636\n08-23 13:11:28.556 D/: >> Content-Type: binary/octet-stream\n08-23 13:11:28.556 D/: >> Host: .com\n08-23 13:11:28.556 D/: >> Connection: Keep-Alive\n08-23 13:13:12.150 D/: Get connection: HttpRoute[{s}->https://.com], timeout = 10000\n08-23 13:13:12.150 D/: [HttpRoute[{s}->https://.com]] total kept alive: 0, total issued: 0, total allocated: 0 out of 20\n08-23 13:13:12.150 D/: No free connections [HttpRoute[{s}->https://.com]][null]\n08-23 13:13:12.150 D/: Available capacity: 2 out of 2 [HttpRoute[{s}->https://.com]][null]\n08-23 13:13:12.150 D/: Creating new connection [HttpRoute[{s}->https://.com]]\n08-23 13:13:12.197 D/: Connecting to .com/*.*.*.*:443\n08-23 13:13:12.868 D/: CookieSpec selected: best-match\n08-23 13:13:12.868 D/: Attempt 1 to execute request\n08-23 13:13:12.868 D/: Sending request: POST /UploadFiles.aspx HTTP/1.1\n08-23 13:13:12.876 D/: >> POST /UploadFiles.aspx HTTP/1.1\n08-23 13:13:12.876 D/: >> Cache-Control: no-cache\n08-23 13:13:12.876 D/: >> Pragma: no-cache\n08-23 13:13:12.876 D/: >> Authorization: Basic ****\n08-23 13:13:12.876 D/: >> ty: 0\n08-23 13:13:12.876 D/: >> v: 252\n08-23 13:13:12.876 D/: >> u: A000002201F102\n08-23 13:13:12.876 D/: >> postType: 1\n08-23 13:13:12.876 D/: >> filenum: 0\n08-23 13:13:12.876 D/: >> pl: 1\n08-23 13:13:12.876 D/: >> on: 1\n08-23 13:13:12.876 D/: >> mf: 5\n08-23 13:13:12.884 D/: >> Transfer-File-Name: file2\n08-23 13:13:12.884 D/: >> Transfer-File-Chunk-Count: 1\n08-23 13:13:12.884 D/: >> Transfer-File-Chunk: 0\n08-23 13:13:12.884 D/: >> filelength: 39024636\n08-23 13:13:12.884 D/: >> Cookie: ASP.NET_SessionId=v2jltw45cmu4wtiznidhavnx; path=/; HttpOnly\n08-23 13:13:12.884 D/: >> Content-Length: 39024636\n08-23 13:13:12.884 D/: >> Content-Type: binary/octet-stream\n08-23 13:13:12.884 D/: >> Host: .com\n08-23 13:13:12.884 D/: >> Connection: Keep-Alive\n08-23 13:13:57.556 D/: Connection closed\n08-23 13:13:57.587 D/: Closing the connection.\n08-23 13:13:57.587 D/: Connection closed\n08-23 13:13:57.650 I/: I/O exception (java.io.IOException) caught when processing request: SSL shutdown failed: I/O error during system call, Broken pipe\n08-23 13:13:57.665 D/: SSL shutdown failed: I/O error during system call, Broken pipe\n08-23 13:13:57.665 D/: java.io.IOException: SSL shutdown failed: I/O error during system call, Broken pipe\n08-23 13:13:57.665 D/:       at org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl.nativeclose(Native Method)\n08-23 13:13:57.665 D/:       at org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl.close(OpenSSLSocketImpl.java:958)\n08-23 13:13:57.665 D/:       at org.apache41.http.impl.SocketHttpClientConnection.close(SocketHttpClientConnection.java:259)\n08-23 13:13:57.665 D/:       at org.apache41.http.impl.conn.DefaultClientConnection.close(DefaultClientConnection.java:162)\n08-23 13:13:57.665 D/:       at org.apache41.http.impl.conn.AbstractPooledConnAdapter.close(AbstractPooledConnAdapter.java:152)\n08-23 13:13:57.665 D/:       at org.apache41.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:129)\n08-23 13:13:57.665 D/:       at org.apache41.http.impl.client.DefaultRequestDirector.tryExecute(DefaultRequestDirector.java:623)\n08-23 13:13:57.665 D/:       at org.apache41.http.impl.client.DefaultRequestDirector.execute(DefaultRequestDirector.java:453)\n08-23 13:13:57.665 D/:       at org.apache41.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:700)\n08-23 13:13:57.665 D/:       at org.apache41.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:625)\n08-23 13:13:57.665 D/:       at org.apache41.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:603)\n08-23 13:13:57.665 D/:       at hg.a(ProGuard:2446)\n08-23 13:13:57.665 D/:       at b.a(ProGuard:1962)\n08-23 13:13:57.665 D/:       at b.a(ProGuard:1563)\n08-23 13:13:57.665 D/:       at e.run(ProGuard:1509)\n08-23 13:13:57.665 I/: Retrying request\n08-23 13:13:57.665 D/: Reopening the direct connection.\n08-23 13:13:57.665 D/: Connecting to .com/*.*.*.*:443\n08-23 13:13:58.025 D/: Cannot retry non-repeatable request\n08-23 13:13:58.033 D/: Connection shut down\n08-23 13:13:58.033 D/: Released connection is not reusable.\n08-23 13:13:58.033 D/: Releasing connection [HttpRoute[{s}->https://.com]][null]\n08-23 13:13:58.040 D/: Notifying no-one, there are no waiting threads\n08-23 13:13:58.056 E/: null\n08-23 13:13:58.056 E/: org.apache41.http.client.ClientProtocolException\n08-23 13:13:58.056 E/:   at org.apache41.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:702)\n08-23 13:13:58.056 E/:   at org.apache41.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:625)\n08-23 13:13:58.056 E/:   at org.apache41.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:603)\n08-23 13:13:58.056 E/:   at hg.a(ProGuard:2446)\n08-23 13:13:58.056 E/:   at b.a(ProGuard:1962)\n08-23 13:13:58.056 E/:   at b.a(ProGuard:1563)\n08-23 13:13:58.056 E/:   at e.run(ProGuard:1509)\n08-23 13:13:58.056 E/: Caused by: org.apache41.http.client.NonRepeatableRequestException: Cannot retry request with a non-repeatable request entity.  The cause lists the reason the original request failed.\n08-23 13:13:58.056 E/:   at org.apache41.http.impl.client.DefaultRequestDirector.tryExecute(DefaultRequestDirector.java:610)\n08-23 13:13:58.056 E/:   at org.apache41.http.impl.client.DefaultRequestDirector.execute(DefaultRequestDirector.java:453)\n08-23 13:13:58.056 E/:   at org.apache41.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:700)\n08-23 13:13:58.056 E/:   ... 6 more\n08-23 13:13:58.056 E/: Caused by: java.io.IOException: SSL shutdown failed: I/O error during system call, Broken pipe\n08-23 13:13:58.056 E/:   at org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl.nativeclose(Native Method)\n08-23 13:13:58.056 E/:   at org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl.close(OpenSSLSocketImpl.java:958)\n08-23 13:13:58.056 E/:   at org.apache41.http.impl.SocketHttpClientConnection.close(SocketHttpClientConnection.java:259)\n08-23 13:13:58.056 E/:   at org.apache41.http.impl.conn.DefaultClientConnection.close(DefaultClientConnection.java:162)\n08-23 13:13:58.056 E/:   at org.apache41.http.impl.conn.AbstractPooledConnAdapter.close(AbstractPooledConnAdapter.java:152)\n08-23 13:13:58.056 E/:   at org.apache41.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:129)\n08-23 13:13:58.056 E/:   at org.apache41.http.impl.client.DefaultRequestDirector.tryExecute(DefaultRequestDirector.java:623)\n08-23 13:13:58.056 E/:   ... 8 more\n08-23 13:13:58.064 D/: Shutting down",
            "date": "2010-08-23T19:47:39.601+0000",
            "id": 21
        },
        {
            "author": "Richard Bassous",
            "body": "Oleg:\n\nAny ideas on the log I posted please...\n\nThanks",
            "date": "2010-08-25T00:35:29.007+0000",
            "id": 22
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "So, do I understand it correctly that your application is posting ~30MB of stuff using a non-repeatable entity? Well, what are the changes of temporarily losing the connection while such amount of data is being uploaded over a wireless link? The only problem on the HttpClient side is that the original I/O exception gets lost because the HttpConnection#close() method called by HttpRequestExecutor also terminates abnormally with an I/O exception. Feel free to raise a JIRA for this issue. \n\nOleg",
            "date": "2010-08-25T13:07:18.008+0000",
            "id": 23
        },
        {
            "author": "Richard Bassous",
            "body": "In the mean time..\n\nIs there a work around..???\n\nwhen it retries why does it fail?????\n\nis it not shutting down properly??",
            "date": "2010-08-25T14:56:26.160+0000",
            "id": 24
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Use self-contained (repeatable) entity implementation.\n\nhttp://hc.apache.org/httpcomponents-client-4.0.1/tutorial/html/fundamentals.html#d4e93\n\nPlease post all your further questions to the user list.\n\nOleg",
            "date": "2010-08-25T15:31:04.944+0000",
            "id": 25
        },
        {
            "author": "Richard Bassous",
            "body": "repeatable entity means that I have to buffer the whole file into memory, (this is why I started using httpclient to start with, because URLConnection buffers the whole thing and I get outofmemory exception)\n\nAre you saying this is a bug with httpClient???",
            "date": "2010-08-26T14:36:00.646+0000",
            "id": 26
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "> repeatable entity means that I have to buffer the whole file into memory,\n\nNo, it does not. An entity does not have to be buffered in memory in order to be repeatable. It just need to be able to recreate its input stream\n\n> Are you saying this is a bug with httpClient???\n\nNo, it is not.\n\nDid you read the section of the tutorial I referred you to? If you have any further questions, post them to the user list.\n\nOleg",
            "date": "2010-08-26T14:53:06.775+0000",
            "id": 27
        }
    ],
    "component": "HttpClient (classic)",
    "description": "I'm trying to upload a file to a WebDav server (mod_dav on Apache Web Server 2.2.14) that has basic (or digest, the result is the same) authentication enabled.\nI'm using the following code:\n        String url = \"http://myserver/dir/test2.gif\";\n        File file = new File(\"d:/test2.gif\");\n        DefaultHttpClient httpClient = new DefaultHttpClient();\n        HttpPut put = new HttpPut(url);\n        put.setEntity(new InputStreamEntity(new FileInputStream(file), file.length()));\n        \n        URI uri = put.getURI();\n        httpClient.getCredentialsProvider().setCredentials(new AuthScope(uri.getHost(), uri.getPort()),\n                getCredentials());\n        put.getParams().setBooleanParameter(CoreProtocolPNames.USE_EXPECT_CONTINUE, true);\n        HttpResponse response = httpClient.execute(put);\n        System.out.println(response.getStatusLine());\n\nWhen running the above code, I'm getting a org.apache.http.client.NonRepeatableRequestException: Cannot retry request with a non-repeatable request entity. I tested both the latest alpha & the svn head. Doing the same thing in HttpClient 3.1 worked as expected. \n\nThis could be normal, as I'm using an InputStream that is indeed not repeatable, but as I'm also using Expect: 100-Continue, the stream shouldn't have been consumed with the first connection (the one that gets a code 401 from the WebDav server), and only in the second one, when the credentials are provided.\n\nThe problem is that DefaultRequestDirector.execute doesn't take this into account and assumes that if a request has been tried once, its associated entity (if any) has been consumed.\nHere's the fix that I came up with:\nChange DefaultRequestDirector.execute so that if the wrapper is an EntityEnclosingRequestWrapper, it checks if the entity has actually been consumed before throwing a NonRepeatableRequestException. I'm using the method isStreaming() from HttpEntity, as it's the closest thing to what I was looking for. Reading the JavaDoc, it could lead to the situation where an entity has started streaming but has not yet finished, and so is not in a state where it can be used. However I don't think that's a problem as the javadoc for HttpEntity.getContent() states that it can't be called two times on a non-repeatable entity, so it's just a matter of when the request will fail.\nThis lead me to also modify InputStreamEntity (from the httpCore project) as it didn't comply with the javadoc. With these two modifications, The file upload completes successfully.\n\nI also modified:\n * TestInputStreamEntity.testBasics() (from the httpCore project) test so that it complies with getContent()'s Javadoc.\n * TestDefaultClientRequestDirector.FaultyHttpRequestExecutor because it didn't consume the entity's content.\nAll the tests from both httpCore and httpClient pass.\nI tested both InputStreamEntity and BasicHttpEntity.\n \nPlease keep in mind that I am by no means an httpClient (or http, for that matter) expert, and these modifications may have some unexpected side-effects that I did not foresee, contain plain dumb code, or whatever, so it would be great if someone could review my changes and give their opinion.\n",
    "hasPatch": false,
    "hasScreenshot": false,
    "id": "HTTPCLIENT-951",
    "issuetypeClassified": "BUG",
    "issuetypeTracker": "BUG",
    "priority": "Major",
    "product": "HTTPCLIENT",
    "project": "HTTPCLIENT",
    "summary": "Incorrect handling of InputStreams when connecting to a server that requires authentication",
    "systemSpecification": true,
    "version": "4.0 Final, 4.0.1, 4.1 Alpha1, 4.1 Alpha2"
}