{
    "comments": [
        {
            "author": "Oleg Kalnichevski",
            "body": "HttpClient has never been meant to be a browser, however we MAY consider\nproviding a lightweight caching API without a concrete implementation in version 4.0\n\nOleg",
            "date": "2005-02-11T05:12:55.000+0000",
            "id": 0
        },
        {
            "author": "Roland Weber",
            "body": "make that version 5",
            "date": "2007-02-05T19:48:08.381+0000",
            "id": 1
        },
        {
            "author": "Sebb",
            "body": "This would be useful for JMeter, though it would probably not want to store the full pages, only enough to identify them and the relevant headers.\n\nSo it would be useful if the logic to determine cacheability etc was implemented independently of the store.",
            "date": "2009-02-13T16:27:31.578+0000",
            "id": 2
        },
        {
            "author": "Mike Youngstrom",
            "body": "This would be extremely useful in the case of restful service calls.  If http client could emulate a browsers caching logic and then expose an api that that will allow developers to plug this logic into their system's caching solution that would be awesome!!!!!  I've looked around and couldn't find any other http library that offers such functionality.  Client side caching could mark a big reason for frameworks such as CXF and Spring RestTemplate (provides Commons Http Client) to add Http Components as an optional client.\n\nThis isn't really a case of HttpClient trying to be a browser.  It's a case for HttpClient to taking advantage of standard http headers to provide a well understood caching model.",
            "date": "2010-02-13T16:28:21.763+0000",
            "id": 3
        },
        {
            "author": "Avlesh Singh",
            "body": "I agree to Mike's comment. Caching would be a boon for all rest based API's. \nI am ready to take on this issue and come up with a prototype. Can someone help me on where exactly to get started with? Is it HttpMethodBase?\n\nWould common's cache (http://commons.apache.org/sandbox/cache/) be good enough to start with, or something as complex as JSC (http://jakarta.apache.org/jcs/) is needed?",
            "date": "2010-02-18T12:19:39.475+0000",
            "id": 4
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Avlesh,\n\nThis is how I _personally_ think this issue should be addressed :\n\n(1) Firstly, one needs to define an abstract API for storing and retrieving content from an abstract cache. A single interface HttpCache (or some such) is likely to be sufficient.\n\n(2) Different implementations of the said caching API should be possible. The default one can be very simple just backed by a HashMap instance. For a more sophisticated implementation I would recommend using ehcache [1]\n\n(3) The caching logic should be implemented as a decorator for the HttpClient interface [2]. It should be possible to take any arbitrary instance of HttpClient and enhance it with caching capabilities.\n\nOleg\n\n[1] http://www.ehcache.org/\n[2] http://hc.apache.org/httpcomponents-client/httpclient/apidocs/org/apache/http/client/HttpClient.html",
            "date": "2010-02-18T13:44:15.758+0000",
            "id": 5
        },
        {
            "author": "Avlesh Singh",
            "body": "Thanks Oleg, these would be good for me to get started.\nFor your #3, shouldn't caching be tightly coupled with HttpClient rather than being implemented as a decorator? More so, because, caching can only be implemented if the response headers direct an HttpClient instance to do so. Having said this, I definitely agree to the fact that actual cache should be an API implementation thereby giving users the flexibility to use a custom cache. \n\nI'll come up with a basic cache API definition and share shortly.",
            "date": "2010-02-18T16:28:59.608+0000",
            "id": 6
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "> For your #3, shouldn't caching be tightly coupled with HttpClient rather than being implemented as a decorator?\n\nI am pretty sure it should not. Moreover, I think a good caching implementation should require no changes in the DefaultHttpClient at all.\n\nOleg",
            "date": "2010-02-18T19:15:46.822+0000",
            "id": 7
        },
        {
            "author": "Jonathan Moore",
            "body": "Hi folks,\n\nWe had a group of engineers work on a CachingHttpClient as a \"lab week\" project last week, following (as it turns out) the same decorator pattern Oleg outlined. We've also developed a pluggable cache storage interface and have in-memory (basically a LRU HashMap), ehcache, and memcache backends. We're not quite standards-compliant yet, but hopefully will be soon.\n\nCurrently this builds as a separate JAR with all the classes under org.apache.http.client.cache as a new package (the adapters for the ehcache and memcache backends are also separate JARs so you can just include the dependencies you need).\n\nWe'd like to contribute this back to the community; are there any particulars about the best way to do this?\n\nThanks,\nJon Moore\nComcast Interactive Media\n",
            "date": "2010-03-29T18:47:42.888+0000",
            "id": 8
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Jon,\n\nSimply attach the source (preferably in a form of a patch) to this issue and do not forget to select 'Grant license to ASF for inclusion in ASF works'.\n\nOleg",
            "date": "2010-03-29T19:07:10.295+0000",
            "id": 9
        },
        {
            "author": "Jonathan Moore",
            "body": "Ok, great. It may take us a week or two to get it all tied up, but shouldn't be a problem.\n\nJon\n",
            "date": "2010-03-29T20:47:05.984+0000",
            "id": 10
        },
        {
            "author": "Jonathan Moore",
            "body": "We're taking the approach of trying to be a conditionally-compliant (meaning, we implement all the MUSTs and MUST NOTs in the RFC) HTTP/1.1 transparent proxy cache, even though technically the CachingHttpClient decorator isn't a full proxy (since it doesn't actually talk HTTP with its upstream client; we use the HttpClient API). In general, we feel like this will maximize interoperability but could lead to some surprising behavior.\n\nOne example requirement of the RFC is: \"Clients MAY issue simple (non-subrange) GET requests with either weak validators or strong validators. Clients MUST NOT use weak validators in other forms of request.\"\n\nLet's say the client program issues a request like this:\n\nPUT / HTTP/1.1\nHost: foo.example.com\nContent-Length: 6\nContent-Type: text/plain\nIf-Match: W/\"etag\"\n\nstuff\n\nIf I were a compliant, standalone proxy, I would not be allowed to send this request downstream per the RFC, and would probably return a 400 (Bad Request). Now, the CachingHttpClient could likewise construct a 400 response and hand it right back, but this might be surprising to a client who had previously been interacting with a non-compliant origin that allowed this, in which case the CachingHttpClient wouldn't really be a drop-in replacement.\n\nIs there some community opinion on how to behave in cases like this? Is subjecting ourselves to the rigors of requirements on proxies too much? Should this type of behavior be configurable?\n",
            "date": "2010-04-07T14:37:01.736+0000",
            "id": 11
        },
        {
            "author": "Ortwin Gl\u00fcck",
            "body": "Jon, I like your approach. \n\nIf you don't know what to do with a request, the best thing you can do is to pass it on verbatim to the server, as would do the client without a cache. The server will know the answer. If you can't decide whether it's correct to cache the response or not, then don't. Better make an extra request to the server than deliver stale or incorrect data (especially with WebDav you can easily loose data).\n\nMy opinion on the case in question: The correct behaviour of a compliant server is undefined, especially no meaning must be implied to the returned status code or headers. Trying to be as transparent as possible should be the way to go here (trying not to break anything). So pass on the request verbatim to the destination and remove the resource from the cache, as you can't know what the server will do.\n\n",
            "date": "2010-04-07T14:59:35.787+0000",
            "id": 12
        },
        {
            "author": "Jonathan Moore",
            "body": "Just wanted to touch base here on progress, to keep the thread alive. We've got basic functionality working, and are working our way through the RFC to create unit tests around all the MUST/MUST NOT protocol requirements. In the meantime, here's a couple more behavior questions:\n\nOptions and Max-Forwards: in theory, if a proxy receives an OPTIONS request with a Max-Fowards: 0, it is not supposed to forward the request and instead should consider the OPTIONS request to be directed to it directly. Should the CachingHttpClient consider itself a proxy in this sense (i.e. count itself as a hop in the request/response chain)? Again, this is the \"am I just part of the client or am I a proxy\" question.\n\nVia header: probably related in spirit. Should the CachingHttpClient add Via headers as a proxy? i.e.\n\nVia: 1.0 localhost (CachingHttpClient/4.0.1)\n",
            "date": "2010-04-13T13:20:40.635+0000",
            "id": 13
        },
        {
            "author": "Ortwin Gl\u00fcck",
            "body": "Jon,\n\nYou are *not* implementing a proxy! Only a cache. A proxy is an intermediate server that the client is fully aware of. The client uses the CONNECT method and proxy-specific headers to interact with a proxy. A cache however is fully transparent to the client. The client has no knowledge about the proxy. No Via headers. No Max-Forwards interpretation. A cache only interacts with the headers that control lifetime of the cached object. Apart from that it just replays responses to the client. That implies that you have to store also the original headers and not just the request body. In my opinion the cache should even issue the original Date and Server headers back to the client and not generate new ones.",
            "date": "2010-04-13T13:38:35.123+0000",
            "id": 14
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "+1 to what Odi said.\n\nBTW, I intend to start working on the 4.1-a2 release in a few days. If you think your code is ready for testing by a larger community of users I could hold back the release for a week or so.\n\nOleg",
            "date": "2010-04-13T13:56:25.228+0000",
            "id": 15
        },
        {
            "author": "Jonathan Moore",
            "body": "Ok, I think we have something ready to be poked at by a larger community. We're getting the signoff from the legal team (shouldn't be a problem), and it should be pretty easy to produce the patch from what we have going in our internal repository. Let us know what your release deadline would be and we'll try to hit it.",
            "date": "2010-04-15T04:26:41.191+0000",
            "id": 16
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "There is no deadline, but due to personal circumstances I would like to get the next release out within the next two weeks.\n\nOleg",
            "date": "2010-04-15T09:39:52.167+0000",
            "id": 17
        },
        {
            "author": "David Mays",
            "body": "Hi, I'm working with Jonathan on the caching client. Am I correct in assuming that I should create the patch against the 4.1-alpha1 tag in SVN? ",
            "date": "2010-04-16T13:54:33.970+0000",
            "id": 18
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Usually one should always be using trunk when submitting new features\n\nhttp://svn.apache.org/repos/asf/httpcomponents/httpclient/trunk/\n\nIn this particular case it should not really matter, though, as the code should be self-contained and should not require any changes to the existing classes.\n\nEither a patch or a bunch of ZIPPED classes should do just fine.\n\nOleg\n",
            "date": "2010-04-16T14:03:23.622+0000",
            "id": 19
        },
        {
            "author": "David Mays",
            "body": "Oleg,\n\nI've sent you a tgz of the source code for the caching client. Let me know if you need anything or have any questions.\n\nThanks,\n\nDave",
            "date": "2010-04-22T13:04:38.620+0000",
            "id": 20
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Hhhm. I guess you did not get my response to your message for some reason. I simply cannot commit code sent to me directly. You MUST attach the patch to this issue and clearly state that the code is granted to the ASF (Apache Software Foundation) under the terms of ASL (Apache Software License) and that you are acting with a consent of your employer. \n\nOleg ",
            "date": "2010-04-22T13:24:50.689+0000",
            "id": 21
        },
        {
            "author": "David Mays",
            "body": "This patch is being submitted by David Mays on behalf of Comcast Corporation. I am acting with the consent of my employer. \n\nIt is intended for redistribution and is granted to the Apache Software Foundation under the terms of the Apache Software License.\n\nContributors to this patch:\nJoe Campbell\nDavid Cleaver\nDavid Mays\nJon Moore\nBrad Spenla\n",
            "date": "2010-04-22T14:15:11.741+0000",
            "id": 22
        },
        {
            "author": "David Mays",
            "body": "You are correct. I did not receive your message. However you should now be able to see the attachment I have just uploaded.\n\nDave",
            "date": "2010-04-22T14:16:56.543+0000",
            "id": 23
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "I will review and commit the patch either today or tomorrow.\n\nOleg",
            "date": "2010-04-22T14:26:23.128+0000",
            "id": 24
        },
        {
            "author": "David Mays",
            "body": "Oleg,\n\nWe discovered that something seems to be fatally broken right now, in the sense that it is not caching anything. Please hold off integrating this for now. My apologies for the false start.\n\nI'll get back to you about it on Monday. It's likely a very small bug, since we did at one time have certainty that it WAS working correctly.\n\nThanks,\n\nDave",
            "date": "2010-04-23T21:35:57.406+0000",
            "id": 25
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Dave,\n\nNo worries. Even if it is broken it might be better if I check in the code sooner than later, so others could start reviewing the API. However, it looks like I will have to migrate HttpClient from JUnit 3 to JUnit 4 before your code could be committed.\n\nAnother thing. I'd be really great if you could contribute a short section on the caching extension to the HttpClient tutorial.\n\nCheers\n\nOleg",
            "date": "2010-04-24T08:53:51.740+0000",
            "id": 26
        },
        {
            "author": "Sebb",
            "body": "JUnit4 is backwards compatible with JUnit3, and HttpClient requires Java 1.5+ so the dependency for HttpClient could just be changed to 4.8.1. (4.8.2 has been released, but is not yet in Maven or on SourceForge)\n\nIt's probably not a good idea to mix JUnit3 and 4 syntax in the same class, however ;-)",
            "date": "2010-04-24T16:33:10.277+0000",
            "id": 27
        },
        {
            "author": "David Mays",
            "body": "Oops. I didn't even consider the JUnit version issue when submitting this.\n\nI believe we'll be ready with a non-broken submission later today. One of our guys spent some time this weekend fixing that, as well as making some other new unit tests pass. He's down to the last failing test, so I think we're in good shape.\n\nHow do I go about contributing to the tutorial?",
            "date": "2010-04-26T13:44:25.674+0000",
            "id": 28
        },
        {
            "author": "David Mays",
            "body": "This file supercedes my previous submission of cachingclient.tgz. This one actually works, and has more passing tests.\n\nI am submitting this and granting the software to the ASF, under the terms of the ASL, with full consent of my employer, Comcast Corporation.\n",
            "date": "2010-04-26T19:06:31.764+0000",
            "id": 29
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "> How do I go about contributing to the tutorial?\n\nIdeally, by submitting a patch. The latest tutorial snapshot in the DocBook format can be found here:\n\nhttp://svn.apache.org/repos/asf/httpcomponents/httpclient/trunk/src/docbkx/\n\nI took a _very_ cursory look at the code. Overall, great stuff. Some minor remarks:\n\n(1) I spotted quite a few instance variables that could be made final. Final variables make code somewhat less prone to race conditions and generally make it easier to ensure thread-safety when accessed by multiple threads.\n\n(2) Static Logs are considered harmful in managed environments such as JEE containers. HttpClient uses non-static Log instances as recommended by the developers of Commons Logging. Cache should be consistent with the rest of the code base.\n\n(3) I see lots of places where CacheOperationExceptions are silently discarded. Each particular case should be reviewed and the exception should either be propagated, handled or logged. Exceptions should be ignored in very special cases only. In most cases logging at DEBUG or WARN priority is all that it takes. \n\n(4) Ideally CacheEntry class should not impose a particular physical representation of the cache entry content (for instance, as a byte array). We might also want to provide a file system based cache implementation, which ideally should function without buffering the entire response content in memory. I kind of think CacheEntry might even use HttpEntity interface for content representation.\n\nThere are two ways we could proceed. (1) I can commit the patch pretty much as is and let you work on improvements incrementally by submitting smaller patches, or (2) you can resubmit the whole thing if that is easier for you. \n\nCheers\n\nOleg ",
            "date": "2010-04-27T14:49:08.391+0000",
            "id": 30
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "David,\n\nI started messing with your code. You probably should not make any major changes in your local code tree until the code is committed to the repository.\n\nOleg",
            "date": "2010-04-28T18:05:59.028+0000",
            "id": 31
        },
        {
            "author": "David Mays",
            "body": "Oleg,\n\nThanks for letting me know! I was actually planning to suggest this morning that you go ahead and commit the code if you are ready, so that I can check out the trunk and work on the suggestions you had.\n\nIf you're not ready to commit it to the trunk yet, that is fine also; I can put off any local modifications for a while.\n\nThanks,\n\nDave\n",
            "date": "2010-04-29T13:49:24.283+0000",
            "id": 32
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Dave,\n\nMy wife just gave birth to our first child. Things are a bit hectic right now. I'll try to commit the code tomorrow.\n\nOleg",
            "date": "2010-04-29T19:48:26.038+0000",
            "id": 33
        },
        {
            "author": "David Mays",
            "body": "Oleg, \n\nThat's outstanding! Congratulations on the addition to your family.\n\nI certainly understand if it isn't committed very soon.\n\nDave",
            "date": "2010-04-29T20:33:43.002+0000",
            "id": 34
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Dave,\n\nPlease find a slightly reworked version of your code attached to the issue. I took liberty of making a number of changes in order to make the code more consistent with the rest of HttpClient. I started splitting the code into API and impl parts and generified some public interfaces. I also converted all test cases to JUnit 4 (by the way the test coverage in truly impressive).\n\nIf I hear no objections, I'll commit the code tonight (~20:00 GMT)\n\nOleg",
            "date": "2010-04-30T09:26:02.905+0000",
            "id": 35
        },
        {
            "author": "David Mays",
            "body": "Oleg,\n\nSounds good. I like the direction you're going, separating it into Impl and interfaces. \n\nThanks,\n\nDave",
            "date": "2010-04-30T14:29:26.152+0000",
            "id": 36
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Dave,\n\nModule checked in. Many thanks you all you, guys, for contributing it!\n\nI forgot to mention another minor issue. One of the tests TestCachingHttpClient#testRealResultsMatch depends on an external resource. If possible, consider replacing it with a mock service based on LocalTestServer. You can use TestRedirects test cases as a starting point.\n\nhttp://svn.apache.org/repos/asf/httpcomponents/httpclient/trunk/httpclient/src/test/java/org/apache/http/client/protocol/TestRedirects.java\nhttp://svn.apache.org/repos/asf/httpcomponents/httpclient/trunk/httpclient/src/test/java/org/apache/http/localserver/LocalTestServer.java\n\nAs soon as the issues I mentioned previously have been looked into, I'll proceed with cutting an official release\n\nCheers\n\nOleg\n\n",
            "date": "2010-04-30T21:13:34.408+0000",
            "id": 37
        },
        {
            "author": "Sebb",
            "body": "The volatile long count fields in CachingHttpClient are not guaranteed to be updated correctly by multiple threads.\n\nThis is because:\n* increment is not atomic\n* long read/write are not guaranteed atomic (though they probably are on most modern hardware)\n\nThe first could cause lost updates, the second could cause rubbish values to be stored.\n\nCould either use AtomicLong, or could synchronize updates.",
            "date": "2010-04-30T23:38:56.470+0000",
            "id": 38
        },
        {
            "author": "Sebb",
            "body": "I think one or two classes are not currently thread-safe:\n\nCacheEntry\nCachingHttpClient (only the counts are a possible problem)\nOptionsHttp11Response - not sure why the instance fields are not final & private?\nSizeLimitedResponseReader\n\nAre these classes intended to be shared between threads?",
            "date": "2010-05-01T00:03:28.758+0000",
            "id": 39
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "I think all these classes need to be thread-safe, as the cache may be accessed from multiple worker threads concurrently.\n\nOleg ",
            "date": "2010-05-01T10:08:02.608+0000",
            "id": 40
        },
        {
            "author": "David Mays",
            "body": "For the SizeLimitedResponseReader and OptionsHttp11Response, these are \"new\" for every request, and so should not be accessed by multiple threads unless someone was doing something very unusual in their client code.\n\nThe counters in CachingHttpClient are being updated to AtomicLong.\n\nThe tricky bit is the CacheEntry.\n\nI'm thinking that the atomicity there should be in the updates to the cache, rather than the entry itself. We already have this notion with the HttpCacheUpdateCallback, which enables atomic updates to the cache. The key is preventing existing instances of a CacheEntry from being updated while someone is reading one. I believe we have a handle on how to make this happen, so we are working on it now.\n\nWhat do you consider the top priority items to complete before you consider this ready for release? Specifically, is the CacheEntry physical representation something you consider gating for release, or can that go as-is for now?\n\nDave",
            "date": "2010-05-03T18:23:11.292+0000",
            "id": 41
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Dave,\n\nOnly threading issue is a show stopper. All others can be addressed at a later point and should not block the release. \n\nIn my opinion the best way to ensure CacheEntity thread safety is by making it immutable. Basically instead of updating an exiting entry the cache should replace an existing entry with a new one thus making synchronisation on that entity unnecessary. This solves threading issue without decreasing performance.   \n\nI already have started working on a patch but was unable to fix 5 test cases that currently fail. I will do my best to finish my changes tomorrow and pass it onto you for review. \n\nI have stumbled upon one particular bit which I cannot fully understand without your help. What is the intent of variantURIs set? I could not figure out just by looking at the test cases.  \n\nOleg",
            "date": "2010-05-03T19:42:21.405+0000",
            "id": 42
        },
        {
            "author": "David Mays",
            "body": "The idea behind Variant URIs is that for a resource that has Vary response headers, we store a \"parent\" cache entry, which has pointers (variant URIs) to \"child\" entries. The child entries will contain the \"variable\" content for that resource. So the parent entry becomes the map to find a given child entry, where the URI (cache key) has had a string like {Content-Encoding:gzip} prepended to it\n\nSo you might have a parent entry like this:\n\n\"http://www.example.com/foo\"\n\nWith children like these:\n\n\"{Content-Encoding:gzip}http://www.example.com/foo\" (Caused by a request that had Accept-Encoding:gzip header)\n\"{Content-Encoding:identity}http://www.example.com/foo\" (Caused by a request that had Accept-Encoding:identity header)\n\nThe idea of keeping the list of variant children with the parent entry is so that we can clean up all child entries when a parent is invalidated. It prevents orphan cache entries.\n\nRegarding the atomic updates, we had also started working on a patch for that, where CacheEntry had a new constructor that took everything you need, instead of the HttpResponse. Obviously all the other setters were to be removed also. This way, every time a cache entry is \"pulled\" from the cache, it is effectively a copy, rather than a reference.\n\nThe CacheEntryUpdater class would have to be changed slightly to work with this, but would not be especially difficult to do.\n\nDave\n",
            "date": "2010-05-03T20:02:48.401+0000",
            "id": 43
        },
        {
            "author": "Sebb",
            "body": "For OptionsHttp11Response - is there any need for the instance variables statusLine and version to be mutable? Can they be made private?\nI know fixing this is not strictly necessary, but then again is it necessary for the fields to be mutable and not private?\n\nIt's a lot better to start with all fields private - and final if possible - and only increase the visibility if strictly necessary.",
            "date": "2010-05-04T01:55:46.303+0000",
            "id": 44
        },
        {
            "author": "Joe Campbell",
            "body": "Yes - they can be made private and final - as they are never meant to change.  In fact, I added the @Immutable annotation to the class (similar to other classes assumed to have been modified by Oleg).  OptionsHttp11Response's purpose is to serve as the response container for a request OPTIONS query with maxforwards set to 0 (essentially a loopback to indicate all the various things that the cache will support).  \n\nThis change will be included in a patch from us when Oleg is complete with making CacheEntry immutable as well.  We are trying not to collide changes by pausing to wait for Oleg's changes on the tree and then supplying a patch for some of the other minor changes requested based on that.\n\nThanks,\n     Joe  \n\n",
            "date": "2010-05-04T12:34:43.504+0000",
            "id": 45
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Dave, Joe\n\nI could not fully complete the changes that I had in mind. So far I managed to have made all variables in the CacheEntry class final which helps a great deal to ensure thread safety of the class, but I was unable to make it truly immutable. Variant URIs can still be mutated by multiple threads leading to a race condition. I have also failed miserably trying to wrap my head around EasyMock which turned out to be far from easy. One of the test cases still fails after my changes and I was not able to fix it nor to fully understand why it is failing in the first place. I think it is better if you take over from here and incorporate the patch (attached) into your change set.\n\nCheers\n\nOleg",
            "date": "2010-05-04T12:54:30.552+0000",
            "id": 46
        },
        {
            "author": "Joe Campbell",
            "body": "Thanks Oleg.\n\nI think that Dave was heading down the very same path that you were (attempting to make CacheEntry immutable).  We'll take a look at your patch and incorporate as needed.  I don't want to speak for Dave (as he was the one making the change) but we should have a patch in the next day, TWO at the most.\n\nAlso if you have specific questions about EasyMock - don't hesitate to send a direct email to Dave or myself.  Happy to help the learning and information dissemination of a wonderful framework for mocking.  8-)\n\nThanks,\n    Joe",
            "date": "2010-05-04T13:20:14.135+0000",
            "id": 47
        },
        {
            "author": "David Mays",
            "body": "This patch correctly makes CacheEntry immutable, and fixes all the unit tests that broke based on this change.",
            "date": "2010-05-06T12:55:40.444+0000",
            "id": 48
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Patch checked in. Many thanks, David\n\nAs far as I can tell all major issues have been addressed. I'll start cutting preview packages sometime this weekend.\n\nOleg",
            "date": "2010-05-06T20:11:48.166+0000",
            "id": 49
        },
        {
            "author": "Sebb",
            "body": "I think there is still a minor issue with the CacheEntry class.\n\nIt contains the field:\n\nprivate final byte[] body;\n\nHowever, this is exposed by both the constructor and getBody(), neither of which copy the array.\n\nAs it stands, the class is not @Immutable, because the body array can be changed externally.\n\nSimplest solution is to copy the array.\n\nAlso, the CacheInvalidator class is definitely not @Immutable, because the cache can be upated.\nIt is @ThreadSafe, so long as the cache implementation is @ThreadSafe\n\nThe AtomicLong fields in CachingHttpClient don't need to be volatile; also I think the class is now @ThreadSafe, so long as the responseCache is.\n",
            "date": "2010-05-06T20:36:48.909+0000",
            "id": 50
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Sebastian,\n\nI would like that byte array be eventually replaced with a more complex object similar to HttpEntity. While CacheEntity is not truly immutable, it is thread safe now. This is good enough for the first cut and should not be a release blocker. Feel free to remove @Immutable annotations which you find inappropriate.  Please just go ahead and make whatever changes you deem necessary to close the issue and proceed with the release.\n\nOleg",
            "date": "2010-05-06T21:14:10.680+0000",
            "id": 51
        },
        {
            "author": "Sebb",
            "body": "CacheEntity is not inherently thread-safe, because external classes can affect the byte array in non-threadsafe manner.\nIt is only threadsafe if the external classes behave themselves.\nHowever, cloning the body array means that the class is now @Immutable.\n\nOther issues also fixed.",
            "date": "2010-05-06T21:47:08.536+0000",
            "id": 52
        },
        {
            "author": "Joe Campbell",
            "body": "Sebastian,\n     The volatile keyword effects the multi-thread visibility of the value located in the AtomicLong.  To be appropriate, the volatile keyword should remain.  From the util.concurrent java doc:\n\n\"In essence, the classes in this package extend the notion of volatile values, fields, and array elements to those that also provide an atomic conditional update operation of the form...\"\n\nvolatility and atomicity are not the same by this notation, would you be ok with putting that keyword back?\n\nAlso - I am curious about the @Immutable annotation in reference to the CacheInvalidator... by your definition CacheInvalidator is not immutable because a member variable of the invalidator can change internally (meaning things can be added and removed from the cache) - I am unclear though why this 'cache' mutability effects the mutability of the Invalidator class.  Once the Cache is set on the CacheInvalidator it can only be changed if the cache is reconstructed/replaced (i.e. a new instance of the CacheInvalidator is needed to change the cache it uses).  \n\nThanks,\n    Joe",
            "date": "2010-05-07T00:43:24.105+0000",
            "id": 53
        },
        {
            "author": "Sebb",
            "body": "@Joe: \n\nFrom the Javadoc for java.util.concurrent.atomic:\n\n#  get has the memory effects of reading a volatile variable.\n# set has the memory effects of writing (assigning) a volatile variable. \n\nThe way I read that, there is no need to use volatile. \nIf there were, then AtomicLong would not be thread-safe.\n\nI already changed CacheInvalidator to @ThreadSafe rather than @Immutable.",
            "date": "2010-05-07T10:25:53.145+0000",
            "id": 54
        },
        {
            "author": "Sam Berlin",
            "body": "One statement, one question:\n\n1) Without looking at the code involved, the AtomicLong variable would only need to be volatile if the variable itself were being assigned to a new AtomicLong in one thread and used in another.  If the AtomicLong object is created & assigned in one place (preferably the constructor, allowing the object to be final), then calling 'set' or 'get' on it is effectively the same as calling get or set on a volatile long.  If you say 'new AtomicLong' somewhere other than the constructor, something is probably wrong with the code.\n\n2) Re: the byte[].clone() that sebb added.  Again I haven't looked too deeply at the code (just the diffs), but is that the byte[] of the body of a cached response?  If so, that could potentially be very large.  Cloning it could lead to memory crunches.  Is it possible to change the objects involved to ByteBuffers & convert it using asReadOnly?  Additionally, if it is a byte[] of the body of cached response... I'm concerned that larger responses (ie, downloading a large file) wouldn't even be able to be stored in memory.  Does the API allow for reading the data from an InputStream (or Channel?).  (If that byte[] is not for the body of cached responses, you can ignore this question.)",
            "date": "2010-05-07T13:02:27.754+0000",
            "id": 55
        },
        {
            "author": "Jonathan Moore",
            "body": "@Sam:\n\nThe byte[] is indeed the cached response body, and I would agree with Seb that as-is, it's not threadsafe because someone can muck with the bytearray. I think clone() on the byte array solves this, but at the expense of extra copies of the data. The Right Way is probably going down the road that Oleg suggests, which is to use something like HttpEntity instead which can be treated as immutable.\n\nWith regard to the potential size of the response, the CachingHttpClient lets you specify a max object size (with a heuristic default behavior that I'd have to recheck in the code); if the CachingHttpClient encounters a response that exceeds this, it won't try to cache it and will just stream the result through (it will optimistically consume some of the input stream, in case there is a chunked-encoding response that will fit, but if this process exceeds the max length then it will return a response with a \"composite\" input stream that returns the byte array read so far, then \"appends\" the rest of the unconsumed origin response stream.\n",
            "date": "2010-05-07T13:25:36.191+0000",
            "id": 56
        },
        {
            "author": "Jonathan Moore",
            "body": "Please find attached a patch that adds some more acceptance tests to TestProtocolRequirements, as gleaned from Section 13 of RFC 2616, in terms of MUST and MUST NOT requirements. Existing code already passed these, so this is a net addition of passing unit tests.\n\nThis contribution is made with the consent of my employer, Comcast Interactive Media, and license is granted to the ASF for inclusion in ASF works.\n\n",
            "date": "2010-05-07T13:34:45.987+0000",
            "id": 57
        },
        {
            "author": "Joe Campbell",
            "body": "@Sam:\n\nRE #1) Thank you for the more in depth explanation of volatile keywords use in this case.  This clarified the use of the keyword for me quite a bit and has made my understanding of what that keyword 'really' does in code more precise.  \n\nRE #2) I think Jon covered that explanation.  I think all here (that have worked on the Caching client) agree that we would like to head down the path that Oleg suggested - but we don't want that work to gate getting the 'working foundation' of this code checked in and released.  We are happy to continue to work with the group to make suggested changes to improve and strengthen this code base contribution.\n\nThanks,\n     Joe",
            "date": "2010-05-07T14:08:28.356+0000",
            "id": 58
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "@Jonathan\n\nMany thanks for contributing the patch. Committed to SVN trunk\n\n@all\n\nI think things are in a shape good enough for an ALPHA release. \n\nI raised a new JIRA for the cache entry representation issue, see HTTPCLIENT-937.\n\n@Jonathan, Joe and Dave\n\nA short tutorial section about caching support would make things absolutely perfect \n\nOleg",
            "date": "2010-05-07T14:28:53.870+0000",
            "id": 59
        },
        {
            "author": "David Mays",
            "body": "I'm working on an additional chapter for the documentation, titled \"HTTP Caching\" which will include general background on the caching code, its effort at being compliant with the caching requirements in RFC-2616 and a trivial example of how one might configure it.\n\nI should be ready to send a patch with that sometime today.\n\nDave",
            "date": "2010-05-07T17:42:19.453+0000",
            "id": 60
        },
        {
            "author": "David Mays",
            "body": "Attached is a patch that contains a new docbook chapter about the Caching Client.\n\nLet me know if you would like it to be more or less than it is, or modify as you see fit.\n\nDave",
            "date": "2010-05-07T20:17:28.104+0000",
            "id": 61
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "I think it is about right. Patch checked in. Many thanks, Dave\n\nOleg",
            "date": "2010-05-08T09:24:04.828+0000",
            "id": 62
        }
    ],
    "component": "HttpClient (classic)",
    "description": "Browsers may cache received content according to the values of different\nresponse headers. It would be great if HttpClient could do the same.",
    "hasPatch": true,
    "hasScreenshot": false,
    "id": "HTTPCLIENT-427",
    "issuetypeClassified": "RFE",
    "issuetypeTracker": "IMPROVEMENT",
    "priority": "Major",
    "product": "HTTPCLIENT",
    "project": "HTTPCLIENT",
    "summary": "Implement a cache to perform real request only when needed",
    "systemSpecification": true,
    "version": ""
}