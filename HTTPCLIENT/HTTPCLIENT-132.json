{
    "comments": [
        {
            "author": "Ortwin Gl\u00fcck",
            "body": "Obviously this Bugzilla is not configured to allow dependencies. So just add\ncomments with the bug numbers:\n\n#8288\n#10790\n#10791\n#10793\n#10797\n",
            "date": "2002-12-17T19:23:33.000+0000",
            "id": 0
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "I have new preference architecure almost ready. I'll submit the first revision \nof the patch as soon as I get back from Croatia.\n\nIt turned out to be much more difficult than I initally though. At least three \nattempts to come up with acceptable solution bogged down. But the 4th one \nlooks promising. \n\nOleg.",
            "date": "2003-08-30T21:43:32.000+0000",
            "id": 1
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "See my comments above",
            "date": "2003-08-30T21:48:15.000+0000",
            "id": 2
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Created an attachment (id=8053)\nPatch (take 1)\n",
            "date": "2003-09-04T04:15:49.000+0000",
            "id": 3
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Important points:\n\n- collections of HTTP parameters may be linked together to form a hierarchy\n- Parameters can be set at the global level, Http client level or Http method level\n- If a parameter is not defined at the current level, its value is drawn from a\nhigher levels of the hierarchy at which the parameter is defined\n- If parameter is not defined at the current level or any level above, a default\nvalue is returned\n- Some parameters are not applicable at the Http method level ",
            "date": "2003-09-04T04:17:45.000+0000",
            "id": 4
        },
        {
            "author": "Michael Becke",
            "body": "Hi Oleg,\n\nI like it.  Overall the design is quite good.  I have number of ideas/questions which I will \nelaborate on below.\n\nHigh level stuff:\n\n - How should we handle the storage of more complicated configuration options, like the date \nformats used in DateParser?  This is definitely something that I think should be able to \nconfigure, in the default case at least.  Another item that has been brought up is the ability to \ndefine a set of default headers to be applied to all methods.  Here a couple of ideas off the top \nof my head:\n\n# 1 - delimit values\nhttp.dateFormats=EEE, dd-MMM-yyyy HH:mm:ss z<SOME_DELIM>EEE dd-MMM-yyyy HH-mm-\nss z\n\n# 2 - indirection\nhttp.dateFormats=format1, format2\nformat1=EEE, dd-MMM-yyyy HH:mm:ss z\nformat2=EEE dd-MMM-yyyy HH-mm-ss z\n\nThe first choice is the easiest but has the delimiter choice problem.  The second choice is more \nexact but requires more work and is a little less obvious.  I think the solution here will depend \nsomewhat on the answer to the next question.\n\n\n - Is there a need for both specific configuration params like getConnectionManagerTimeout() \nand generic ones like getParameter(String)?  I feel like we should have custom methods for all \nconfiguration values, or all generic ones with support for type specific params like \ngetLongValue(String), but not both.  I am leaning more toward all specific configuration \nmethods.  This configuration system is only meant to support HttpClient.  It should not need to \nbe generic enough to be usable for other purposes.\n\n\nImplementation details (perhaps too soon for this):\n\n - I think HttpParams.load() should use a PropertyResourceBundle to load/parse the \nconfiguration.  It avoids implementing the nasty details and provides support for splitting lines \nwith \"\\\", among other things.\n\n - I think we probably want a HttpMethodBase.setParams() or something of the sort.\n\nWhat do you think?\n\nMike\n\n\n",
            "date": "2003-09-04T09:09:38.000+0000",
            "id": 5
        },
        {
            "author": "Ortwin Gl\u00fcck",
            "body": "A comment about classloaders to finde the properties file. We must be very\ncareful about this and be as much compatible with other components i.e. handle\nit the same way. I am not 100% sure but I think the 'most common' procedure is a\nfollows:\n\n1. Try the current thread's context ClassLoader (if not null) and look for the\nproperties file\n2. Try the ClassLoader that loaded the class and look for the properties file\n3. Use the Jar file service provider mechanism (see\nhttp://java.sun.com/j2se/1.3/docs/guide/jar/jar.html)\n\nWe must check other projects like Xerces, JCE how they handle ClassLoaders.",
            "date": "2003-09-04T14:35:41.000+0000",
            "id": 6
        },
        {
            "author": "Michael Becke",
            "body": "I thought about this quite a bit more last night as I was going to sleep and I have changed my \nmind, particularly in regard to specific vs. generic configuration.  My feeling now is that \nHttpParams should be a source for generic configuration and that specific configuration should be \nhandled by the specific users of the values.  For example HttpParams would have methods like:\n\n    String getParam(String key)\n    long getLongParam(String key)\n\nand default options like:\n\n    String getParam(String key, String default)\n    long getLongParam(String key, long default)\n\nThen classes like HttpVersion or HttpMethodBase would have the specifics like:\n\n    public static final String PARAM_PROTOCOL_VERSION = \"http.protocol.version\"\n\nand\n\n    public static void setHttpVersion(HttpVersion version, HttpParams params)\n\nAgain, these are just some ideas.  I like this separation of things better though.  This allows \nHttpParams to be flexible enough to handle various kinds of configuration, and pushes the \nspecifics to the classes that care about them.\n\nWhat do you think?\n\nMike",
            "date": "2003-09-04T19:28:58.000+0000",
            "id": 7
        },
        {
            "author": "Adrian Sutton",
            "body": "In response to Ortwin's comments (I haven't had a chance to look into the patch yet), if you are \ntrying to load arbitrary things from the classpath you create a major problem and for applets since \nthose attempts translate into requests back to the original server which may include popping up \nauthentication dialogs to the user etc.  I'm not sure why HttpClient needs a way to be configured \nby a dynamically located properties file, since it is always used through it's programmatic API \nanyway.  It seems to me that just passing in a properties file (or some other configuration object) \nto the HttpClient constructor would do and we could avoid the need to implement and maintain \ncode for automatically locating the properties file.\n\nEither way, it's an absolute must for us to have a way to turn off this autodiscovery.  I'm happy to \nimplement this myself once things settle down if need be though.",
            "date": "2003-09-04T20:07:43.000+0000",
            "id": 8
        },
        {
            "author": "Eric Johnson",
            "body": "Some quick thoughts from here, having scanned the proposed patch only very briefly:\n\n* I like the idea of keeping parameters generic.  I use the Slide WebDAV\nextensions, and likely there will be options that make sense to specify for that\nin the future (default encoding of XML requests, for example).  Clients may also\nhave preferences that they associate with HttpClient, but are not necessarily\nused by HttpClient.  By keeping the options generic, extensions like WebDAV, and\nother client wrappers can use the same mechanism for setting their preferences.\nIf you make the settings functions specific, it will be harder over time for the\nlibrary to accommodate new options, and clients will not be able to extend it as\neasily.\n\n* The \"discovery\" process standard could use the approach outlined here:\nhttp://java.sun.com/j2se/1.4.2/docs/api/javax/xml/parsers/SAXParserFactory.html#newInstance()\nwhich is as close to a \"standard\" as Java has for this kind of thing.\n\n* Ortwin has an excellent point, namely that the discovery process should kick\nin only if the caller doesn't provide default information.\n",
            "date": "2003-09-04T20:22:03.000+0000",
            "id": 9
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Folks,\nIt's my first day at work after two weeks of holidays, so things are a bit \nhectic right now. I'll try to respond to every comment made but that may take a \nwhile and a few postings\n\n> # 2 - indirection\n> http.dateFormats=format1, format2\n> format1=EEE, dd-MMM-yyyy HH:mm:ss z\n> format2=EEE dd-MMM-yyyy HH-mm-ss z\n\nThat's the way Sun does it, and it may well be the way most users would expect \nit to work (me for one)\n\n> - Is there a need for both specific configuration params \n> like getConnectionManagerTimeout() and generic ones like getParameter\n(String)?  \n\nNot really. I also agree that ideally two methods should not be mixed up. I \nsense that the majority of respondent favor the generic approach over specific, \nlike I do. I just felt that having to parse some frequently values such as \nprotocol version might be too much of a performance hit. I thought an exception \ncould be made for the most frequently used parameters (maybe just protocol \nversion). However, if we all agree that performance degradation will be offset \nby greater flexibility, I do not mind taking purely generic approach\n\n> - I think HttpParams.load() should use a PropertyResourceBundle to \n> load/parse the  configuration.  It avoids implementing the nasty \n> details and provides support for splitting lines with \"\\\", among\n> other things.\n\nAgreed. \n\n> - I think we probably want a HttpMethodBase.setParams() or something\n> of the sort.\n\nCan do.\n\nOleg",
            "date": "2003-09-04T21:22:30.000+0000",
            "id": 10
        },
        {
            "author": "Roland Weber",
            "body": "I don't like the generic approach so much. It involves defining property names\nwhich introduce typos and requires converting data representations. If you\nknow you need a boolean to indicate whether redirects should be chased or not\n(just to give an example), give it a setter and a getter and let the compiler\ncheck for typos. To me, a generic mechanism is something for \"things we haven't\nthought about\", or \"things we couldn't know about\" in Eric's case. Useful, but\nrather a fallback than a preferred choice.\nUnfortunately, I won't find the time to look at the code in the near future.\nBut is there a way to have base class that provides a generic mechanism and\nto use adapter classes for the individual components? Something like:\n\nHttpParams: generic parameters and conversion methods from and to strings\nHttpClientParams: specific getters and setters for the client's properties,\n  kept in attributes. Constructor and/or readFrom(HttpParams) to initialize\n  the attributes, and saveTo(HttpParams) to write them back.\nHttpMethodParams: like HttpClientParams, just for the HttpMethodBase params\nHttpGetMethodParams: derived from HttpMethodParams, adding some GET-specific\n  attributes.\n...and so on for every component that defines parameters\n\nI know this may create a lot of new classes, but I always was a friend of\nlots of (simple) classes :-)",
            "date": "2003-09-04T21:26:11.000+0000",
            "id": 11
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "> We must be very careful about this and be as much compatible with \n> other components i.e. handle it the same way\n\nOdi, Adrian,\nI think your concerns are well grounded. In order to address them I am going to\nmake sure that \n\n1) configuration file discovery mechanism behaves consistently with the common\npractices outlined in the reference provided by Eric\n2) discovery mechanism kicks in ONLY if no configuration file explicitly\nspecified through a system property \n3) fat, scary warning message is logged if no configuration file is explicitly\ngiven \n\nOleg",
            "date": "2003-09-05T02:36:17.000+0000",
            "id": 12
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "> HttpParams: generic parameters and conversion methods from and to strings\n> HttpClientParams: specific getters and setters for the client's properties,\n>   kept in attributes. Constructor and/or readFrom(HttpParams) to initialize\n>   the attributes, and saveTo(HttpParams) to write them back.\n> HttpMethodParams: like HttpClientParams, just for the HttpMethodBase params\n> HttpGetMethodParams: derived from HttpMethodParams, adding some GET-specific\n>   attributes.\n> ...and so on for every component that defines parameters\n\nRoland, how about this?\n\ninterface HttpGenericParams: implemented by HttpParams\ninterface HttpClientParams: derived from HttpGenericParams, implemented by\nHttpClient\ninterface HttpHttpParams: derived from HttpGenericParams, implemented by\nHttpMethodBase\n\nInterface implementations act as a facade that abstract the intricacies of\nphysical representation and conversion of parameters contained in the associated\nHttpParams instance. All parameters can still be accessed directly through\nHttpGenericParams interface. That would also be a way to interact with\nnon-standard parameters\n\nOleg",
            "date": "2003-09-05T02:51:39.000+0000",
            "id": 13
        },
        {
            "author": "Adrian Sutton",
            "body": "Hi Oleg,\nI've had a chance to look over the patch and it looks like some really good work - well done!\n\nContinuing my applet-focussed view of the world:\n\n>2) discovery mechanism kicks in ONLY if no configuration file explicitly\n>specified through a system property \n\nThis won't help unsigned applets at all and while I don't think HttpClient is particularly useful in \nsuch a context anyway it would be nice to avoid system properties for configuration since that was \none of the goals of the new architecture anyway.  Certainly setting a system property would be a \ngood option, but would it be possible to just create a HttpParams object manually and not use a \nproperties file at all?  I wouldnt' be too worried if such a scheme causes undue problems but it is a \nnice to have feature.\n\nOtherwise I like it, particularly with your latest suggestion for handling Roland's suggestions and \nwith the aid of good documentation supporting it (that I'm happy to add to my todo list).",
            "date": "2003-09-05T08:36:18.000+0000",
            "id": 14
        },
        {
            "author": "Michael Becke",
            "body": "Here is another idea that combines some of what Oleg and Roland are saying, but in a different \nway.  How about something like:\n\ninterface HttpParams with getters and setter for simple types like (String, int, etc.): implemented \nby PropertyHttpParams(the current HttpParams)\n\nclass HttpParamsFactory with factory methods for getting access to instances of HttpParams.\n\nThese classes would handle loading/storing/access for the basics.  For the various specifics like \nHttpVersion we would have static/instance methods like the following:\n\nclass HttpVersion {\n  ...\n\n  public static HttpVersion getHttpVersion(HttpParams params) { ... }\n\n  public static void setHttpVersion(HttpVersion version, HttpParams params) { ... }\n\n  ...\n}\n\nThis setup allows for more flexibility at the base HttpParams level, which I think is important, \nbut doesn't add specific Params classes/interfaces(ClientParams, MethodParams, etc.).  I feel like \nthere is really only going to be one way to go from HttpVersion->String and vice-versa and that \nadding interfaces/abstraction for this is overkill.\n\nSome food for thought, or at least I hope:)\n\nMike",
            "date": "2003-09-05T11:01:27.000+0000",
            "id": 15
        },
        {
            "author": "Roland Weber",
            "body": "Hello Oleg, Mike,\n\nI like the interface approach. Mike, the generic approach with automatic\nconversion for simple data types is fine for simple data types. But for\nsomething like the various date formats, you'd have parsing code at the\nplace where the formats are needed. I would prefer something like\nparams.getDateFormats() that returns a parsed string array, with the\nparsing code offloaded to a different class. Of course, that could also\nbe achieved by using a helper like ParamsParser.getDateFormats(param)\nand a generic parameter store.\nStill, this would *require* a generic data store even in cases where\nconfiguration is done programatically. Folks would have to convert their\ntype-specific parameters they obtained from whereever to the generic\nformat, which would then be converted back by the http client code.\n\nMike, the HttpParamsFactory is an excellent suggestion. I learned from\nmy work on OpenCard that a forced config loading mechanism is a bad idea.\nSooner or later someone is going to create a small footprint version of\nyour code, or use it in a setting you didn't expect originally, and they\nwill want to get rid of whatever well-designed loading mechanism you put\nin, just because they have their own or don't want to specify one.\n\nI would even go so far as to avoid any reference from the run-time classes\nto the configuration classes. So instead of having a default constructor\nfor HttpClient that uses HttpParamsFactory to obtain it's parameters, put\na factory method in the factory to create a configured HttpClient:\n  HttpClient HttpParamsFactory.createConfiguredClient()\nSo folks that want to provide the properties themselves can just drop\nHttpParamsFactory from the package without any impact on the rest of the\nclasses.\n\nIn a customer project, I put all configuration loading and default\ninitialization code into a separate, optional package and was quite\nhappy with that decision.\n",
            "date": "2003-09-05T13:29:17.000+0000",
            "id": 16
        },
        {
            "author": "Ortwin Gl\u00fcck",
            "body": "Oleg, Adrian\n\nI am not convinced that we should really use a configuration FILE at all. This\nwould imply that all HttpClient objects were configured with exactly the same\nparameters (if not customized after instantiation). I think this is of little\n(to no) use. I have rather come to the conclusion that configuration should be\ndone instrinsic. If someone wants a properties / XML file he can always write\nhis own configuration mechanism. We may supply a \"PropertiesFileConfigurator\" in\nthe contrib package. Default values can also be provided in a class.\n\nGeneric parameters vs. getters/setters:\nThis was discussed in earlier approches too. The main argument not to use\ngetters/setters is the sheer (?) number of parameters and future extenstions\nwhile keeping the API small and constant enough. But there are some good\narguments pro getters/setters:\n - compile time (spell-)checking is less error prone\n - you can use reflection (for Digester, O-R persistence etc.)\n - easier to understand and read\n - enforces strong type checking\n\nBut I think we must use a combination of both!\n\nWhy?\nIf I set certain parameters on a high level like HttpClient, it must be able to\npass them down to the Methods it executes. But I don't want getters/setter for\nMethod properties in HttpClient.\n\nHow?\nMake getters/setters in those classes where the parameter is evaluated only.\nThis may be in more than one class (just think of HTTP version) if classes are\nonly loosely coupled.\nHigher level classes like HttpClient must take generic parameters and configure\nthe objects it uses.\nUse a parameter object and not just an interface. This enables us to pass sets\nof parameters along to other classes.\n\nThose are my recommendations. Feel free to criticise them.\n",
            "date": "2003-09-05T15:09:55.000+0000",
            "id": 17
        },
        {
            "author": "Roland Weber",
            "body": "Yet more thoughts on generic vs. specific configuration objects...\nIf you use generic configuration, you will probably look up a property\n(like 'use HTTP 1.1'? or 'follow Redirects') once and then store them\nin an attribute of the object that did the lookup.\nWhen I suggested configuration objects, my idea was to remove these\nattributes from the class that needs to be configured. Instead of using\na local configuration attribute, it accesses the configuration object\nevery time the value is needed. Used that way, type conversion on every\naccess becomes a real penalty.\n\nOrtwin, default configuration objects could be configuration values\nthemselves. Instead of finding a method's configuration parameters\nindividually in the parameters for the HttpClient, you could use a\nsingle setter and getter:\n void setDefaultMethodParams(HttpMethodParams)\n HttpMethodParams getDefaultMethodParams()\n\nThe generic extension mechanism can be a getter and setter for a\nHashMap named 'customParameters' in each parameter class.\n\ncheers,\n  Roland\n",
            "date": "2003-09-05T18:17:36.000+0000",
            "id": 18
        },
        {
            "author": "Ortwin Gl\u00fcck",
            "body": "Parameter classes could be inner classes.\nWhat about considering an existing configuration tool like the Configuration\nproject from the Jakarta Sandbox?\n\nOdi",
            "date": "2003-09-05T19:07:33.000+0000",
            "id": 19
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "All right. We all seem agree to disagree at this time. If do not move on we \nwill get nowhere. I suggest the following: I provide a second draft that will \nattempt to incorporate those ideas that we all more or less in agreement about:\n\n* HttpParam class should at this time be dealing with generic properties only. \nHttpClient & HttpMethod specifics will be later built on top of it. We all yet \nhave to come an agreement as to how exactly it is to be implemented.\n* Configuration file discovery mechanism is inherently evil and should be \nbanished to the contrib package for eternity.  \n\nOleg",
            "date": "2003-09-05T20:19:13.000+0000",
            "id": 20
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Created an attachment (id=8082)\nPatch (take 2)\n",
            "date": "2003-09-06T20:27:20.000+0000",
            "id": 21
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "With property file gone things got surprisingly easier. The new patch should\naddress a lot of concerns expressed above. Please give me your feedback.\n\nOleg",
            "date": "2003-09-06T20:30:24.000+0000",
            "id": 22
        },
        {
            "author": "Michael Becke",
            "body": "Hi Oleg,\n\nI'm glad you decided to take another stab at this.  This version has some definite improvements, \nand I think I can see the light at the end of the tunnel now.  Specifics below:\n\n - Removing the reliance on the properties and string based values was an excellent idea.  This \ngreatly simplifies things and makes the process of loading defaults separate.  Nice.\n\n - To replace the loading of defaults from properties I think we need an HttpParamsFactory.  This \nwould replace the static GLOBAL_DEFAULTS.  HttpParamsFactory would have a plugable mechanism \nfor defining the default params.  Things like the static initializer in HttpMethodParams could be \nmoved there.\n\n - Are isParameterFalse() and isParameterTrue() necessary?  Seems like getBooleanParameter() \nshould be enough :)\n\n - All of the various PROTOCOL_STRICTNESS_PARAMS should be broken out to individual methods I \nthink.\n\n - Once parameters have methods for getting/setting them I do not think the public param Strings \nfor them are required.\n\nAgain, nice work.\n\nMike",
            "date": "2003-09-06T22:32:32.000+0000",
            "id": 23
        },
        {
            "author": "Oleg Kalnichevski",
            "body": " - To replace the loading of defaults from properties I think we need an\nHttpParamsFactory.  This \n> would replace the static GLOBAL_DEFAULTS.  HttpParamsFactory would have a\nplugable mechanism \n> for defining the default params.  Things like the static initializer in\nHttpMethodParams could be \n> moved there.\n\nMike, I just do not see how this can work without resorting to system\nproperties. How are you planning to initialize the factory class? \n\nI think that any properties persistence mechanism can simply feed the\nGLOBAL_DEFAULTS with the values retrieved from a persistent storage. Is class\nfactory pattern really necessary in this particular case. Probably I just can't\nsee an elegant way of implementing it. Give me a gentle push in the right direction.\n\n> \n>  - Are isParameterFalse() and isParameterTrue() necessary?  Seems like\ngetBooleanParameter() \n> should be enough :)\n> \n\nTrue, but I just felt isParameterTrue() & isParameterFalse() required one\nparameter less and were a bit more readable. I do not mind removing them, though.\n\n\n>  - All of the various PROTOCOL_STRICTNESS_PARAMS should be broken out to\nindividual methods I \n> think.\n> \n\nI have to disagree. In my opinion it would create too much clutter. But again,\nif the majority favours this approach, I'll happily oblige.\n\nOleg",
            "date": "2003-09-08T04:44:17.000+0000",
            "id": 24
        },
        {
            "author": "Roland Weber",
            "body": "Hello Oleg,\n\nI'm currently stuck at a customer site and can dial in only occasionally.\nSince I'm unable to browse through the source, could you consider the\nfollowing two use cases?\n\n1. A servlet class is instantiated multiple times with different config,\nbut in the same classloader context. Can different instances of the servlet\ncreate HttpClient instances with different parameters?\n\n2. A framework uses HttpClient and has it's own mechanism for defining\nproperties. How tricky is it to pass the properties - once they are\nloaded - to the Http Client?\n\nLoading the set of default properties should be initiated by the application.\nI don't see a need for an automatic loading mechanism, or automatic selection\nof an HttpParamsFactory. Make it a one-liner to choose a factory and delegate\nthat responsibility to the application (or the framework) that is using the\nHttp Client.\n\ncheers,\n  Roland",
            "date": "2003-09-08T23:11:24.000+0000",
            "id": 25
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "> 1. A servlet class is instantiated multiple times with different config,\n> but in the same classloader context. Can different instances of the servlet\n> create HttpClient instances with different parameters?\n\nOf course! What would my patch be worth otherwise? It is still up to you to \ndecide if you want your HttpClient instances to share the same global defaults. \nOne can simply set HttpClient#getParams#setDefaults(null) to make it disregard \nglobal defaults.\n\n> 2. A framework uses HttpClient and has it's own mechanism for defining\n> properties. How tricky is it to pass the properties - once they are\n> loaded - to the Http Client?\n\nAllow me to try to explain that with the following pseudo-code snippet:\n\n// Select either global HttpParams or HttpClient's params or HttpMethod's params\nHttpParams params = GLOBAL_DEFAULTS // Or \nHttpParams params = httpClient.getParams(); // Or\nHttpParams params = httpMethod.getParams();\n\nwhile (storage.hasMore()) {\n  storageitem = storage.getNext();\n  String paramName = storageitem.getName();\n  Object paramValue = storageitem.getObject();\n  params.setParameter(paramName, paramValue);\n}\n\nThis may look trivial, but at the moment I can't see why we would want \nsomething more complex. I still would like to know, though, what Mike has got \non his mind with the HttpParamsFactory\n\nCheers\n\nOleg",
            "date": "2003-09-08T23:36:39.000+0000",
            "id": 26
        },
        {
            "author": "Michael Becke",
            "body": "Created an attachment (id=8109)\nPatch (HttpParamsFactory)\n",
            "date": "2003-09-09T10:27:50.000+0000",
            "id": 27
        },
        {
            "author": "Michael Becke",
            "body": "The attached patch contains a quick implementation of what I had in mind with regard to a \nHttpParamsFactory.  The main purpose is to consolidate all of the initialization of the HttpParams \nto a single/configurable location.  I see the benefits of this approach as the following:\n\n - Initialization of HttpParams is localized and formalized.  The method for specifying a new \ninitialization routine is clear and easily modifiable.\n - Creation/initialization of the default HttpParams is not necessarily a one time occurrence.  Since \nHttpParamsFactory.getDefaultParams() is called every time the default params are requested, the \ndefaults could be completely static, new for every call, or perhaps created on a per-thread basis.  \nThe choice is up to the implementor.  We would most likely just provide the default static \ninitialization factory.\n\nOverall, I think this approach buys us some nice flexibility with little overhead.  What do you think?\n\nMike\n\n",
            "date": "2003-09-09T10:43:38.000+0000",
            "id": 28
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Mike,\nI like the patch, even though it makes things more complex than absolutely\nnecessary. I agree with you, though, that greater flexibility makes it well\nworth paying the price.\n\nI'll incorporate your changes into the new patch which I intend to submit tomorrow. \n\nOleg",
            "date": "2003-09-10T00:11:17.000+0000",
            "id": 29
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Created an attachment (id=8137)\nPatch (take 4)\n",
            "date": "2003-09-11T03:42:28.000+0000",
            "id": 30
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "The forth revision of the patch incorporates Mike's code with some minor\nvariations. \n\nAs far as I am concerned that looks pretty much like it. What do you think?\n\nOleg",
            "date": "2003-09-11T03:49:26.000+0000",
            "id": 31
        },
        {
            "author": "Michael Becke",
            "body": "I think it's ready to commit.  I'm anxious to get in there and start using it.  The only change I would \nsuggest it to move all of the params classes to a new params package.\n\nMike",
            "date": "2003-09-11T04:12:45.000+0000",
            "id": 32
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Mike, I just could not get Eclipse to create a patch with *HttpParams* classes\nin org.apache.commons.httpclient.params package. I'll move them back before\ncommitting the patch.\n\nIf no objections raised by tomorrow 22:00 GMT, I'll commit the patch.\n\nOleg",
            "date": "2003-09-11T04:22:59.000+0000",
            "id": 33
        },
        {
            "author": "Michael Becke",
            "body": "Sounds good to me.\n\nMike",
            "date": "2003-09-11T04:27:27.000+0000",
            "id": 34
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Patch committed. \n\nI am leaving the bug report open until javadocs for new classes are provided and\nreferences to deprecated methods removed.\n\nOleg",
            "date": "2003-09-12T03:19:40.000+0000",
            "id": 35
        },
        {
            "author": "Michael Becke",
            "body": "Created an attachment (id=8239)\nJavadocs + more configuration items.\n",
            "date": "2003-09-16T09:27:33.000+0000",
            "id": 36
        },
        {
            "author": "Michael Becke",
            "body": "This patch adds some javadocs, makes use the default connection manager config,\nand moves date parser formats to a configuration item.  Please take a look.\n\nMike",
            "date": "2003-09-16T09:29:17.000+0000",
            "id": 37
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Mike,\nThe patch looks good to me. Wouldn't it be better, though, if\njava.util.Collection or java.util.Set were used to store multi-value parameters?\nI suppose in that way multi-value parameter would be easier to deal with.\nImagine if one wanted to add an additional DateFormat to the standard set of\nDateFormats. That would require quite a bit of ugly code with the current\nimplementation, I think.\n\nCheers\n\nOleg",
            "date": "2003-09-18T04:04:55.000+0000",
            "id": 38
        },
        {
            "author": "Michael Becke",
            "body": "Oleg,\n\nI heartily agree.  A collection makes much more sense than an array.  I will make this change and \napply the patch.\n\nMike",
            "date": "2003-09-18T06:04:14.000+0000",
            "id": 39
        },
        {
            "author": "Roland Weber",
            "body": "Hi folks,\n\nmy apologies for taking so long to look into this again. The current\narchitecture is definitely useful, so take these comments as something\nthat might just as well end up on the lower end of some to-do list :-)\nThere are two things I'm not quite happy with:\n\n1. Taking HttpClient as an example, I'm missing a constructor\n   HttpClient(HttpClientParams)\n   I really want a way to instantiate classes without triggering\n   the properties loading mechanism at all. Second best would be a\n   setParams(HttpClientParams), so I can simply copy the params\n   of another client. Ok, the copying idea makes more sense using\n   HttpMethodParams and HttpMethodBase as an example :-)\n\n2. From a design point of view, shouldn't HttpMethodParams better\n   be an attribute than a base class of HttpClientParams?\n   Since that would require parsing properties into different\n   params objects, I don't really think it's worth the effort.\n   I just want to put it up for discussion.\n\ncheers,\n  Roland",
            "date": "2003-09-19T15:36:58.000+0000",
            "id": 40
        },
        {
            "author": "Roland Weber",
            "body": "Having thought about it again, I now realize my misconception in point 2.\nHttpMethodParams and HttpClientParams are rather independent classes.\nShouldn't they both be derived from DefaultHttpParams directly?\n",
            "date": "2003-09-19T17:44:55.000+0000",
            "id": 41
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Hi Roland. Welcome back.\n\n> 1. Taking HttpClient as an example, I'm missing a constructor\n>    HttpClient(HttpClientParams)\n>    I really want a way to instantiate classes without triggering\n>    the properties loading mechanism at all. Second best would be a\n>    setParams(HttpClientParams), so I can simply copy the params\n>    of another client. Ok, the copying idea makes more sense using\n>    HttpMethodParams and HttpMethodBase as an example :-)\n\nAddition of HttpClient#HttpClient(HttpClientParams) sounds reasonable. We might \nneed to make DefaultHttpParams cloneable, which would be a good thing to do \nanyways\n\n> HttpMethodParams and HttpClientParams are rather independent classes.\n> Shouldn't they both be derived from DefaultHttpParams directly?\n\nAny of parameters relevant on the HttpMethod level should also be settable on \nHttpClient level when applicable of a number of methods, IMO. Off course, there \nis no real need for 'extends' relationship between HttpClientParams and \nHttpMethodParams other than for reusing a few methods\n\nOleg",
            "date": "2003-09-19T18:22:43.000+0000",
            "id": 42
        },
        {
            "author": "Roland Weber",
            "body": "Hello Oleg,\n\n> Any of parameters relevant on the HttpMethod level should also be settable on \n> HttpClient level when applicable of a number of methods, IMO.\n\nSo you want to use the same params object for the client and methods, or use\nthe client params object as default for the methods object. Sounds good to me.\nKeep the hierarchy as it is.\n\n> Addition of HttpClient#HttpClient(HttpClientParams) sounds reasonable. We\n> might need to make DefaultHttpParams cloneable, [...]\n\nRight, no-one should use the same params object for multiple clients or methods\nand expect setters to be invoked without side effects. That should be made\nclear in the JavaDocs for the constructors that accept params objects.\n\nIt would surely be useful if all params objects were cloneable. I'd say that\non cloning, a params object should copy the parameters it holds locally, but\nkeep the same reference for the default params. No need to clone defaults,\nsince they are accessed read-only.\n\nWhile you're at it, can you add an \"implements Serializable\" as well?\nI don't know what it would be good for, but maybe someone someday wants\ndo deserialize params objects in an HttpParamsFactory.\n\nregards,\n  Roland\n",
            "date": "2003-09-19T19:18:56.000+0000",
            "id": 43
        },
        {
            "author": "Michael Becke",
            "body": "> Right, no-one should use the same params object for multiple clients or methods\n> and expect setters to be invoked without side effects. That should be made\n> clear in the JavaDocs for the constructors that accept params objects.\n\nI agree this could cause some strange problems.  Is there even a case to share the same instance \nof a params object between multiple methods/clients?  If not, perhaps the constructor should \nalways make copies.\n\n> It would surely be useful if all params objects were cloneable. I'd say that\n> on cloning, a params object should copy the parameters it holds locally, but\n> keep the same reference for the default params. No need to clone defaults,\n> since they are accessed read-only.\n\nSounds like a good idea.  I would suggest a copy constructor along with/instead of Cloneable as \ncloning can be a little ugly.\n\n> While you're at it, can you add an \"implements Serializable\" as well?\n> I don't know what it would be good for, but maybe someone someday wants\n> do deserialize params objects in an HttpParamsFactory.\n\nAgreed.\n\nMike",
            "date": "2003-09-19T19:31:53.000+0000",
            "id": 44
        },
        {
            "author": "Roland Weber",
            "body": "Hello Mike,\n\n> Is there even a case to share the same instance of a params object between\n> multiple methods/clients?  If not, perhaps the constructor should always\n> make copies.\n\nI intend to create params objects from my servlets's configuration, and\nto use them to create all methods affected by that configuration. The idea\nof having a constructor that accepts a params object was to avoid creating\ndefault params that get replaced immediately afterwards. Copying params\nin the constructor would leave me without a chance to avoid additional\nobject creation, even though the one I pass in is exactly the one I want\nto be used by the method.\n\n> I would suggest a copy constructor along with/instead of Cloneable as\n> cloning can be a little ugly.\n\nGood point. I support \"along with\". Cloning has the advantage that you\ndo not need to know the exact class of the object you're dealing with.\n",
            "date": "2003-09-19T19:42:25.000+0000",
            "id": 45
        },
        {
            "author": "Michael Becke",
            "body": "Hello Roland,\n\n> I intend to create params objects from my servlets's configuration, and\n> to use them to create all methods affected by that configuration. The idea\n> of having a constructor that accepts a params object was to avoid creating\n> default params that get replaced immediately afterwards. Copying params\n> in the constructor would leave me without a chance to avoid additional\n> object creation, even though the one I pass in is exactly the one I want\n> to be used by the method.\n\nSounds like a good enough reason to me.\n\nMike",
            "date": "2003-09-19T20:23:29.000+0000",
            "id": 46
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "I'll be working on a patch this weekend that will incorporate the suggested\nimprovements among other things.\n\nOleg",
            "date": "2003-09-20T06:01:01.000+0000",
            "id": 47
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Created an attachment (id=8311)\nFollow-up patch 1 (take 1)\n",
            "date": "2003-09-22T17:14:44.000+0000",
            "id": 48
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Changelog:\n- Ability to 'deep' clone DefaultHttpParams and its sub-classes\n- HttpClient constructors that accept custom parameter set\n- Complete javadoc\n\nLet me know what you think\n\nOleg",
            "date": "2003-09-22T17:18:03.000+0000",
            "id": 49
        },
        {
            "author": "Roland Weber",
            "body": "Hello Oleg,\n\n1. public HttpClient(HttpClientParams params)\nCan we add something like HttpConnectionManager.setParams(p)?\nI think the newly created connection manager should have a chance\nto learn from the parameters how many connections it is supposed\nto create and such stuff.\n\n2. DefaultHttpParams.clone()\nI believe the clone method is a little too smart. Think of the most\ncommon and simple case. You implemented an awfully complex way to\nclone objects of classes String, Integer, Long, Boolean and so on,\nall of which are serializable and non-modifiable classes that do\nnot need to be cloned at all.\nI suggest the simple approach: clone the collection but not it's\nelements and tell folks they shouldn't put complex objects in there.\nIn case of stored arrays such as for the date formats, a new array\nhas to be created when the old one is supposed to be modified. If\na parameter object cares about whether it needs to be cloned or not,\nthen it implements way too much logic to be a parameter object.\n\nOtherwise, it's peachy :-)\n\ncheers,\n  Roland",
            "date": "2003-09-22T18:26:07.000+0000",
            "id": 50
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "> 1. public HttpClient(HttpClientParams params)\n> Can we add something like HttpConnectionManager.setParams(p)?\n\nHttpParams-enable HttpConnection & HttpConnectionManager is the next item on my \nlist.\n\n> 2. DefaultHttpParams.clone()\n> I believe the clone method is a little too smart. Think of the most\n> common and simple case. \n\nActually I spent a healthy part of my last weekend studying different \napproaches to object cloning in Java. General sentiment is that \njava.lang.Object#clone() and java.lang.Cloneable are just plan broken. There \nare enough folks out there who believe that object serialization is the only \nway to go. \n\nI am a bit reluctant to put constraints on type of objects that may be used as \nparameter values as there's always a chance that we may overlook a legitimate \nuse pattern. I would also prefer to use Collection classes instead of arrays as \nthings may turn ugly if one wanted, for instance, just to add one additional \nDateFormat to the standard set of DateFormats. All that array content juggling \ncan get a bit messy\n\nI agree my clone method does appear to be an overkill, but that was the only \napproach which I felt was robust enough to handle all sorts of cases without \nrunning a risk of screwing things up in a subtle way. Anyways, I do not mind \nhaving a simpler method, but first of all, we need to agree on what type of \nobjects we should allow as parameter values. My opinion that we should allow all\n\nCheers\n\nOleg\n",
            "date": "2003-09-22T18:44:17.000+0000",
            "id": 51
        },
        {
            "author": "Roland Weber",
            "body": "Hello Oleg,\n\nfirst, let me define the term's I'll use in this posting:\n\nparams object: instance of DefaultHttpParams or one of it's subclasses\nparameter object: an object stored in a params object \n\nTo me, a parameter object represents a value. The value may be simple\nor structured, but it is accessed read-only by the HTTP client. The\nparameter object may change it's value asynchronously, but such change\nis never effected directly by the HTTP client.\nParams objects may be modified by the HTTP client, namely by the setter\nmethods that store the set values in the params object. However, such\nchange is always an addition, replacement, or removal of a parameter\nobject, never a modification of an existing one. Furthermore, the HTTP\nclient never implicitly clones params objects.\n\nUnder these assumptions, there is no need to make copies of parameter\nobjects from the HTTP client's point of view, as they are read-only.\nAn application programmer who uses parameter objects with changing\nvalues may have a need to control whether the same object or clones\nare stored in different params objects. However, as the HTTP client\ndoes not create clones implicitly, the application programmer has full\nfreedom to clone all parameter objects that require cloning whenever\nparams objects are prepared. Cloning may be controlled explicitly by\nreplacing copy-by-reference entries in a cloned params object, or the\nparams classes can be derived to clone specific entries. It is none\nof the HTTP client's concern.\n",
            "date": "2003-09-22T19:17:03.000+0000",
            "id": 52
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Makes sense to me. I'll simplify the DefaultHttpParams#clone() method and post \na new revision of the patch shortly.\n\nOleg",
            "date": "2003-09-22T19:24:28.000+0000",
            "id": 53
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Created an attachment (id=8313)\nFollow-up patch 1 (take 2)\n",
            "date": "2003-09-22T21:53:39.000+0000",
            "id": 54
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "DefaultHttpParams#clone() updated to incorporate Roland's feedback.\n\nOleg",
            "date": "2003-09-22T21:56:17.000+0000",
            "id": 55
        },
        {
            "author": "Roland Weber",
            "body": "Oleg, I like it.\n\nMike, there is no copy constructor right now. As it would have the\nsame signature as the constructor that takes default parameters, I\nsuggest to leave it that way.\n",
            "date": "2003-09-23T13:19:50.000+0000",
            "id": 56
        },
        {
            "author": "Michael Becke",
            "body": "Oleg, I agree, it looks good.\n\nRoland, I noticed the lack of copy constructor as well.  As you point out it would conflict with the \ndefault params constructor.  Just having clone() is good enough for me.\n\nMike",
            "date": "2003-09-23T19:37:51.000+0000",
            "id": 57
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "All right then. I'll commit the patch around 22:00 GMT, if nobody objects\n\nOleg",
            "date": "2003-09-23T20:45:00.000+0000",
            "id": 58
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Follow-up patch 1 (take 2) committed.\n\nOleg",
            "date": "2003-09-24T02:57:21.000+0000",
            "id": 59
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Created an attachment (id=8429)\nFollow-up patch 2 (take 1)\n",
            "date": "2003-10-02T20:58:50.000+0000",
            "id": 60
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Changelog:\n* Massive cleanup of deprecated methods\n* HeadMethod class changed to take advantage of the new preference architecture\n* EntityEnclosingMethod class changed to take advantage of the new preference \narchitecture\n\nLet me know what you think\n\nOleg",
            "date": "2003-10-02T21:01:30.000+0000",
            "id": 61
        },
        {
            "author": "Michael Becke",
            "body": "Looks good to me.\n\nMike",
            "date": "2003-10-03T09:18:08.000+0000",
            "id": 62
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Follow-up patch 2 (take 1) committed.\n\nOleg",
            "date": "2003-10-04T04:04:32.000+0000",
            "id": 63
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Created an attachment (id=8543)\nFollow-up patch 3 (take 1)\n",
            "date": "2003-10-13T03:11:16.000+0000",
            "id": 64
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Changelog:\n- HttpConnection & HttpConnectionManager classes updated to take advantage of\nthe new preference architecute.\n\nLet me know what you think\n\nOleg",
            "date": "2003-10-13T03:14:58.000+0000",
            "id": 65
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Created an attachment (id=8609)\nFollow-up patch 3 (take 2)\n",
            "date": "2003-10-17T23:24:43.000+0000",
            "id": 66
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "New patch adds receive buffer size parameter for HttpConnection and \nHttpConnectionManager classes.\n\nFolks, any feedback on the follow-up patch 3 so far?\n\nOleg",
            "date": "2003-10-17T23:26:27.000+0000",
            "id": 67
        },
        {
            "author": "Michael Becke",
            "body": "Oleg,\n\nThese changes look good.   I have only one question.  Why does HttpConnection now have \nsetSoTimeout() and setSocketTimeout()?\n\nMike",
            "date": "2003-10-19T23:02:52.000+0000",
            "id": 68
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Mike,\nI agree it's ugly. The problem is there are situations when read timeout must be\nchanged on an open socket (when handling 100-continue handshake) The choice here\nis between two evils: either make HttpConnectionParams tightly coupled with\nHttpConnection or Socket object, or to provide a way to set read timeout on\nHttpconnection directly. If you see a more elegant way of solving the problem,\ngive me a hint\n\nOleg",
            "date": "2003-10-20T00:57:41.000+0000",
            "id": 69
        },
        {
            "author": "Michael Becke",
            "body": "Oleg,\n\nAh.  I see what you are doing.  This seems like a decent solution, nothing better comes to mind.  \nTo keep things consistent I think setSoTimeout(int) should still set the timeout on the socket, if \npresent.  The new Javadoc @link on setSoTimeout() should be changed to setSocketTimeout().  \nOther than that I think it's good to be committed.\n\nMike",
            "date": "2003-10-20T19:14:36.000+0000",
            "id": 70
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Follow-up patch 3 committed.\n\nI am planning to submit one more, hopefully the final, follow-up patch shortly\n\nOleg",
            "date": "2003-10-23T02:45:07.000+0000",
            "id": 71
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Created an attachment (id=8679)\nFollow-up patch 4 (take 1)\n",
            "date": "2003-10-23T03:56:36.000+0000",
            "id": 72
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Changelog:\n- The patch removes those HttpClientParams parameters that are better served by\nthe HttpConnectionManagerParams\n- MultiThreadedHttpConnectionManager specific parameters changed to take\nadvantage of the new preference architecture \n\nDo you think that the following parameters should be deprecated?\n\nMultiThreadedHttpConnectionManager#getMaxHostConnections\nMultiThreadedHttpConnectionManager#setMaxHostConnections\nMultiThreadedHttpConnectionManager#getMaxTotalConnections\nMultiThreadedHttpConnectionManager#setMaxTotalConnections\n\nOleg",
            "date": "2003-10-23T04:05:02.000+0000",
            "id": 73
        },
        {
            "author": "Michael Becke",
            "body": "Oleg,\n\nA few comments:\n\n- I think the connectionManagerTimeout should be left on the HttpClient.  The value is used by \nHttpClient/HttpMethodDirector when retrieving connections and not directly by the connection \nmanagers.  In fact this seems to be causing a compile error in HttpMethodDirector, which was \ninitially undetected by Eclipse for some reason.\n- What happened to the soTimeout option?\n\nI agree MultiThreadedHttpConnectionManager maxHostConnections and maxTotalConnections \nshould be moved to preferences and deprecated.\n\nMike",
            "date": "2003-10-24T09:03:59.000+0000",
            "id": 74
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Created an attachment (id=8734)\nFollow-up patch 4 (take 2)\n",
            "date": "2003-10-25T18:43:45.000+0000",
            "id": 75
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "> - What happened to the soTimeout option?\n\nMike, I do not quite get what is the point of your concern hrere. Socket read\ntimeout has been moved to HttpConnectionManagerParams. I believe that is where\nit should be. \n\nLet me know what you think about the new patch\n\nOleg",
            "date": "2003-10-25T18:46:44.000+0000",
            "id": 76
        },
        {
            "author": "Michael Becke",
            "body": "Oleg,\n\nPerhaps I'm missing something but I don't see the soTimeout option on the \nHttpConnectionManagerParams.\n\nMike",
            "date": "2003-10-26T01:22:58.000+0000",
            "id": 77
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Mike, \nHttpConnectionManagerParams inherits SO_TIMEOUT/TCP_NODELAY/SO_RCVBUF/SO_SNDBUF\nparameters along with several others from HttpConnectionParams. Do you see any\nproblem with that?\n\nOleg",
            "date": "2003-10-26T01:33:54.000+0000",
            "id": 78
        },
        {
            "author": "Michael Becke",
            "body": "Oleg,\n\nYou are quite right.  Somehow I seem to have missed that :)  I agree I think HttpConnectionParams \nis the right place for soTimeout, et al.  The patch looks good to me.\n\nMike",
            "date": "2003-10-26T02:03:58.000+0000",
            "id": 79
        },
        {
            "author": "Oleg Kalnichevski",
            "body": "Patch committed. It looks like the journey is finally over.\n\nOleg",
            "date": "2003-10-26T17:57:28.000+0000",
            "id": 80
        }
    ],
    "component": "HttpClient (classic)",
    "description": "An architectural solution is needed to configure various aspects of HttpClient,\nMethods and Connections. \n\nFeatures:\n- can configure certain properties per request / per connection\n- all configuration is done in a consistant way \n- do not use system properties\n- configuration is completely optional: default values should be used if no\nconfiguration is made\n\nThis is a refactoring request / reminder. File configuration issues as\ndependencies of this bug.",
    "hasPatch": true,
    "hasScreenshot": false,
    "id": "HTTPCLIENT-132",
    "issuetypeClassified": "RFE",
    "issuetypeTracker": "IMPROVEMENT",
    "priority": "Minor",
    "product": "HTTPCLIENT",
    "project": "HTTPCLIENT",
    "summary": "New Preferences Architecture",
    "systemSpecification": false,
    "version": "2.0 Alpha 1"
}