{
    "comments": [
        {
            "author": "Ortwin Gl\u00fcck",
            "body": "Checked-in fixes for the two issues. Submitted a patch to list for the loop\noptimization.",
            "date": "2002-09-23T21:18:46.000+0000",
            "id": 0
        }
    ],
    "component": "HttpClient (classic)",
    "description": "Bug 1.\n\nIn the     \n\nread(byte[] b, int off, int len)  method\n\nof ChunkedInputStream, the number of bytes to read from the underlying \nInputStream is calculated wrongly. In the code this is done by\n\nlen = Math.min(len, chunkSize);\n\nThis could (and will) cause the server (also Apache) to indeed serve that \nnumber of bytes (let's say chunkSize), but it may be that we already had a \nnumber of bytes on the first read. The result is that the input is now NOT \npositioned on the end of a chunk and the rest of the reader fails because it \ncannot find CRLF or a valid chunksize.\n\nProposed fix (works, tested)\nlen = Math.min(len, chunkSize-pos);\n\nBug 2.\n\nIn the calculation of the chunkSize (method getChunkSizeFromInputStream) the \nconversion to int is done by calling             \n\nresult = Integer.parseInt(dataString, 16);\n\nThis is not robust and causes the occasional crash. The fix is simple and in \nfact implements what is done when the chunkSize is commented (see lines in code \nabove)\n\nresult = Integer.parseInt(dataString.trim(), 16);\n\nTested and works.\n\n\n\nSuggestion:\nSame routine, input state machine. Perhaps just being pedantic..change while \nloop to:\n\n        while (state != 2) {\n            int b = in.read();\n            if (b == -1) throw new IOException(\"chunked stream ended \nunexpectedly\");\n            switch (state) {\n                case 0:\n                    if (b == '\\r')\n                      state = 1;\n                    else\n                      baos.write(b);\n                    break;\n                case 1:\n                    if (b == '\\n')\n                      state = 2;\n                    else{\n                     // this was not CRLF, so now write '\\r' + this char\n                      baos.write('\\r');\n                      baos.write(b);\n                      state = 0;\n                    }\n                    break;\n                default: throw new RuntimeException(\"assertion failed\");\n            }\n        }.\n\nIn the     \n\nread(byte[] b, int off, int len)  method\n\nof ChunkedInputStream, the number of bytes to read from the underlying \nInputStream is calculated wrongly. In the code this is done by\n\nlen = Math.min(len, chunkSize);\n\nThis could (and will) cause the server (also Apache) to indeed serve that \nnumber of bytes (let's say chunkSize), but it may be that we already had a \nnumber of bytes on the first read. The result is that the input is now NOT \npositioned on the end of a chunk and the rest of the reader fails because it \ncannot find CRLF or a valid chunksize.\n\nProposed fix (works, tested)\nlen = Math.min(len, chunkSize-pos);\n\nBug 1.\n\nIn the     \n\nread(byte[] b, int off, int len)  method\n\nof ChunkedInputStream, the number of bytes to read from the underlying \nInputStream is calculated wrongly. In the code this is done by\n\nlen = Math.min(len, chunkSize);\n\nThis could (and will) cause the server (also Apache) to indeed serve that \nnumber of bytes (let's say chunkSize), but it may be that we already had a \nnumber of bytes on the first read. The result is that the input is now NOT \npositioned on the end of a chunk and the rest of the reader fails because it \ncannot find CRLF or a valid chunksize.\n\nProposed fix (works, tested)\nlen = Math.min(len, chunkSize-pos);\n\nBug 2.\n\nIn the calculation of the chunkSize (method getChunkSizeFromInputStream) the \nconversion to int is done by calling             \n\nresult = Integer.parseInt(dataString, 16);\n\nThis is not robust and causes the occasional crash. The fix is simple and in \nfact implements what is done when the chunkSize is commented (see lines in code \nabove)\n\nresult = Integer.parseInt(dataString.trim(), 16);\n\nTested and works.\n\n\n\nSuggestion:\nSame routine, input state machine. Perhaps just being pedantic..change while \nloop to:\n\n        while (state != 2) {\n            int b = in.read();\n            if (b == -1) throw new IOException(\"chunked stream ended \nunexpectedly\");\n            switch (state) {\n                case 0:\n                    if (b == '\\r')\n                      state = 1;\n                    else\n                      baos.write(b);\n                    break;\n                case 1:\n                    if (b == '\\n')\n                      state = 2;\n                    else{\n                     // this was not CRLF, so now write '\\r' + this char\n                      baos.write('\\r');\n                      baos.write(b);\n                      state = 0;\n                    }\n                    break;\n                default: throw new RuntimeException(\"assertion failed\");\n            }\n        }.\n\nIn the calculation of the chunkSize (method getChunkSizeFromInputStream) the \nconversion to int is done by calling             \n\nresult = Integer.parseInt(dataString, 16);\n\nThis is not robust and causes the occasional crash. The fix is simple and in \nfact implements what is done when the chunkSize is commented (see lines in code \nabove)\n\nresult = Integer.parseInt(dataString.trim(), 16);\n\nTested and works.\n\n\n\nSuggestion:\nSame routine, input state machine. Perhaps just being pedantic..change while \nloop to:\n\n        while (state != 2) {\n            int b = in.read();\n            if (b == -1) throw new IOException(\"chunked stream ended \nunexpectedly\");\n            switch (state) {\n                case 0:\n                    if (b == '\\r')\n                      state = 1;\n                    else\n                      baos.write(b);\n                    break;\n                case 1:\n                    if (b == '\\n')\n                      state = 2;\n                    else{\n                     // this was not CRLF, so now write '\\r' + this char\n                      baos.write('\\r');\n                      baos.write(b);\n                      state = 0;\n                    }\n                    break;\n                default: throw new RuntimeException(\"assertion failed\");\n            }\n        }",
    "hasPatch": false,
    "hasScreenshot": false,
    "id": "HTTPCLIENT-105",
    "issuetypeClassified": "BUG",
    "issuetypeTracker": "BUG",
    "priority": "Major",
    "product": "HTTPCLIENT",
    "project": "HTTPCLIENT",
    "summary": "ChunkedInputStream broken (2 bugs + fixes, 1 suggestion)",
    "systemSpecification": true,
    "version": ""
}