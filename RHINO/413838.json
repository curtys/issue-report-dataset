{
    "comments": [
        {
            "author": "norrisboyd@gmail.com",
            "body": "The proposed change won't work:\n\njs> var a = new java.util.HashMap();\njs> var b = new java.util.HashMap();\njs> a == b\nRHINO USAGE WARNING: Missed Context.javaToJS() conversion:\nRhino runtime detected object {} of class java.util.HashMap where it expected String, Number, Boolean or Scriptable instance. Please check your code for missing Context.javaToJS() call.\nfalse\n\nThe problem is that a Wrapper doesn't necessarily wrap a value that can be handled by the Rhino runtime (which is why we have Wrappers in the first place).  So passing the unwrapped values to eq() can cause the problem above. \n\nWhat if we just make this change instead:\n                if (x instanceof Wrapper && y instanceof Wrapper) {\n                    return ((Wrapper)x).unwrap().equals(((Wrapper)y).unwrap());\n                }\n?",
            "date": "20080208T20:30:20",
            "id": 0
        },
        {
            "author": "vyacheslav.soldatov@bridge-quest.com",
            "body": "IMHO, eq(obj1, obj2) should be invoked only for primitive types and string, but should be invoked eq(obj1, obj2) certainly.\nBecause the method eq(obj1, obj2) correctly and accurately handles any situations when arguments have different types, by example:\nnew java.lang.String(\"1\") == new java.lang.Integer(1); //should be true\nand any other.\n\nBy example, following fix can be used:\n.......\n                if (x instanceof Wrapper && y instanceof Wrapper) {\n                \tObject obj1 = ((Wrapper)x).unwrap();\n                \tObject obj2 = ((Wrapper)y).unwrap();\n\n                \tif (isPrimitiveOrString(obj1) && isPrimitiveOrString(obj2)) {\n                \t\treturn eq(obj1, obj2);\n                \t}\n\n                    return obj1 == obj2;\n                }\n.......\nwhen\n    private static boolean isPrimitiveOrString(final Object obj) {\n    \treturn\n    \t\t(obj instanceof Number)\n    \t\t|| (obj instanceof String)\n    \t\t|| (obj instanceof Boolean);\n    }\n",
            "date": "20080209T18:40:00",
            "id": 1
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "Looking at this more, I checked out the relevant ECMA section:\n\n11.9.3 The Abstract Equality Comparison Algorithm\nThe comparison x == y, where x and y are values, produces true or false. Such a comparison is\nperformed as follows:\n1. If Type(x) is different from Type(y), go to step 14.\n2. If Type(x) is Undefined, return true.\n3. If Type(x) is Null, return true.\n4. If Type(x) is not Number, go to step 11.\n5. If x is NaN, return false.\n6. If y is NaN, return false.\n7. If x is the same number value as y, return true.\n8. If x is +0 and y is \u22120, return true.\n9. If x is \u22120 and y is +0, return true.\n10. Return false.\n11.If Type(x) is String, then return true if x and y are exactly the same sequence of characters (same\nlength and same characters in corresponding positions). Otherwise, return false.\n12. If Type(x) is Boolean, return true if x and y are both true or both false. Otherwise, return false.\n13.Return true if x and y refer to the same object or if they refer to objects joined to each other (see\n13.1.2). Otherwise, return false.\n14. If x is null and y is undefined, return true.\n15. If x is undefined and y is null, return true.\n- 56 -\n16.If Type(x) is Number and Type(y) is String,\nreturn the result of the comparison x == ToNumber(y).\n17.If Type(x) is String and Type(y) is Number,\nreturn the result of the comparison ToNumber(x) == y.\n18. If Type(x) is Boolean, return the result of the comparison ToNumber(x) == y.\n19. If Type(y) is Boolean, return the result of the comparison x == ToNumber(y).\n20.If Type(x) is either String or Number and Type(y) is Object,\nreturn the result of the comparison x == ToPrimitive(y).\n21.If Type(x) is Object and Type(y) is either String or Number,\nreturn the result of the comparison ToPrimitive(x) == y.\n22. Return false.\n\nSince \"joined\" objects in step 13 refers only to function objects, we don't have the normal \"host object\" escape clause I would have expected. That means we can't implement something more than object identity in the case of two objects. I think the current implementation is correct as the same Java object could have two different wrappers.",
            "date": "20080212T14:54:09",
            "id": 2
        },
        {
            "author": "vyacheslav.soldatov@bridge-quest.com",
            "body": "Yes, formally it is right. The java.lang.String is the java object and should be handled as punkt 13.\nBut see please example:\njs> var a = \"\";\njs> var b = \"\";\njs> a == b; //good result\ntrue\njs> var map1 = new java.util.HashMap();\njs> var map2 = new java.util.HashMap();\njs> map1.put(\"key\", a);\nnull\njs> map2.put(\"key\", b);\nnull\njs> map1.get(\"key\") == map2.get(\"key\"); //not good result because this is equals with a==b\nfalse\njs> \n\nIn last string the result of map1.get(\"key\") is the variable a, and result of map2.get(\"key\") is the variable b. If we directly compare them then result will 'true' and if we compare them as results of operation get from corresponding map, the result will 'false'. This is result of conversation rhino objects to java objects and back.\nThis is a cause. Two ways there are for resolving of this situation.\n1. Changing of implementation of work with java objects and methods. All returned values if they are primitive should be not wrapped.\n2. Wrapped java primitives should have a bihaviour like as corresponding native rhino primitive.\n\nIMHO second approach is more simple and natural.",
            "date": "20080212T17:23:44",
            "id": 3
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "Thanks, that's a much more motivating example. The machinery of wrapping and unwrapping JavaScript primitives interferes with the normal comparison semantics.\n\nI've submitted your proposed change with minor changes.",
            "date": "20080213T18:33:40",
            "id": 4
        }
    ],
    "component": "Core",
    "description": "User-Agent:       Mozilla/5.0 (X11; U; Linux i686; ru; rv:1.8.1.10) Gecko/20071128 Fedora/2.0.0.10-2.fc7 Firefox/2.0.0.10\nBuild Identifier: 1_6R7\n\nIn case of arguments (Wrapper, Wrapper) this method invokes following code:\n                if (x instanceof Wrapper && y instanceof Wrapper) {\n                    return ((Wrapper)x).unwrap() == ((Wrapper)y).unwrap();\n                }\n\nbut should invoke:\n                if (x instanceof Wrapper && y instanceof Wrapper) {\n                    return eq(((Wrapper)x).unwrap(), ((Wrapper)y).unwrap());\n                }\nThis bug may appearances, by example, if we have in current scope two equals wrapped string objects. It may be if the object is returned from another object. In this case the operator a == b returns false instead of true, but the operation a.equals(b) returns true. It not appears if we will use code\n(\"\" + a) == (\"\" + b) which casts the objects to real strings.\n\nReproducible: Always\n\nSteps to Reproduce:\n1. Create two equals wrapped strings (x = \"aaa\", y = \"aaa\") and put them into top level scriptable as indexed properties.\n2. execute script \"x == y\"\nActual Results:  \nfalse\n\nExpected Results:  \ntrue\n\nThe unit test by example of reproduce:\n/**\n * TestEq.java (24.01.2008)\n */\n\npackage com.uupdate.script.js;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.mozilla.javascript.Context;\nimport org.mozilla.javascript.NativeJavaObject;\nimport org.mozilla.javascript.Script;\nimport org.mozilla.javascript.Scriptable;\nimport org.mozilla.javascript.tools.shell.Global;\n\nimport junit.framework.TestCase;\n\n/**\n * @author Vyacheslav Soldatov\n *\n */\npublic class TestEq extends TestCase {\n    /**\n     * The scripting context.\n     */\n    private Context context;\n\n    /**\n     * The constructor.\n     */\n    public TestEq() {\n        super();\n    }\n\n    /**\n     * @param name the test case name.\n     */\n    public TestEq(final String name) {\n        super(name);\n    }\n\n    /**\n     * @see junit.framework.TestCase#setUp()\n     */\n    @Override\n    protected void setUp() throws Exception {\n        context = Context.enter();\n    }\n\n    /**\n     * Tests '==' operator.\n     * @throws IOException comilation exception.\n     */\n    public void testEq() throws IOException {\n        Map<String, String> map = new HashMap<String, String>();\n        map.put(\"x\", new String(\"aaa\"));\n        map.put(\"y\", new String(\"aaa\"));\n\n        Scriptable scriptable =  new NativeJavaObject(new Global(), map, Map.class);\n        Object obj = compileScript(\"get('x') == get('y');\").exec(context, scriptable);\n        assertEquals(Boolean.TRUE, obj);\n    }\n\n    /**\n     * Tests 'equals' work.\n     * @throws IOException comilation exception.\n     */\n    public void testEquals() throws IOException {\n        Map<String, String> map = new HashMap<String, String>();\n        map.put(\"x\", new String(\"aaa\"));\n        map.put(\"y\", new String(\"aaa\"));\n\n        Scriptable scriptable =  new NativeJavaObject(new Global(), map, Map.class);\n        Object obj = compileScript(\"get('x').equals(get('y'));\").exec(context, scriptable);\n        assertEquals(Boolean.TRUE, obj);\n    }\n\n    /**\n     * @param script the script body.\n     * @return compiled script. \n     * @throws IOException \n     */\n    private Script compileScript(final String script) throws IOException {\n        return context.compileReader(new StringReader(script), \"Unit test body\", 0, null);\n    }\n    /**\n     * @see junit.framework.TestCase#tearDown()\n     */\n    @Override\n    protected void tearDown() throws Exception {\n        Context.exit();\n    }\n}",
    "hasPatch": false,
    "hasScreenshot": false,
    "id": "413838",
    "issuetypeClassified": "BUG",
    "issuetypeTracker": "BUG",
    "priority": "-- normal",
    "product": "Rhino",
    "project": "RHINO",
    "summary": "Incorrect ScriptRuntime.eq(Object, Object) implementation",
    "systemSpecification": true,
    "version": "other"
}