{
    "comments": [
        {
            "author": "igor@mir2.org",
            "body": "Created attachment 117387\nScript test case where optimizer uses optimization leading to creation of static field",
            "date": "20030316T13:13:06",
            "id": 0
        },
        {
            "author": "igor@mir2.org",
            "body": "Created attachment 117388\nJava program to demonstrate a memory leak with classes created by JavaScript compiler for the the previous attachment",
            "date": "20030316T13:14:32",
            "id": 1
        },
        {
            "author": "igor@mir2.org",
            "body": "Steps to reproduce the problem:\n\n1. Compile the script from the first attachment by JavaScript compiler with an\noptimization level set to 1 or higher:\n\njava -classpath js.jar  org.mozilla.javascript.tools.jsc.Main -opt 1 script.js\n\n2. Compile a Java program form the second attachment:\n\njavac -classpath .:js.jar StaticFieldProblem.java\n\nwhere . is included to the classpath so javac finds classes generated by\nJavaScript compiler. \n\nThe program instantiate and execute an instance of the class script created by\nJavaScript compiler and then calls the garbage collector explicitly to see if an\ninstance of CustomScope which the program as a scope object is finalized.\n\n3. Run StaticFieldProblem:\n\njavac -classpath .:js.jar StaticFieldProblem\n\nIt currently prints \nfinalizeCount=0\nindicating that a reference to CustomScope is not GCed. \n",
            "date": "20030316T13:31:41",
            "id": 2
        },
        {
            "author": "igor@mir2.org",
            "body": "Created attachment 117390\nMaking references to direct call targets an instance fields of the main script class.\n\nThe static fields generated by the compiler store references to objects\nrepresenting JavaScript functions that are targets of direct call optimization.\n\nThey are used to make sure during optimized calls that a function reference\nstill points to the original function object.  For example, in the script from\nthe first attachment:\n\nfunction a(x)\n{\n\tb(x);\n}\n\nfunction b(x)\n{\n\treturn x == 0;\n}\n\nthe code generated for a() to call b() checks if the property b still holds the\noriginal function object and if it does, a() will use an optimized calling\nconversion to call b(). \n\nThe patch replaces static fields by an instance fields in the class\nrepresenting the main script object. This is quite significant change since it\nadds code to store/query a field that refers to the main class to each function\nclass and changes the way the direct fields are initialized. Still the patch\nitself is not that big since during the work on the patch I found that some of\nrefactoring that are necessary for the patch is make sense to apply on its own\nand that part is already in CVS.",
            "date": "20030316T13:50:14",
            "id": 3
        },
        {
            "author": "igor@mir2.org",
            "body": "I commited the patch and now the test case prints what it should:\n\nfinalizeCount=1",
            "date": "20030316T13:54:54",
            "id": 4
        },
        {
            "author": "pschwartau@meer.net",
            "body": "Marking Verified.\n\nI also get 'finalizeCount=1' as the output of the steps to reproduce\ngiven in Comment #3. \n\nHowever, that's what I got before the patch was committed, as well!\nIs it possible the results are machine-dependent?",
            "date": "20030317T00:06:59",
            "id": 5
        },
        {
            "author": "igor@mir2.org",
            "body": "Phil, did you re-run the JavaScript compiler with optimization set to 1 against\nthe scripts when you run the test with and without patch? It is strange that you\nget that finalizeCount=1 in both cases. Without the patch the script compiler\nhas to produce the code with static fields that are never cleared and AFAIK\nobjects reachable through such fields should not be subject of garbage\ncollection since JDK 1.1 in this case.",
            "date": "20030318T20:37:24",
            "id": 6
        },
        {
            "author": "pschwartau@meer.net",
            "body": "Igor: you're right! I must have made some mistake the other day. When\nI try the testcase today against rhino1_5R4pre (i.e. before the fix),\nI get finalizeCount=0 just like you did.\n\nSorry for the trouble. I will attach my results below, verifying\nthat the bug is fixed -",
            "date": "20030318T22:20:13",
            "id": 7
        },
        {
            "author": "pschwartau@meer.net",
            "body": "Created attachment 117645\nVerification results:  rhino1_5R4pre  vs.  rhino1_5R4",
            "date": "20030318T22:25:15",
            "id": 8
        },
        {
            "author": "igor@mir2.org",
            "body": "Thanks Phil!",
            "date": "20030318T23:34:43",
            "id": 9
        },
        {
            "author": "igor@mir2.org",
            "body": "Targeting as resolved against 1.5R5",
            "date": "20040213T11:52:06",
            "id": 10
        }
    ],
    "component": "Compiler",
    "description": "Currently Rhino optimizer with optimization level set to 1 or higher adds a\nstatic fields to classes representing compiled script functions to perform\nfunction call optimization.\n\nThese static fields holds references to script runtime objects and as long as\nthe loaded classes together with their static fields are not garbage collected,\nthe runtime structures will remain in JVM memory. It is not a problem in typical\nsituations where script is created and immediately executed since in such cases\ngenerated classes can be GCed after script execution allowing to GC the runtime\nas well.\n\nBut in the case of JavaScript compiler this is no longer true since then\ngenerated classes representing a compiled script are stored as class files and\ncan be loaded via system class loader which means that object stored in static\nfields will never be garbage collected. It leaks references to script runtime\nstructures and if script is loaded more then once, it will disable the\noptimization altogether since the static fields will hold the reference for\nwrong runtime structures.\n\nP.S. From now I will use igor@fastmail.fm for mozilla.org and other\ncommunications outside my work since due to various reorganization at work\nigor@icesoft.no and igor@icesoft.com may or may not work, a provider that I used\nfor private mail (igor at mir2 org) made an \"improvement\" that stopped mail\nworking for days and igor3@apochta.com that I sometime used for various mail\nlists to prevent spam is no longer necessary since I finally got good enough\nspam filters.",
    "hasPatch": true,
    "hasScreenshot": false,
    "id": "197682",
    "issuetypeClassified": "IMPROVEMENT",
    "issuetypeTracker": "BUG",
    "priority": "-- normal",
    "product": "Rhino",
    "project": "RHINO",
    "summary": "Memory leak via static filed in generated bytecode",
    "systemSpecification": true,
    "version": "other"
}