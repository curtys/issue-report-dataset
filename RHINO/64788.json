{
    "comments": [
        {
            "author": "norrisboyd@gmail.com",
            "body": "Fantastic! \n\nCould you send me a diff for FunctionObject.java that shows how you call it? \nI've tried what I thought was obvious but it doesn't quite work.\n\n",
            "date": "20010109T20:37:19",
            "id": 0
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "Okay, I've got it running now. I'm seeing no difference on BenchPress.js, but\nit doesn't call too many built-in functions. I made a simple test like \n\nfunction f() {\n        for (var i=0; i < 10000; i++) {\n                Math.abs(-1);\n        }\n}\nvar d = new Date();\nf();\nprint((new Date()) - d);\n\nI see a speedup of a little under 50%. I'll attach my diff so you can see if I\nleft out something. (Still a nice performance boost.)",
            "date": "20010109T21:40:12",
            "id": 1
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "Created attachment 22172\nproposed patch with recommended changes",
            "date": "20010109T21:41:01",
            "id": 2
        },
        {
            "author": "dnavas@yahoo.com",
            "body": "Sorry to mislead -- the 10x performance is the performance boost seen from just \nthe .invoke() viewpoint, not the boost seen through the entire javascript \nfunction call process (which includes looking up the function to call, possibly \nthrough scope or prototype chains, retrieving the Context from a hashtable, \netc.).  Now, that would be too much to hope for!\n\nThe time spent in the test I was using decreased by about 30% overall, iirc.  \nIf it helps, the .js I'm using is:\n    http://pages.ebay.com/included/js/cobrand/links.js\n[yes, it would be easier to fix the javascript, but I don't have that \nluxury ;^/]\n\n\nLooked at the proposed changes, four comments:\n\n1) This diff has got to be wrong:\n+                    type == Boolean.TYPE &&\n+                    type == Byte.TYPE &&\n+                    type == Short.TYPE &&\n+                    type == Integer.TYPE &&\n+                    type == Float.TYPE && \n+                    type == Double.TYPE)\n\nThere's no way for that to ever be true!\nThe only thing I changed there was to remove these lines\n<                     types[i] = ScriptRuntime.BooleanClass;\n178d561\n<                     types[i] = ScriptRuntime.ByteClass;\n181d563\n<                     types[i] = ScriptRuntime.ShortClass;\n184d565\n<                     types[i] = ScriptRuntime.IntegerClass;\n187d567\n<                     types[i] = ScriptRuntime.FloatClass;\n190d569\n<                     types[i] = ScriptRuntime.DoubleClass;\n\n2) The constructor for FunctionObject sometimes nulls out the types\n   array (if there is no casting required).  I don't think your change took\n   that into account???  I grab the paramTypes of the method again if types\n   is null.  No biggie....\n\n3) There are two methods in FunctionObject, one in call() and one in\n   callVarargs(), that can use MyMethod\n\n4) There is one place in ScriptableObject (getter invoke) you might want to\n   consider as well.  Most of the code I was dealing with was actually calling\n   getters (getDocument(), getLinks(), getHref(), etc., as you might be able\n   to tell from the above .js file)\n\nI'd send a FunctionObject diff to you, but I've made so many tweaks to the\nfile at this point that it might call functions or reference classes that don't \nexist in your version (getParameterTypes() and NativeDelegate I think fall into \nthat category).  But, for what it's worth, aside from the MyMethod stuff I \nalready sent, and the import line:\n***************\n*** 171,194 ****\n                  {\n                      hasConversions = true;\n                  } else if (type == Boolean.TYPE) {\n                      hasConversions = true;\n-                     types[i] = ScriptRuntime.BooleanClass;\n                  } else if (type == Byte.TYPE) {\n                      hasConversions = true;\n-                     types[i] = ScriptRuntime.ByteClass;\n                  } else if (type == Short.TYPE) {\n                      hasConversions = true;\n-                     types[i] = ScriptRuntime.ShortClass;\n                  } else if (type == Integer.TYPE) {\n                      hasConversions = true;\n-                     types[i] = ScriptRuntime.IntegerClass;\n                  } else if (type == Float.TYPE) {\n                      hasConversions = true;\n-                     types[i] = ScriptRuntime.FloatClass;\n                  } else if (type == Double.TYPE) {\n                      hasConversions = true;\n-                     types[i] = ScriptRuntime.DoubleClass;\n                  } else if ( type.isInterface() )\n                  {\n                      //Pretend like none is needed.\n                      //hasConversions = true;\n--- 556,573 ----\n***************\n*** 592,601 ****\n              if ( thisObj instanceof NativeDelegate )\n              {\n                  thisObj = thisObj.getPrototype();\n              }\n!             Object result = (method != null)\n!                             ? method.invoke(thisObj, invokeArgs)\n                              : ctor.newInstance(invokeArgs);\n              return hasVoidReturn ? Undefined.instance : result;\n          }\n          catch (InvocationTargetException e) {\n--- 971,986 ----\n              if ( thisObj instanceof NativeDelegate )\n              {\n                  thisObj = thisObj.getPrototype();\n              }\n!\n!             if ( myMethod == null && method != null)\n!             {\n!                 // Initialize the myMethod correctly!\n!                 myMethod = MyMethod.initializeMyMethod(method, (types==null?ge\ntParameterTypes(method):types));\n!             }\n!\n!             Object result = (myMethod!=null)? myMethod.invoke(thisObj, invokeA\nrgs)\n                              : ctor.newInstance(invokeArgs);\n              return hasVoidReturn ? Undefined.instance : result;\n          }\n          catch (InvocationTargetException e) {\n***************\n*** 661,677 ****\n          throws JavaScriptException\n      {\n          try {\n              if (parmsLength == VARARGS_METHOD) {\n!                 Object[] invokeArgs = { cx, thisObj, args, this };\n!                 Object result = method.invoke(null, invokeArgs);\n                  return hasVoidReturn ? Undefined.instance : result;\n              } else {\n                  Boolean b = inNewExpr ? Boolean.TRUE : Boolean.FALSE;\n!                 Object[] invokeArgs = { cx, args, this, b };\n!                 return (method == null)\n!                        ? ctor.newInstance(invokeArgs)\n!                        : method.invoke(null, invokeArgs);\n              }\n          }\n          catch (InvocationTargetException e) {\n              Throwable target = e.getTargetException();\n--- 1046,1073 ----\n          throws JavaScriptException\n      {\n          try {\n              if (parmsLength == VARARGS_METHOD) {\n!                 Object[] invokeArgs = cx.getStaticFunctionArgs( thisObj, args,\n this );\n!                 if ( myMethod == null)\n!                 {\n!                     // Initialize the myMethod correctly!\n!                     myMethod = MyMethod.initializeMyMethod(method, (types==nul\nl?getParameterTypes(method):types));\n!                 }\n!                 Object result = myMethod.invoke(null, invokeArgs);\n                  return hasVoidReturn ? Undefined.instance : result;\n              } else {\n                  Boolean b = inNewExpr ? Boolean.TRUE : Boolean.FALSE;\n!                 Object[] invokeArgs = cx.getStaticFunctionArgs( args, this, b\n);\n!\n!                 if ( myMethod == null && method != null)\n!                 {\n!                     // Initialize the myMethod correctly!\n!                     myMethod = MyMethod.initializeMyMethod(method, (types==nul\nl?getParameterTypes(method):types));\n!                 }\n!\n!                 return (myMethod!=null)?myMethod.invoke(null, invokeArgs)\n!                                        :ctor.newInstance(invokeArgs);\n              }\n          }\n          catch (InvocationTargetException e) {\n              Throwable target = e.getTargetException();\n***************\n*** 704,711 ****\n--- 1100,1108 ----\n      private static boolean sawSecurityException;\n\n      static Method[] methodsCache;\n\n+     MyMethod myMethod;\n      Method method;\n      Constructor ctor;\n      private Class[] types;\n      private short parmsLength;\n\n",
            "date": "20010110T20:53:22",
            "id": 3
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "Fixed:\n\nChecking in Context.java;\n/cvsroot/mozilla/js/rhino/org/mozilla/javascript/Context.java,v  <--  Context.ja\nva\nnew revision: 1.47; previous revision: 1.46\ndone\nChecking in FunctionObject.java;\n/cvsroot/mozilla/js/rhino/org/mozilla/javascript/FunctionObject.java,v  <--  Fun\nctionObject.java\nnew revision: 1.20; previous revision: 1.19\ndone\nChecking in JavaAdapter.java;\n/cvsroot/mozilla/js/rhino/org/mozilla/javascript/JavaAdapter.java,v  <--  JavaAd\napter.java\nnew revision: 1.36; previous revision: 1.35\ndone",
            "date": "20010114T01:20:27",
            "id": 4
        },
        {
            "author": "pschwartau@meer.net",
            "body": "Marking Verified - ",
            "date": "20010116T20:58:19",
            "id": 5
        }
    ],
    "component": "Core",
    "description": "Method.invoke() is an NMI call (JNI in 1.3 and up) and is not replaced when \nusing the JIT.  That means that it's gawd-awful slow.  By replacing \nmethod.invoke() and getterSlot.getter.invoke() calls with on-the-fly generated \nstub code that calls the method in question directly, the invocation of methods \ncan be sped up by an order of magnitude (or 20x when running under 1.3).\n\nTo hook the code in, keep a MyMethod instance in the FunctionObject and \nGetterSlot.  You may want to only keep a MyMethod instance for getters (setters \ncan be slow, I would think, and may not warrant the extra space?).  You create \nthe instances on-the-fly or during construction -- both seem to work -- by \ncalling initializeMyMethod().  If you plan on creating instances on-the-fly, \nyou should review the FunctionObject constructor.  It modifies the parameter \ntypes so that primitive types aren't primitive types anymore.  There may have \noriginally been a reason for this code, but the parameter casting code checks \nboth the ScriptRuntime classes and the primitive type classes when deciding how \nto perform the cast, so I'm not sure it needs to do that anymore.  <shrug>\nI've removed that code without ill effect.\n\nI have the MyMethod class as a static member of the FunctionObject class -- you \nmay wish to change that.  You'll need to change some constants in the case.  \nI've run the rhino regression suite and mozilla DOM tests, and they seem happy \nwith this change....\n\nCode for MyMethod (note, requires org.mozilla.classfile.* classes):\n    public abstract static class MyMethod\n    {\n        static int _classNumber = 0;\n        static Hashtable _myMethodHash = new Hashtable();\n        static JavaAdapter.MyClassLoader _classLoader = new \nJavaAdapter.MyClassLoader();\n            \n        public static MyMethod initializeMyMethod(Method method, Class[] types)\n        {\n            MyMethod result = (MyMethod)_myMethodHash.get(method);\n            \n            if ( result != null )\n                return result;\n                \n            int classNumber;\n            \n            synchronized(_myMethodHash)\n            {\n                classNumber = ++_classNumber;\n            }\n            \n            String className = \"js\" + classNumber;\n            ClassFileWriter cfw = new ClassFileWriter\n(className, \"org.mozilla.javascript.FunctionObject$MyMethod\", \"\");\n            cfw.setFlags((short)(ClassFileWriter.ACC_PUBLIC | \nClassFileWriter.ACC_FINAL));\n            \n            // Add our instantiator!\n            cfw.startMethod(\"<init>\", \"()V\", ClassFileWriter.ACC_PUBLIC);\n            cfw.add(ByteCode.ALOAD_0);\n            cfw.add\n(ByteCode.INVOKESPECIAL,\"org.mozilla.javascript.FunctionObject$MyMethod\",\n                    \"<init>\", \"()\", \"V\");\n            cfw.add(ByteCode.RETURN);\n            cfw.stopMethod((short)1, null); // one argument -- this???\n\n            // Add the invoke() method call\n            cfw.startMethod(\"invoke\", \"(Ljava/lang/Object;[Ljava/lang/Object;)\nLjava/lang/Object;\",\n                            (short)(ClassFileWriter.ACC_PUBLIC | \nClassFileWriter.ACC_FINAL));\n            \n            // If we return a primitive type, then do something special!\n            String declaringClassName = method.getDeclaringClass().getName\n().replace('.', '/');\n            Class returnType = method.getReturnType();\n            String invokeSpecial = null;\n            String invokeSpecialType = null;\n            boolean returnsVoid = false;\n            boolean returnsBoolean = false;\n            \n            if ( returnType.isPrimitive() )\n            {\n                if ( returnType == Boolean.TYPE )\n                {\n                    returnsBoolean = true;\n                    invokeSpecialType = \"(Z)\";\n                }\n                else if ( returnType == Void.TYPE )\n                {\n                    returnsVoid = true;\n                    invokeSpecialType = \"(V)\";\n                }\n                else if ( returnType == Integer.TYPE )\n                {\n                    cfw.add(ByteCode.NEW, invokeSpecial = \"java/lang/Integer\");\n                    cfw.add(ByteCode.DUP);\n                    invokeSpecialType = \"(I)\";\n                }\n                else if ( returnType == Long.TYPE )\n                {\n                    cfw.add(ByteCode.NEW, invokeSpecial = \"java/lang/Long\");\n                    cfw.add(ByteCode.DUP);\n                    invokeSpecialType = \"(J)\";\n                }\n                else if ( returnType == Short.TYPE )\n                {\n                    cfw.add(ByteCode.NEW, invokeSpecial = \"java/lang/Short\");\n                    cfw.add(ByteCode.DUP);\n                    invokeSpecialType = \"(S)\";\n                }\n                else if ( returnType == Float.TYPE )\n                {\n                    cfw.add(ByteCode.NEW, invokeSpecial = \"java/lang/Float\");\n                    cfw.add(ByteCode.DUP);\n                    invokeSpecialType = \"(F)\";\n                }\n                else if ( returnType == Double.TYPE )\n                {\n                    cfw.add(ByteCode.NEW, invokeSpecial = \"java/lang/Double\");\n                    cfw.add(ByteCode.DUP);\n                    invokeSpecialType = \"(D)\";\n                }\n                else if ( returnType == Byte.TYPE )\n                {\n                    cfw.add(ByteCode.NEW, invokeSpecial = \"java/lang/Byte\");\n                    cfw.add(ByteCode.DUP);\n                    invokeSpecialType = \"(B)\";\n                }\n                else if ( returnType == Character.TYPE )\n                {\n                    cfw.add(ByteCode.NEW, invokeSpecial \n= \"java/lang/Character\");\n                    cfw.add(ByteCode.DUP);\n                    invokeSpecialType = \"(C)\";\n                }\n            }\n            \n            // handle setup of call to virtual function (if calling non-static)\n            if ( !java.lang.reflect.Modifier.isStatic(method.getModifiers()) )\n            {\n                cfw.add(ByteCode.ALOAD_1);\n                cfw.add(ByteCode.CHECKCAST, declaringClassName);\n            }\n            \n            // Handle parameters!\n            StringBuffer params = new StringBuffer( 2 + ((types!=null)?(20 * \ntypes.length):0) );\n            \n            params.append(\"(\");\n            if ( types != null )\n            {\n                for(int i = 0; i < types.length; i++)\n                {\n                    Class type = types[i];\n\n                    cfw.add(ByteCode.ALOAD_2);\n                    \n                    if ( i <= 5) \n                    {\n                        cfw.add((byte) (ByteCode.ICONST_0 + i));\n                    }\n                    else if (i <= Byte.MAX_VALUE)\n                    {\n                        cfw.add(ByteCode.BIPUSH, i);\n                    }\n                    else if (i <= Short.MAX_VALUE)\n                    {\n                        cfw.add(ByteCode.SIPUSH, i);\n    \t            }\n    \t            else \n    \t            {\n    \t                cfw.addLoadConstant((int)i);\n    \t            }\n                    \n                    cfw.add(ByteCode.AALOAD);\n                    \n                    if ( type.isPrimitive() )\n                    {\n                        //Convert enclosed type back to primitive.\n                        \n                        if ( type == Boolean.TYPE )\n                        {\n                            cfw.add(ByteCode.CHECKCAST, \"java/lang/Boolean\");\n                            cfw.add\n(ByteCode.INVOKEVIRTUAL, \"java/lang/Boolean\", \"booleanValue\", \n                                    \"()\", \"Z\");\n                            params.append(\"Z\");\n                        }\n                        else if ( type == Integer.TYPE )\n                        {\n                            cfw.add(ByteCode.CHECKCAST, \"java/lang/Number\");\n                            cfw.add\n(ByteCode.INVOKEVIRTUAL, \"java/lang/Number\", \"intValue\", \n                                    \"()\", \"I\");\n                            params.append(\"I\");\n                        }\n                        else if ( type == Short.TYPE )\n                        {\n                            cfw.add(ByteCode.CHECKCAST, \"java/lang/Number\");\n                            cfw.add\n(ByteCode.INVOKEVIRTUAL, \"java/lang/Number\", \"shortValue\", \n                                    \"()\", \"S\");\n                            params.append(\"S\");\n                        }\n                        else if ( type == Character.TYPE )\n                        {\n                            cfw.add(ByteCode.CHECKCAST, \"java/lang/Character\");\n                            cfw.add\n(ByteCode.INVOKEVIRTUAL, \"java/lang/Character\", \"charValue\", \n                                    \"()\", \"C\");\n                            params.append(\"C\");\n                        }\n                        else if ( type == Double.TYPE )\n                        {\n                            cfw.add(ByteCode.CHECKCAST, \"java/lang/Number\");\n                            cfw.add\n(ByteCode.INVOKEVIRTUAL, \"java/lang/Number\", \"doubleValue\", \n                                    \"()\", \"D\");\n                            params.append(\"D\");\n                        }\n                        else if ( type == Float.TYPE )\n                        {\n                            cfw.add(ByteCode.CHECKCAST, \"java/lang/Number\");\n                            cfw.add\n(ByteCode.INVOKEVIRTUAL, \"java/lang/Number\", \"floatValue\", \n                                    \"()\", \"F\");\n                            params.append(\"F\");\n                        }\n                        else if ( type == Byte.TYPE )\n                        {\n                            cfw.add(ByteCode.CHECKCAST, \"java/lang/Byte\");\n                            cfw.add\n(ByteCode.INVOKEVIRTUAL, \"java/lang/Byte\", \"byteValue\", \n                                    \"()\", \"B\");\n                            params.append(\"B\");\n                        }\n                    }\n                    else\n                    {\n                        String typeName = type.getName().replace('.', '/');\n                        cfw.add(ByteCode.CHECKCAST, typeName);\n                        \n                        if ( !type.isArray() )\n                        {\n                            params.append('L');\n                        }\n                        params.append(typeName);\n                        \n                        if ( !type.isArray() )\n                        {\n                            params.append(';');\n                        }\n                    }\n                }\n            }\n            params.append(\")\");\n            \n            // Call actual function!\n            if ( !java.lang.reflect.Modifier.isStatic(method.getModifiers()) )\n            {\n                cfw.add(ByteCode.INVOKEVIRTUAL, declaringClassName, \nmethod.getName(), params.toString(),\n                        (invokeSpecialType!=null?invokeSpecialType.substring\n(1,2)\n                                                :returnType.isArray()?\nreturnType.getName().replace('.','/')\n                                                                    :\"L\".concat\n(returnType.getName().replace('.', '/').concat(\";\"))));\n            }\n            else\n            {\n                cfw.add(ByteCode.INVOKESTATIC, declaringClassName, \nmethod.getName(), params.toString(),\n                        (invokeSpecialType!=null?invokeSpecialType.substring\n(1,2)\n                                                :returnType.isArray()?\nreturnType.getName().replace('.','/')\n                                                                    :\"L\".concat\n(returnType.getName().replace('.', '/').concat(\";\"))));\n            }\n            \n            // Handle return value;\n            if ( returnsVoid )\n            {\n                cfw.add(ByteCode.ACONST_NULL);\n                cfw.add(ByteCode.ARETURN);\n            }\n            else if ( returnsBoolean )\n            {\n                // HACK\n                //check to see if true;\n                // '7' is the number of bytes of the ifeq<branch> plus \ngetstatic<TRUE> plus areturn instructions\n                cfw.add(ByteCode.IFEQ, 7);\n                cfw.add(ByteCode.GETSTATIC,\n                        \"java/lang/Boolean\",\n                                \"TRUE\",\n                                \"Ljava/lang/Boolean;\");\n                cfw.add(ByteCode.ARETURN);\n                cfw.add(ByteCode.GETSTATIC,\n                        \"java/lang/Boolean\",\n                                \"FALSE\",\n                                \"Ljava/lang/Boolean;\");\n                cfw.add(ByteCode.ARETURN);\n            }\n            else if ( invokeSpecial != null )\n            {\n                cfw.add(ByteCode.INVOKESPECIAL,\n                            invokeSpecial,\n                            \"<init>\", invokeSpecialType, \"V\");\n                cfw.add(ByteCode.ARETURN);\n            }\n            else\n            {\n                cfw.add(ByteCode.ARETURN);\n            }\n            cfw.stopMethod((short)3, null); // three arguments, including the \nthis pointer???\n            \n            // Add class to our classloader.\n            java.io.ByteArrayOutputStream bos = new \njava.io.ByteArrayOutputStream(550);\n            \n            try\n            {\n                cfw.write(bos);\n            }\n            catch (Throwable t)\n            {\n                t.printStackTrace();\n            }\n            \n            try\n            {\n                byte [] bytes = bos.toByteArray();\n                Class clazz = _classLoader.defineClass(className, bytes);\n                result = (MyMethod)clazz.newInstance();\n                \n    //System.out.println(\"Generated method delegate for: \" + method.getName() \n+ \" on \" + method.getDeclaringClass().getName() + \" :: \" + params.toString() \n+ \" :: \" + types);\n                _myMethodHash.put(method, result);\n            }\n            catch (Throwable t)\n            {\n                t.printStackTrace();\n            }\n\n            return result;\n        }\n        \n        public abstract Object invoke(Object that, Object [] args);\n    }",
    "hasPatch": true,
    "hasScreenshot": false,
    "id": "64788",
    "issuetypeClassified": "IMPROVEMENT",
    "issuetypeTracker": "RFE",
    "priority": "-- enhancement",
    "product": "Rhino",
    "project": "RHINO",
    "summary": "Make method invocation 10x faster with following code....",
    "systemSpecification": true,
    "version": "other"
}