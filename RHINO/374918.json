{
    "comments": [
        {
            "author": "szegedia@freemail.hu",
            "body": "Yep, it seems right -- ScriptRuntime.toObjectOrNull() should have a \"Scriptable scope\" parameter that it passes to ScriptRuntime.toObject() instead of defaulting to getTopCallScope(cx). Problem is, ScriptRuntime.toObjectOrNull() is called from no less than 18 locations, so reviewing the possible side-effects of the fix will take a while. Will ask Norris if he can comment on it...",
            "date": "20070515T17:44:29",
            "id": 0
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "Sorry to take a while to respond.\n\nI dug up the original change that introduced the topCallScope changes:\n\n--------\ndate: 2004/08/09 11:00:46;  author: igor%mir2.org;  state: Exp;  lines: +1 -4\nTop call scope tracking changes:\n\nSince E4X implementation needs to know the activation scope for tracking of default namespaces, previously an elaborated schema was added to set/restore the activation scope which relied on the fact that scrip and function with activation record should always call special entry/exit functions.\n\nBut that does not work for functions without activation records since they never call any special entry/exit pairs. So if application call such function directly, the function would not store its top scope anywhere and the E4X subsystem would not be able to get E4X library object.\n\nThe patch fixes with introduction of 2 functions, hasTopCall and doTopCall to ScriptRuntime and adding the following code prefix to each implementation of Callable.call that can start execution of script code:\n\n    public Object call(Context cx, Scriptable scope,\n                       Scriptable thisObj, Object[] args)\n        throws JavaScriptException\n    {\n// Prefix start\n        if (!ScriptRuntime.hasTopCall(cx)) {\n            return ScriptRuntime.doTopCall(this, cx, scope, thisObj, args);\n        }\n// Prefix end\n        ...\n\nIn this way there is always registered top scope during script execution and the previous elaborated schema became unnecessary so I reverted that part to almost pre-E4x state.\n----------\n\nThis change log brings up the question of whether changing ScriptRuntime.toObjectOrNull would break some of the E4X implementation. Frankly I don't know much about E4X so I can't comment. \n\nThe problem with the proposed change of using cx.lastInterpreterFrame.scope is\nthat it doesn't work for compiled mode. It's not clear, Attila, if you were intending to use lastInterpreterFrame or not. \n\nI frankly didn't intend for two sets of scopes initialized with initStandardObjects to ever be mixed in the same JS object graph. It's certainly non-ECMA since those objects are defined to be global by ECMA. What's the use case? ",
            "date": "20070523T20:27:22",
            "id": 1
        },
        {
            "author": "szegedia@freemail.hu",
            "body": "(In reply to comment #2)\n> The problem with the proposed change of using cx.lastInterpreterFrame.scope is\n> that it doesn't work for compiled mode. It's not clear, Attila, if you were\n> intending to use lastInterpreterFrame or not. \n\nNo - that's what the submitter of the bug proposed, but since that wouldn't work in compiled code I specifically intended to change the signature of toObjectOrNull() so it works uniformly regardless of execution mode.\n\n> \n> I frankly didn't intend for two sets of scopes initialized with\n> initStandardObjects to ever be mixed in the same JS object graph. It's\n> certainly non-ECMA since those objects are defined to be global by ECMA. What's\n> the use case? \n> \n\nNot sure. You're right in saying this is quite unintended use of the API, so we might want to avoid jumping the gun. Marc, can you provide us with a real-world use case for this?\n",
            "date": "20070523T20:58:01",
            "id": 2
        },
        {
            "author": "mguillemot@yahoo.fr",
            "body": "In HtmlUnit we simulate the browser(s) behaviour and in this case you have one scope per (html) page but one page can be accessed from an other one (for instance frames).\nThe provided unit case illustrates such a problem we had making the JavaScript generated by Google WebToolkit working with HtmlUnit.",
            "date": "20070524T06:57:12",
            "id": 3
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "This seems like an important case.\n\nAttila's approach should work, but it does look like a lot of plumbing to get\nall the scope values passed around appropriately. \n\nLooking at the E4X default namespace implementation, I see ScriptRuntime.setDefaultNamespace and searchDefaultNamespace. From reading this code I think the problem of multiple top-level scopes would affect this code as well.",
            "date": "20070524T15:26:50",
            "id": 4
        },
        {
            "author": "szegedia@freemail.hu",
            "body": "Just out of curiosity, anyone has any idea how does this work in browsers with cross-page scripting within a frame? I.e. Mark, how would typical browsers (I always have to smile at this, since I'm using a *very* nontypical one - Opera on Mac OS X :-) ) run a browser-adapted version of your above testcase?",
            "date": "20070524T17:30:59",
            "id": 5
        },
        {
            "author": "mguillemot@yahoo.fr",
            "body": "You mean how they handle the scopes? No idea but this is a current practice for js frameworks to play with these multiple scopes (even in Opera).\n\nWith multiple scopes I have an other issue with eval that I will first bring to the mailing list.",
            "date": "20070524T18:00:39",
            "id": 6
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "I took another look at this. I don't see any way to fix this short of redoing a lot of deep plumbing that also has impacts on E4X stuff I don't understand well. \n\nI think we should punt on this for the soon-to-be-released Rhino 1.6R6 and look at it again when we have more time to shake out bugs.",
            "date": "20070613T19:12:46",
            "id": 7
        },
        {
            "author": "mguillemot@yahoo.fr",
            "body": "Does the time come where you have \"more time to shake out bugs\"? ;-)",
            "date": "20071029T19:35:39",
            "id": 8
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "Created attachment 300079\njs1_7/regress/regress-414553.js\n\nProposed regression test",
            "date": "20080129T19:05:09",
            "id": 9
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "Comment on attachment 300079\njs1_7/regress/regress-414553.js\n\nAttached to wrong bug, sorry.",
            "date": "20080129T19:05:56",
            "id": 10
        },
        {
            "author": "djgredler@gmail.com",
            "body": "FYI, this appears to apply to Number.prototype, as well.",
            "date": "20080610T02:34:25",
            "id": 11
        },
        {
            "author": "mguillemot@yahoo.fr",
            "body": "Any progress on this issue? It seems that our workaround (a hack) doesn't work anymore with current Rhino from CVS, meaning that we'll have problem to benefit from the progress made in Rhino.",
            "date": "20080717T15:13:59",
            "id": 12
        },
        {
            "author": "mguillemot@yahoo.fr",
            "body": "Created attachment 338310\nPatch fixinig this bug in primitive prototype resolution\n\nThis patch fixes this bug and contains unit tests demonstrating it both in compiled and interpreted modes.\nI guess that other places than the ones fixed should make usage of the new methods to get object properties that correctly resolve primitive prototypes, but I'm not able to judge it.\nThe test suite junit-all causes a lot of error when I run it (with or without this patch), therefore I can't get any information from it.",
            "date": "20080912T14:11:08",
            "id": 13
        },
        {
            "author": "mguillemot@yahoo.fr",
            "body": "Can a Rhino committer apply this patch (if it considered as good) or post a comment (if there is a problem with it)?",
            "date": "20080925T15:41:48",
            "id": 14
        },
        {
            "author": "mguillemot@yahoo.fr",
            "body": "In fact the problem is more important than I found initially and my patch fixes only one case.\n\nFollowing example shows the problem:\n        final Context cx = ContextFactory.getGlobal().enterContext();\n        final Scriptable scope1 = cx.initStandardObjects();\n        final Scriptable scope2 = cx.initStandardObjects();\n\n        String scriptScope1 = \"String.prototype.foo = function() { return 'from 2'; }\\n\"\n            + \"var s2 = 's2';\\n\";\n\n        String scriptScope2 = \"var s2Foo = scope2.s2.foo();\\n\"\n            + \"if (s2Foo != 'from 2') throw 's2 got: ' + s2Foo;\\n\"; // fails\n\n        cx.evaluateString(scope2, scriptScope2, \"source2\", 1, null);\n\n        scope1.put(\"scope2\", scope1, scope2);\n\n        cx.evaluateString(scope1, scriptScope1, \"source1\", 1, null);\n\n        Context.exit();\n\nThe JS code fails because no function foo can be found in s2. My previous patch doesn't help here because the current scope when the function is called is still scope1.\n\nThis means that a String (or any primitive) can't be saved in a Slot just as java.lang.String but must be wrapped to save the (top?) scope of its creation.\n\nI can work on a patch for that, but I'd like first feedback from some Rhino committer.",
            "date": "20080926T08:22:17",
            "id": 15
        },
        {
            "author": "hannesw@gmail.com",
            "body": "Created attachment 347600\nJava test class\n\nAttaching a simplified version of your test code. As I expected, String and number prototypes are consistent across scopes when wrapped in JS objects via String() and Number constructors. So I guess a viable strategy for implementing cross-scope safety would be to introduce a mode where primitives are always wrapped in objects.",
            "date": "20081111T20:18:16",
            "id": 16
        },
        {
            "author": "mguillemot@yahoo.fr",
            "body": "Primitive aren't objects and therefore wrapping them in JS objects would introduce a lot of failures.\n\nYour test (in fact it's not a unit test) doesn't test exactly the same thing and only test for the default optimization level.\n\nIn fact the number of cases to handle is far higher than illustrated by this test: primitive have to be wrapped as well before to get assigned to a property, before to be transmitted as arg to a function, when returned by a function, in array constructor, in object constructor, ...\n\nI'll  attach the test cases with which I'm working.",
            "date": "20081112T09:03:24",
            "id": 17
        },
        {
            "author": "mguillemot@yahoo.fr",
            "body": "Created attachment 347736\nSet of unit tests illustrating different cases that need to be handle\n\nThe attached tests cover different cases where the scope need to be saved together with the primitive value.\n\nThe last 3 tests pass with current code base and are just here to ensure that modification to primitives don't break basic funtionalities.\n\nNote that it is important to consider special numbers 0 and 1 as they are handled differently than other values.",
            "date": "20081112T09:08:27",
            "id": 18
        },
        {
            "author": "mguillemot@yahoo.fr",
            "body": "Comment on attachment 338310\nPatch fixinig this bug in primitive prototype resolution\n\nobsolete because incomplete as explained in a previous comment",
            "date": "20081112T09:09:12",
            "id": 19
        },
        {
            "author": "szegedia@freemail.hu",
            "body": "Does everyone still agree that my original idea of modifying ScriptRuntime.toObjectOrNull signature to take a \"Scriptable topLevelScope\" argument, and then propagating the change through the code is the way to go?",
            "date": "20081112T10:03:40",
            "id": 20
        },
        {
            "author": "mguillemot@yahoo.fr",
            "body": "I don't agree. This was what I've done in a first time but this is not enough: you need to know which scope has to be taken and this is not necessarily the current one. To be more precise, it is not possible to know which scope it is if it hasn't be saved together with the primitive. Just think of a primitive that is placed as property of some object (or of the top scope) and that is used later but accessed from an other scope.\nThe attached tests handle this case too.",
            "date": "20081112T10:20:14",
            "id": 21
        },
        {
            "author": "mguillemot@yahoo.fr",
            "body": "Comment on attachment 347736\nSet of unit tests illustrating different cases that need to be handle\n\nOOPS, these requirements go far beyond what browsers do. Sorry. Marking as obsolete. More later.",
            "date": "20081112T13:13:35",
            "id": 22
        },
        {
            "author": "hannesw@gmail.com",
            "body": "Adding a ScriptRuntime.toObjectOrNull signature with a scope argument might be a good idea for itself for those cases where a scope is already available, which is the case in a few usages of that method, even if it doesn't fix this problem. \n\nAs for this bug, as Marc said it looks like we need to store the prototype reference (I think it's the prototype and not actually the scope that matters) with primitive values. It's rather obvious to me that the best way to do this is to always store numbers, strings and booleans using Rhino's NativeNumber, NativeString, and NativeBoolean wrapper classes. Primitives are converted to objects a lot anyway (each time you invoke a method on a string, for example), so primitives and their object counterparts really look and behave more like the same thing anyway. (I remember there was a time when primitives weren't converted to objects automatically when calling a method on them - can anybody remember what language version that was and if it still matters?)\n\nAs for the differences between primitives and object wrappers, the best way to handle this would probably be to use subclasses for one or the other, so the (JS) typeof or instanceof operators could look for that using a simple (Java) instanceof. Any other difference between primitives and object wrappers that we'd need to take care of?\n\nSince I guess storing prototype/parent scope info with each primitive would likely result in decreased performance and increased memory usage and most embeddings would not need it, I think it might be wise to implement this as Context feature which is disabled by default, but we can look at that when we have a working patch. It's also possible the spared conversion between primitives and object wrappers helps performance in real world scenarios.\n\nWhat do you think?",
            "date": "20081112T13:20:35",
            "id": 23
        },
        {
            "author": "szegedia@freemail.hu",
            "body": "(In reply to comment #24)\n> Adding a ScriptRuntime.toObjectOrNull signature with a scope argument might be\n> a good idea for itself for those cases where a scope is already available,\n> which is the case in a few usages of that method, even if it doesn't fix this\n> problem.\n\nRight.\n\n> As for this bug, as Marc said it looks like we need to store the prototype\n> reference (I think it's the prototype and not actually the scope that matters)\n> with primitive values. It's rather obvious to me that the best way to do this\n> is to always store numbers, strings and booleans using Rhino's NativeNumber,\n> NativeString, and NativeBoolean wrapper classes. Primitives are converted to\n> objects a lot anyway (each time you invoke a method on a string, for example),\n> so primitives and their object counterparts really look and behave more like\n> the same thing anyway. \n\nThey don't. Consider these examples:\n\nif(false) { ... }\nif(new Boolean(false)) { ... }\n\nif(\"\") { ... }\nif(new String(\"\")) { ... }\n\nif(0) { ... }\nif(new Number(0)) { ... }\n\n> Since I guess storing prototype/parent scope info with each primitive would\n> likely result in decreased performance and increased memory usage and most\n> embeddings would not need it, I think it might be wise to implement this as\n> Context feature which is disabled by default, but we can look at that when we\n> have a working patch. It's also possible the spared conversion between\n> primitives and object wrappers helps performance in real world scenarios.\n> \n> What do you think?\n\nI'm getting to a point where I'm feeling anxious about this whole thing. As an ol' rule of thumb, if the architectural complexity starts to look too hairy, that's usually a good indication we're heading in the wrong direction. And it starts to look hairy to me. \n\nMarc originally said the problem is that \"the protoype of a string primitive is always resolved to the one in the context's top call scope rather than to the one in the executing code's top scope.\" From my understanding of that problem statement, if the \"top scope of the executing code\" were always passed to the toObjectOrNull, instead of relying on a thread local (current context's current top level scope), that'd solve the problem by breaking the assumption that any scope that's active within a Context ultimately has getCurrentContext().getTopLevelScope() as its ancestor.\n\nThat's not the same as tracking the \"prototype of the primitive\". Note that this concept is actually not even well defined. A better defined one would be \"prototype of the corresponding object type for a primitive as per active scope at the point of the primitive creation\".\n\nWhich promptly raises another question: when is a primitive created?\nWhen is boolean literal true, or number 42 created? Does evaluation of an expression, i.e. (i == 42) result in a new instance of true/false being created, or does it return an intrinsic true/false value? The problem is that not every occurrence of a primitive value is a separate instance. You can't even really talk about primitive values being instances.\n\nFinally, The semantics of sharing objects between Contexts that use different global standard object instances is totally out of the ECMA spec, and if allowed, is completely implementation dependent. From point of view of the spec, these are two different programs. Therefore, if we want to embrace this, we need to make sure that we get it right and don't shoot ourselves in the foot (or make it easy for other people to do so).\n\nHonestly, I'm still fairly anxious about breaking the invarant stating that \"any scope that's active within a Context ultimately has getCurrentContext().getTopLevelScope() as its ancestor\". \n\nOn the mailing list, I suggested Marc to try a different solution using a shared scope for the frameset HTML, with all standard objects in it, and use separate scopes for individual frames, with each frame-scope setting the shared scope as its prototype. I believe that'd make his use case work, and we wouldn't need to change anything.",
            "date": "20081112T13:43:01",
            "id": 24
        },
        {
            "author": "mguillemot@yahoo.fr",
            "body": "Created attachment 347763\nPatch fixing primitive prototype problem as currently occuring in HtmlUnit\n\nHere is the smallest patch that:\n- illustrates 2 cases where Rhino behaviour is wrong\n- fixes these 2 cases passing a scope parameter to a new ScriptRuntime.toObjectOrNull method\n\nI haven't changed the methods calling ScriptRuntime.toObjectOrNull without scope parameter when my unit test doesn't show the need for it. This makes this patch smaller and should increase the chance that it gets applied quickly.",
            "date": "20081112T14:05:05",
            "id": 25
        },
        {
            "author": "mguillemot@yahoo.fr",
            "body": "I've followed a wrong way for a far too long time (in fact this bug is really too old). I apologize for the time you've lost trying to understand my incorrect requirements. I don't know at which point I've made a wrong test in my browser that gave me an incorrect understanding of the situation, but the fact is that the situation is far easier to handle than I feared (see comment#26).\n\nAttila was mostly right (not concerning frames and shared scope but this is an other point that I will answer on the mailing list): NO information about the \"origin\" scope needs to be saved, only the current top scope matters (which means that for the same variable x, x.foo may evaluate to different values depending on the scope where the call is performed).",
            "date": "20081112T14:17:10",
            "id": 26
        },
        {
            "author": "mguillemot@yahoo.fr",
            "body": "Last note: reworking the code base to use PrimitiveXxxx to store primitives (what is not needed, see previous comment), I had to perform different refactorings of Rhino code base. If there is interest for it, I can extract 2 patches that:\n- use a \"Stack\" object to hide the Object[] and double[] in Interpreter.java\n- add methods isPrimitiveXxxx() in ScriptRuntime and use them instead of direct instanceof tests\nI think that these changes make the code more readable, easier to debug and the first one can make work on \"death by double\" easier. Let me know if you would welcome such changes.",
            "date": "20081112T14:24:01",
            "id": 27
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "I've patched in the patch from #26. It seems like a fine change to make. I tweaked one part of the change to reduce copied code. The resulting change \npasses the regression tests. I'm fine with accepting this change; any objections from others?",
            "date": "20081112T16:29:02",
            "id": 28
        },
        {
            "author": "hannesw@gmail.com",
            "body": "Fine with me. One place that should also call the new ScriptRuntime.toObjectOrNull with scope argument is in FunctionObject.java at line 238. That code just changed to ignore the local scope variable in the fix to bug 461138 a few days ago.",
            "date": "20081112T18:59:14",
            "id": 29
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "(In reply to comment #30)\n> Fine with me. One place that should also call the new\n> ScriptRuntime.toObjectOrNull with scope argument is in FunctionObject.java at\n> line 238. That code just changed to ignore the local scope variable in the fix\n> to bug 461138 a few days ago.\n\nThanks, I made that change and reran the unit test for bug 461138 to ensure that  the fix didn't regress that issue.",
            "date": "20081112T22:16:11",
            "id": 30
        },
        {
            "author": "mguillemot@yahoo.fr",
            "body": "(In reply to comment #30)\n> Fine with me. One place that should also call the new\n> ScriptRuntime.toObjectOrNull with scope argument is in FunctionObject.java at\n> line 238. That code just changed to ignore the local scope variable in the fix\n> to bug 461138 a few days ago.\n\nHannes,\n\ncan you provide a unit test that shows the need for it? I thought too in a first time that changes needed to be made at many other places but as long as this need it not demonstrated by unit tests, I believe that it is better not to change it.",
            "date": "20081113T07:55:03",
            "id": 31
        },
        {
            "author": "hannesw@gmail.com",
            "body": "(In reply to comment #32)\n> (In reply to comment #30)\n> > Fine with me. One place that should also call the new\n> > ScriptRuntime.toObjectOrNull with scope argument is in FunctionObject.java at\n> > line 238. That code just changed to ignore the local scope variable in the fix\n> > to bug 461138 a few days ago.\n> \n> Hannes,\n> \n> can you provide a unit test that shows the need for it? I thought too in a\n> first time that changes needed to be made at many other places but as long as\n> this need it not demonstrated by unit tests, I believe that it is better not to\n> change it.\n\nNope, but using the new toObjectOrNull() signature just reestablishes the state before the fix for bug 461138 - calling toObject() with the available scope object as argument. So I think your argument works in the other direction - unless we have real evidence, we should go back to the behaviour we had for the past several years.",
            "date": "20081113T09:09:23",
            "id": 32
        },
        {
            "author": "mguillemot@yahoo.fr",
            "body": "The change is indeed needed, but invoking that it is the case because this is the behaviour that we had for the past several years is... hmm, not very constructive.\n\nThis is a very special case where a FunctionObject takes a Scriptable as parameter, gets invoked with a primitive and wants to look at properties of the prototype. No idea if this ever gets used.\n\nNo matter, this should be tested and fixed. Here is the test case showing the need for this:\n\n\tpublic static class MyObject extends ScriptableObject {\n        @Override\n\t\tpublic String getClassName()\n\t\t{\n\t\t\treturn \"MyObject\";\n\t\t}\n\t\t\n\t\tpublic Object readPropFoo(final Scriptable s) {\n\t\t\treturn ScriptableObject.getProperty(s, \"foo\");\n\t\t}\n\t}\n\n\t/**\n     * Test that FunctionObject use the right top scope to convert a primitive to an object\n     */\n    @Test\n    public void functionObjectPrimitiveToObject() throws Exception {\n    \tfinal String scriptScope2 = \"function f() { String.prototype.foo = 'from 2'; \\n\"\n            + \"var s2 = 's2';\\n\"\n            + \"var s2Foo = s2.foo;\\n\"\n            + \"var s2FooReadByFunction = myObject.readPropFoo(s2);\\n\"\n            + \"if (s2Foo != s2FooReadByFunction) throw 's2 got: ' + s2FooReadByFunction;\\n\"\n            + \"}\";\n\n        // define object with custom method\n        final MyObject myObject = new MyObject();\n        final String[] functionNames = { \"readPropFoo\" };\n        myObject.defineFunctionProperties(functionNames, MyObject.class, ScriptableObject.EMPTY);\n\n        final String scriptScope1 = \"String.prototype.foo = 'from 1'; scope2.f()\";\n        \n    \tfinal ContextAction action = new ContextAction()\n    \t{\n    \t\tpublic Object run(final Context cx)\n    \t\t{\n    \t        final Scriptable scope1 = cx.initStandardObjects(new MySimpleScriptableObject(\"scope1\"));\n    \t        final Scriptable scope2 = cx.initStandardObjects(new MySimpleScriptableObject(\"scope2\"));\n\n    \t        scope2.put(\"myObject\", scope2, myObject);\n    \t        cx.evaluateString(scope2, scriptScope2, \"source2\", 1, null);\n\n    \t        scope1.put(\"scope2\", scope1, scope2);\n\n    \t        return cx.evaluateString(scope1, scriptScope1, \"source1\", 1, null);\n    \t\t}\n    \t};\n    \tUtils.runWithAllOptimizationLevels(action);\n    }",
            "date": "20081113T09:57:04",
            "id": 33
        },
        {
            "author": "hannesw@gmail.com",
            "body": "Well, if your test backs my assumption i guess it's all the better. Thanks Marc!",
            "date": "20081113T10:37:43",
            "id": 34
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "Thanks, I added the extra unit test code and have submitted the change to the branch and CVS head.",
            "date": "20081113T15:31:45",
            "id": 35
        },
        {
            "author": "mguillemot@yahoo.fr",
            "body": "Cool!\n\n@Norris:\n- in comment #39 you write that \"The resulting change passes the regression tests\". How do you run the tests? For me there are still a large number of failing standard tests and this makes very difficult to know whether changes introduce regression or not. The build servers seems to have the same results as I have.\n\n- answers to comment #28?",
            "date": "20081113T15:46:11",
            "id": 36
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "(In reply to comment #37)\n> Cool!\n> \n> @Norris:\n> - in comment #39 you write that \"The resulting change passes the regression\n> tests\". How do you run the tests? For me there are still a large number of\n> failing standard tests and this makes very difficult to know whether changes\n> introduce regression or not. The build servers seems to have the same results\n> as I have.\n\nFirst, everything passes for me off of Rhino1_7R2_BRANCH. There are some failures on CVS HEAD due to problems introduced by the AST API. \n\nI'm running the tests using the approach in https://developer.mozilla.org/en/Running_the_Rhino_tests, and then running the JUnit tests from Eclipse. \n\nI just checked for new tests in mozilla/js/tests, and there were 16 new tests that fail. I'll update the skip list for these. I think you are right when you said in a separate thread that we should move to a list of tests to run rather than a list of tests to skip to avoid this problem.\n\n> \n> - answers to comment #28?\n\n- use a \"Stack\" object to hide the Object[] and double[] in Interpreter.java\n\nI'm worried that the performance of a stack object will be less than the direct reference to the array objects. \n\n- add methods isPrimitiveXxxx() in ScriptRuntime and use them instead of direct\ninstanceof tests\n\nAgain, worried about performance impacts, although less so than the first. I suppose a good JVM will inline the methods.",
            "date": "20081113T18:20:48",
            "id": 37
        },
        {
            "author": "mguillemot@yahoo.fr",
            "body": "Norris,\n\nI've tried to run the tests as you do and I didn't get any error either. I think that there is a major problem here and I have opened a special issue for that:\nhttps://bugzilla.mozilla.org/show_bug.cgi?id=464898\n\nConcerning the performance. I couldn't notice any significant difference while running all the tests locally with a version of Rhino that had not only these 2 changes, but that used new classes to save JavaScript primitives. It doesn't really surprise me: modern JVM are good enough to optimize execution of such code.\n\nWhat would be for you a sufficient proof that the performance is not impacted?",
            "date": "20081114T10:07:29",
            "id": 38
        },
        {
            "author": "djgredler@gmail.com",
            "body": "Thanks to Marc and all of the committers for looking into this!!",
            "date": "20081114T18:19:45",
            "id": 39
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "(In reply to comment #39)\n> Norris,\n> \n> I've tried to run the tests as you do and I didn't get any error either. I\n> think that there is a major problem here and I have opened a special issue for\n> that:\n> https://bugzilla.mozilla.org/show_bug.cgi?id=464898\n> \n> Concerning the performance. I couldn't notice any significant difference while\n> running all the tests locally with a version of Rhino that had not only these 2\n> changes, but that used new classes to save JavaScript primitives. It doesn't\n> really surprise me: modern JVM are good enough to optimize execution of such\n> code.\n> \n> What would be for you a sufficient proof that the performance is not impacted?\n\nI've been using the benchmarks from http://ejohn.org/projects/javascript-engine-speeds/ to test performance. If there's noticeable change in those, then I think we're fine. \n\nNote I'm normally not so persnickety about things, but the inner loop of the interpreter is a real hotspot, and even just adding code that pushes us over certain codesize limits can make Rhino interpreter 2X slower.",
            "date": "20081118T19:14:19",
            "id": 40
        },
        {
            "author": "mguillemot@yahoo.fr",
            "body": "(In reply to comment #41)\n> ...\n> I've been using the benchmarks from\n> http://ejohn.org/projects/javascript-engine-speeds/ to test performance. If\n> there's noticeable change in those, then I think we're fine. \n\nOk, I'll try it. Do you know where the whole sources of these tests can be downloaded at once? Many links are now broken.",
            "date": "20081119T08:31:06",
            "id": 41
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "Hmm. You're right that these benchmarks don't seem to be available anymore. I'll mail you a zip file of what I have saved.",
            "date": "20081119T13:45:03",
            "id": 42
        },
        {
            "author": "szegedia@freemail.hu",
            "body": "John Resig is subscribed to the Rhino mailing list -- maybe just ask him where did the tests go?",
            "date": "20081119T13:52:57",
            "id": 43
        },
        {
            "author": "mguillemot@yahoo.fr",
            "body": "I already mailed him this morning but no answer until now (in fact I think that he is subscribed to the bugzilla issues too).",
            "date": "20081119T13:59:51",
            "id": 44
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "I had just mailed him as well.",
            "date": "20081119T14:01:56",
            "id": 45
        }
    ],
    "component": "Core",
    "description": "User-Agent:       Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.2) Gecko/20060601 Firefox/2.0.0.2 (Ubuntu-edgy)\nBuild Identifier: \n\nthe protoype of a string primitive is always resolved to the one in the context's top call scope rather than to the one in the executing code's top scope.\n\nThe provided unit test illustrates the problem.\n\nI suppose that ScriptRuntime.toObjectOrNull shouldn't use getTopCallScope(cx) but look at cx.lastInterpreterFrame.scope. The change can't be done directly as CallFrame is a private class of Interpreter.\nIf it's ok to make changes like removing the private modifier of CallFrame I can look at providing a patch.\n\nReproducible: Always\n\nSteps to Reproduce:\npublic void testStringPrimitivePrototypeScope()\n{\n\tContext cx = Context.enter();\n\tScriptable scope1 = cx.initStandardObjects();\n\tScriptable scope2 = cx.initStandardObjects();\n\tString str2 = \"function f() { String.prototype.foo = 'from 2'; \\n\"\n\t\t+ \"var s1 = new String('s1');\\n\"\n\t\t+ \"if (s1.foo != 'from 2') throw 's1 got: ' + s1.foo;\\n\" // works\n\t\t+ \"var s2 = 's2';\\n\"\n\t\t+ \"if (s2.foo != 'from 2') throw 's2 got: ' + s2.foo;\\n\" // fails\n\t\t+ \"}\";\n\tcx.evaluateString(scope2, str2, \"source2\", 1, null);\n\t\n\tscope1.put(\"scope2\", scope1, scope2);\n\t\n\tString str1 = \"String.prototype.foo = 'from 1'; scope2.f()\";\n\tcx.evaluateString(scope1, str1, \"source1\", 1, null);\n\t\n\tContext.exit();\n}",
    "hasPatch": true,
    "hasScreenshot": false,
    "id": "374918",
    "issuetypeClassified": "BUG",
    "issuetypeTracker": "BUG",
    "priority": "-- major",
    "product": "Rhino",
    "project": "RHINO",
    "summary": "String primitive prototype wrongly resolved when used with many top scopes",
    "systemSpecification": false,
    "version": "other"
}