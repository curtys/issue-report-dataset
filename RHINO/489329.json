{
    "comments": [
        {
            "author": "rspeyer@gmail.com",
            "body": "Created attachment 373835\ninitial patch for Object.getPrototypeOf functionality",
            "date": "20090421T13:09:01",
            "id": 0
        },
        {
            "author": "rspeyer@gmail.com",
            "body": "Created attachment 376910\npatch for getPrototypeOf, keys, getPropertyNames and getPropertyDescriptor methods on Object\n\nNote, this attachment depends on the patch submitted for bug 492525",
            "date": "20090512T13:20:56",
            "id": 1
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "Comment on attachment 376910\npatch for getPrototypeOf, keys, getPropertyNames and getPropertyDescriptor methods on Object\n\n>diff --git a/src/org/mozilla/javascript/NativeObject.java b/src/org/mozilla/javascript/NativeObject.java\n>index 39f4dd3..49f00e5 100644\n>--- a/src/org/mozilla/javascript/NativeObject.java\n>+++ b/src/org/mozilla/javascript/NativeObject.java\n>@@ -71,6 +71,20 @@ public class NativeObject extends IdScriptableObject\n>     }\n> \n>     @Override\n>+    protected void fillConstructorProperties(IdFunctionObject ctor)\n>+    {\n>+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_getPrototypeOf,\n>+                \"getPrototypeOf\", 1);\n>+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_keys,\n>+                \"keys\", 1);\n>+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_getOwnPropertyNames,\n>+                \"getOwnPropertyNames\", 1);\n>+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_getOwnPropertyDescriptor,\n>+                \"getOwnPropertyDescriptor\", 2);\n>+        super.fillConstructorProperties(ctor);\n>+    }\n>+\n>+    @Override\n>     protected void initPrototypeId(int id)\n>     {\n>         String s;\n>@@ -256,6 +270,60 @@ public class NativeObject extends IdScriptableObject\n>               }\n>               return Undefined.instance;\n> \n>+          case ConstructorId_getPrototypeOf:\n>+              {\n>+                if (args.length < 1)\n>+                    return Undefined.instance;\n\nI think Object.getPrototypeOf() should throw the same error as Object.getPrototypeOf(undefined). Same for the other functions below.\n\n>+\n>+                Object arg = args[0];\n>+\n>+                if ( !(arg instanceof Scriptable) )\n>+                    throw ScriptRuntime.typeError1(\"msg.arg.not.object\", ScriptRuntime.toString(arg));\n\nSee comment below about error message. You can get the type of the argument by calling ScriptRuntime.typeof.\n\n>+\n>+                Scriptable obj = (Scriptable) arg;\n>+                return obj.getPrototype();\n>+              }\n>+          case ConstructorId_keys:\n>+              {\n>+                if (args.length < 1)\n>+                    return Undefined.instance;\n>+\n>+                Object arg = args[0];\n>+\n>+                if ( !(arg instanceof Scriptable) )\n>+                    throw ScriptRuntime.typeError1(\"msg.arg.not.object\", ScriptRuntime.toString(arg));\n>+\n>+                Scriptable obj = (Scriptable) arg;\n>+                return cx.newArray(scope, obj.getIds());\n\nUnfortunately getIds isn't quite right as far as the type of the elements:\n\njs> o = { a:3, \"1\":2 }\n[object Object]\njs> a = Object.keys(o)\na,1\njs> typeof a[1]\nnumber\n\nShould be string. Same for getOwnPropertyNames.\n\n>+              }\n>+          case ConstructorId_getOwnPropertyNames:\n>+              {\n>+                if (args.length < 1)\n>+                    return Undefined.instance;\n>+\n>+                Object arg = args[0];\n>+\n>+                if ( !(arg instanceof ScriptableObject) )\n>+                    throw ScriptRuntime.typeError1(\"msg.arg.not.object\", ScriptRuntime.toString(arg));\n>+\n>+                ScriptableObject obj = (ScriptableObject) arg;\n>+                return cx.newArray(scope, obj.getAllIds());\n>+              }\n>+          case ConstructorId_getOwnPropertyDescriptor:\n>+              {\n>+                if (args.length < 2)\n>+                    return Undefined.instance;\n\nNo, Object.getOwnPropertyDescriptor() is equivalent to Object.getOwnPropertyDescriptor(undefined, undefined)\n\n>+\n>+                Object arg = args[0];\n>+                if ( !(arg instanceof ScriptableObject) )\n>+                    throw ScriptRuntime.typeError1(\"msg.arg.not.object\", ScriptRuntime.toString(arg));\n>+                ScriptableObject obj = (ScriptableObject) arg;\n>+                String name = ScriptRuntime.toString(args[1]);\n>+\n>+                PropertyDescriptor desc = obj.getOwnPropertyDescriptor(name);\n>+                return desc == null ? Undefined.instance : desc.fromPropertyDescriptor();\n>+              }\n>+\n>           default:\n>             throw new IllegalArgumentException(String.valueOf(id));\n>         }\n>@@ -303,6 +371,11 @@ public class NativeObject extends IdScriptableObject\n>     }\n> \n>     private static final int\n>+        ConstructorId_getPrototypeOf = -1,\n>+        ConstructorId_keys = -2,\n>+        ConstructorId_getOwnPropertyNames = -3,\n>+        ConstructorId_getOwnPropertyDescriptor = -4,\n>+\n>         Id_constructor           = 1,\n>         Id_toString              = 2,\n>         Id_toLocaleString        = 3,\n>diff --git a/src/org/mozilla/javascript/PropertyDescriptor.java b/src/org/mozilla/javascript/PropertyDescriptor.java\n>new file mode 100644\n>index 0000000..3f5aaa9\n>--- /dev/null\n>+++ b/src/org/mozilla/javascript/PropertyDescriptor.java\n>@@ -0,0 +1,106 @@\n>+package org.mozilla.javascript;\n>+\n>+public class PropertyDescriptor implements Cloneable {\n>+  protected Boolean enumerable = null;\n>+  protected Boolean configurable = null;\n>+  private Object value = null;\n>+  private Boolean writable = null;\n>+  // TODO these two values might be mutable, is it still okay to clone?\n>+  private Callable getter = null; \n>+  private Callable setter = null;\n>+\n>+  public PropertyDescriptor enumerable(Boolean enumerable) {\n>+    PropertyDescriptor copy = this.copy();\n>+    copy.enumerable = enumerable;\n>+    return copy;\n>+  }\n>+  public PropertyDescriptor configurable(Boolean configurable) {\n>+    PropertyDescriptor copy = this.copy();\n>+    copy.configurable = configurable;\n>+    return copy;\n>+  }\n>+  public PropertyDescriptor value(Object value) {\n>+    if (this.isAccessorDescriptor()) \n>+      throw new UnsupportedOperationException(\"Cannot add value to an accessor property descriptor\");\n>+\n>+    PropertyDescriptor copy = this.copy();\n>+    copy.value = value;\n>+    return copy;\n>+  }\n>+  public PropertyDescriptor writable(Boolean writable) {\n>+    if (this.isAccessorDescriptor()) \n>+      throw new UnsupportedOperationException(\"Cannot add writable to an accessor property descriptor\");\n>+\n>+    PropertyDescriptor copy = this.copy();\n>+    copy.writable = writable;\n>+    return copy;\n>+  }\n>+  public PropertyDescriptor getter(Callable getter) {\n>+    if (this.isDataDescriptor()) \n>+      throw new UnsupportedOperationException(\"Cannot add getter to a data property descriptor\");\n>+\n>+    PropertyDescriptor copy = this.copy();\n>+    copy.getter = getter;\n>+    return copy;\n>+  }\n>+  public PropertyDescriptor setter(Callable setter) {\n>+    if (this.isDataDescriptor()) \n>+      throw new UnsupportedOperationException(\"Cannot add setter to a data property descriptor\");\n>+\n>+    PropertyDescriptor copy = this.copy();\n>+    copy.setter = setter;\n>+    return copy;\n>+  }\n>+\n>+  public boolean isEnumerable() {\n>+    return enumerable;\n>+  }\n>+  public boolean isConfigurable() {\n>+    return configurable;\n>+  }\n>+  public Object getValue() {\n>+    return this.value;\n>+  }\n>+  public boolean isWritable() {\n>+    return writable;\n>+  }\n>+  public Callable getGetter() {\n>+    return getter;\n>+  }\n>+  public Callable getSetter() {\n>+    return setter;\n>+  }\n>+\n>+  public boolean isDataDescriptor() {\n>+    return value != null || writable != null;\n>+  }\n>+  public boolean isAccessorDescriptor() {\n>+    return getter != null || setter != null;\n>+  }\n>+  public boolean isGenericDescriptor() {\n>+    return !isDataDescriptor() && !isAccessorDescriptor();\n>+  }\n>+\n>+  public NativeObject fromPropertyDescriptor() {\n>+    NativeObject obj = new NativeObject();\n>+    if (isDataDescriptor()) {\n>+      if (value != null) obj.defineProperty(\"value\", value, ScriptableObject.EMPTY);\n>+      if (writable != null) obj.defineProperty(\"writable\", writable, ScriptableObject.EMPTY);\n>+    } else if (isAccessorDescriptor()) {\n>+      if (getter != null) obj.defineProperty(\"get\", getter, ScriptableObject.EMPTY);\n>+      if (setter != null) obj.defineProperty(\"set\", setter, ScriptableObject.EMPTY);\n>+    }\n>+    if (enumerable != null) obj.defineProperty(\"enumerable\", enumerable, ScriptableObject.EMPTY);\n>+    if (configurable != null) obj.defineProperty(\"configurable\", configurable, ScriptableObject.EMPTY);\n>+    return obj;\n>+  }\n>+\n>+  private PropertyDescriptor copy() {\n>+    try {\n>+      return (PropertyDescriptor) this.clone();\n>+    } catch (CloneNotSupportedException ex) {\n>+      throw new RuntimeException(\"PropertyDescriptor does not support cloning\", ex);\n>+    }\n>+  }\n>+\n>+}\n>diff --git a/src/org/mozilla/javascript/ScriptableObject.java b/src/org/mozilla/javascript/ScriptableObject.java\n>index 0c96d6c..5065076 100644\n>--- a/src/org/mozilla/javascript/ScriptableObject.java\n>+++ b/src/org/mozilla/javascript/ScriptableObject.java\n>@@ -202,6 +202,14 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>             }\n>         }\n> \n>+        PropertyDescriptor getPropertyDescriptor() {\n>+          return new PropertyDescriptor().\n>+            value(value).\n>+            writable((attributes & READONLY) == 0).\n>+            enumerable((attributes & DONTENUM) == 0).\n>+            configurable((attributes & PERMANENT) == 0);\n\nI think this isn't the best approach, because the prototype and parent aren't set, for one:\n\njs> x = Object.getOwnPropertyDescriptor(o, \"a\")\njs: uncaught JavaScript runtime exception: TypeError: Cannot find default value for object.\njs> typeof x\nobject\njs> Object.getPrototypeOf(x)\nnull\n\nI think you should use Context.newObject to create a new empty object and then set the appropriate properties on it for all places where you create a PropertyDescriptor. I don't think you need the PropertyDescriptor class.\n\n>+        }\n>+\n>     }\n> \n>     private static final class GetterSlot extends Slot\n>@@ -215,6 +223,14 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>         {\n>             super(name, indexOrHash, attributes);\n>         }\n>+\n>+        PropertyDescriptor getPropertyDescriptor() {\n>+          return super.getPropertyDescriptor().\n>+            value(null).\n>+            writable(null).\n>+            getter((Callable) getter).\n>+            setter((Callable) setter);\n>+        }\n>     }\n> \n>     static void checkValidAttributes(int attributes)\n>@@ -2523,6 +2539,11 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>         }\n>     }\n> \n>+    protected PropertyDescriptor getOwnPropertyDescriptor(String name) {\n>+      Slot slot = getSlot(name, 0, SLOT_QUERY);\n>+      return (slot == null) ? null : slot.getPropertyDescriptor();\n>+    }\n>+\n>     // Methods and classes to implement java.util.Map interface\n> \n>     public int size() {\n>diff --git a/src/org/mozilla/javascript/resources/Messages.properties b/src/org/mozilla/javascript/resources/Messages.properties\n>index a80e6a5..9f51f2c 100644\n>--- a/src/org/mozilla/javascript/resources/Messages.properties\n>+++ b/src/org/mozilla/javascript/resources/Messages.properties\n>@@ -260,6 +260,9 @@ msg.bad.regexp.compile =\\\n>     Only one argument may be specified if the first argument to \\\n>     RegExp.prototype.compile is a RegExp object.\n> \n>+msg.arg.not.object =\\\n>+    Argument is not an object {0}.\n>+\n\nI think a better error message would be \"Object expected, had instead <type>\", and similar for the other new functions you're defining.\n\n> # Parser\n> msg.got.syntax.errors = \\\n>     Compilation produced {0} syntax errors.\n>diff --git a/testsrc/build.xml b/testsrc/build.xml\n>index b4bde34..c907f00 100644\n>--- a/testsrc/build.xml\n>+++ b/testsrc/build.xml\n>@@ -118,7 +118,7 @@\n>         <pathelement location=\"${test.jstests.jar}\"/>\n>       </classpath>\n>       <batchtest todir=\"build/test\">\n>-        <fileset dir=\"${test.classes}\" includes=\"**/tests/*Test.class\"/>\n>+        <fileset dir=\"${test.classes}\" includes=\"**/tests/**/*Test.class\"/>\n>         <fileset dir=\"${test.classes}\" includes=\"**/StandardTests.class\"/>\n>       </batchtest>\n>       <formatter type=\"xml\"/>\n>diff --git a/testsrc/doctests/480758.doctest b/testsrc/doctests/480758.doctest\n>index 675483a..3893400 100755\n>diff --git a/testsrc/doctests/object.getownpropertydescriptor.doctest b/testsrc/doctests/object.getownpropertydescriptor.doctest\n>new file mode 100644\n>index 0000000..8026267\n>--- /dev/null\n>+++ b/testsrc/doctests/object.getownpropertydescriptor.doctest\n>@@ -0,0 +1,41 @@\n>+js> Object.getOwnPropertyDescriptor;\n>+function getOwnPropertyDescriptor() { [native code for Object.getOwnPropertyDescriptor, arity=2] }\n>+js> Object.getOwnPropertyDescriptor() === undefined;\n>+true\n>+js> [undefined, null, true, 1, \"hello\"].forEach(function(val) {\n>+  >   try {\n>+  >     Object.getOwnPropertyDescriptor(val, 'p');\n>+  >     print(\"Object.getOwnPropertyDescriptor(\"+val+\", 'p') should have thrown a TypeError\");\n>+  >   } catch (e if e instanceof TypeError) {\n>+  >     // expected this\n>+  >   } catch (e) {\n>+  >     print(\"Object.getOwnPropertyDescriptor(\"+val+\", 'p') should have thrown a TypeError, but instead threw \"+e)\n>+  >   }\n>+  > })\n>+\n>+js> Object.getOwnPropertyDescriptor({}, 'p') === undefined;\n>+true\n>+\n>+js> var desc = Object.getOwnPropertyDescriptor({p:1}, 'p');\n>+js> desc.value\n>+1\n>+js> desc.writable\n>+true\n>+js> desc.enumerable\n>+true\n>+js> desc.configurable\n>+true\n>+\n>+js> var desc = Object.getOwnPropertyDescriptor({ get p() {}, set p() {} }, 'p');\n>+js> desc.value === undefined;\n>+true\n>+js> desc.writable === undefined;\n>+true\n>+js> desc.get.toSource()\n>+(function () {})\n>+js> desc.set.toSource()\n>+(function () {})\n>+js> desc.enumerable\n>+true\n>+js> desc.configurable\n>+true\n>diff --git a/testsrc/doctests/object.getownpropertynames.doctest b/testsrc/doctests/object.getownpropertynames.doctest\n>new file mode 100644\n>index 0000000..4fa5a64\n>--- /dev/null\n>+++ b/testsrc/doctests/object.getownpropertynames.doctest\n>@@ -0,0 +1,56 @@\n>+js> Object.getOwnPropertyNames;\n>+function getOwnPropertyNames() { [native code for Object.getOwnPropertyNames, arity=1] }\n>+js> Object.getOwnPropertyNames() === undefined;\n>+true\n>+js> [undefined, null, true, 1, \"hello\"].forEach(function(val) {\n>+  >   try {\n>+  >     Object.getOwnPropertyNames(val);\n>+  >     print(\"Object.getOwnPropertyNames(\"+val+\") should have thrown a TypeError\");\n>+  >   } catch (e if e instanceof TypeError) {\n>+  >     // this was expected\n>+  >   } catch (e) {\n>+  >     print(\"Object.getOwnPropertyNames(\"+val+\") should have thrown a TypeError, but instead threw \"+e)\n>+  >   }\n>+  > })\n>+\n>+js> Object.getOwnPropertyNames({}).toSource();\n>+[]\n>+js> Object.getOwnPropertyNames({a:2}).toSource();\n>+[\"a\"]\n>+js> Object.getOwnPropertyNames({a:1, b:2}).toSource();\n>+[\"a\", \"b\"]\n>+js> Object.getOwnPropertyNames({'a.b':1, 'c d':2}).toSource();\n>+[\"a.b\", \"c d\"]\n>+\n>+js> Object.getOwnPropertyNames([]).toSource();\n>+[\"length\"]\n>+js> Object.getOwnPropertyNames(['a', 'b', 'c']).toSource();\n>+[0, 1, 2, \"length\"]\n>+\n>+js> function UserDefined() { this.a = 1; this.b = 2 };\n>+js> var obj = new UserDefined()\n>+js> Object.getOwnPropertyNames(obj).toSource()\n>+[\"a\", \"b\"]\n>+\n>+js> UserDefined.prototype.c = 3;\n>+3\n>+js> Object.getOwnPropertyNames(obj).toSource()\n>+[\"a\", \"b\"]\n>+\n>+js> // test properties of result are enumerable\n>+js> for (var p in Object.getOwnPropertyNames({a:2, b:3})) print(p)\n>+0\n>+1\n>+\n>+js> // test that properties of result are writable\n>+js> var k = Object.getOwnPropertyNames({a:2, b:3});\n>+js> k[1] = 'c'; k.toSource();\n>+[\"a\", \"c\"]\n>+\n>+js> // test that properties of result are configurable\n>+js> var k = Object.getOwnPropertyNames({a:2, b:3})\n>+js> delete k[1];\n>+true\n>+js> k\n>+a,\n>+js> // TODO test that the attributes of the properties can be changed\n>diff --git a/testsrc/doctests/object.getprototypeof.doctest b/testsrc/doctests/object.getprototypeof.doctest\n>new file mode 100644\n>index 0000000..dcd797a\n>--- /dev/null\n>+++ b/testsrc/doctests/object.getprototypeof.doctest\n>@@ -0,0 +1,33 @@\n>+js> Object.getPrototypeOf;\n>+function getPrototypeOf() { [native code for Object.getPrototypeOf, arity=1] }\n>+\n>+js> // FIXME: not sure if this is correct behaviour, should we be expecting a TypeError here instead?\n>+js> Object.getPrototypeOf() === undefined;\n>+true\n>+\n>+js> var nonObjects = [undefined, null, true, 1, 'hello'];\n>+js> nonObjects.every(function(value) {\n>+  >   try {\n>+  >     Object.getPrototypeOf(value);\n>+  >     return false;\n>+  >   } catch (e if e instanceof TypeError) {\n>+  >     return true;\n>+  >   } catch (e) {\n>+  >     return false;\n>+  >   }\n>+  > });\n>+true\n>+\n>+js> [(function(){}), [], {}].every(function(obj) {\n>+  >   return Object.getPrototypeOf(obj) === obj.__proto__;\n>+  > });\n>+true\n>+\n>+js> function UserDefined() {}\n>+js> [Date, UserDefined].every(function(type) {\n>+  >   var instance;\n>+  >   eval('instance = new '+type.name);\n>+  >   return Object.getPrototypeOf(instance) === type.prototype;\n>+  > });\n>+true\n>+\n>diff --git a/testsrc/doctests/object.keys.doctest b/testsrc/doctests/object.keys.doctest\n>new file mode 100644\n>index 0000000..8c31399\n>--- /dev/null\n>+++ b/testsrc/doctests/object.keys.doctest\n>@@ -0,0 +1,56 @@\n>+js> Object.keys;\n>+function keys() { [native code for Object.keys, arity=1] }\n>+js> Object.keys() === undefined;\n>+true\n>+js> [undefined, null, true, 1, \"hello\"].forEach(function(val) {\n>+  >   try {\n>+  >     Object.keys(val);\n>+  >     print(\"Object.keys(\"+val+\") should have thrown a TypeError\");\n>+  >   } catch (e if e instanceof TypeError) {\n>+  >     // this was expected\n>+  >   } catch (e) {\n>+  >     print(\"Object.keys(\"+val+\") should have thrown a TypeError, but instead threw \"+e)\n>+  >   }\n>+  > })\n>+\n>+js> Object.keys({}).toSource();\n>+[]\n>+js> Object.keys({a:2}).toSource();\n>+[\"a\"]\n>+js> Object.keys({a:1, b:2}).toSource();\n>+[\"a\", \"b\"]\n>+js> Object.keys({'a.b':1, 'c d':2}).toSource();\n>+[\"a.b\", \"c d\"]\n>+\n>+js> Object.keys([]).toSource();\n>+[]\n>+js> Object.keys(['a', 'b', 'c']).toSource();\n>+[0, 1, 2]\n>+\n>+js> function UserDefined() { this.a = 1; this.b = 2 };\n>+js> var obj = new UserDefined()\n>+js> Object.keys(obj).toSource()\n>+[\"a\", \"b\"]\n>+\n>+js> UserDefined.prototype.c = 3;\n>+3\n>+js> Object.keys(obj).toSource()\n>+[\"a\", \"b\"]\n>+\n>+js> // test properties of result are enumerable\n>+js> for (var p in Object.keys({a:2, b:3})) print(p)\n>+0\n>+1\n>+\n>+js> // test that properties of result are writable\n>+js> var k = Object.keys({a:2, b:3});\n>+js> k[1] = 'c'; k.toSource();\n>+[\"a\", \"c\"]\n>+\n>+js> // test that properties of result are configurable\n>+js> var k = Object.keys({a:2, b:3})\n>+js> delete k[1];\n>+true\n>+js> k\n>+a,\n>+js> // TODO test that the attributes of the properties can be changed\n>diff --git a/testsrc/org/mozilla/javascript/tests/Evaluator.java b/testsrc/org/mozilla/javascript/tests/Evaluator.java\n>new file mode 100644\n>index 0000000..0876c41\n>--- /dev/null\n>+++ b/testsrc/org/mozilla/javascript/tests/Evaluator.java\n>@@ -0,0 +1,28 @@\n>+package org.mozilla.javascript.tests;\n>+import org.mozilla.javascript.*;\n>+import java.util.Collections;\n>+import java.util.Map;\n>+\n>+public class Evaluator {\n>+\n>+  public static Object eval(String source) {\n>+    return eval(source, Collections.EMPTY_MAP);\n>+  }\n>+\n>+  public static Object eval(String source, String id, Scriptable object) {\n>+    return eval(source, Collections.singletonMap(id, object));\n>+  }\n>+\n>+  public static Object eval(String source, Map<String, Scriptable> bindings) {\n>+    Context cx = ContextFactory.getGlobal().enterContext();\n>+    try {\n>+      Scriptable scope = cx.initStandardObjects();\n>+      for (String id : bindings.keySet()) {\n>+        scope.put(id, scope, bindings.get(id));\n>+      }\n>+      return cx.evaluateString(scope, source, \"source\", 1, null);\n>+    } finally {\n>+      Context.exit();\n>+    }\n>+  }\n>+}\n>diff --git a/testsrc/org/mozilla/javascript/tests/es5/ObjectGetOwnPropertyDescriptorTest.java b/testsrc/org/mozilla/javascript/tests/es5/ObjectGetOwnPropertyDescriptorTest.java\n>new file mode 100644\n>index 0000000..9eaf7a9\n>--- /dev/null\n>+++ b/testsrc/org/mozilla/javascript/tests/es5/ObjectGetOwnPropertyDescriptorTest.java\n>@@ -0,0 +1,32 @@\n>+/*\n>+ * Tests for the Object.getOwnPropertyDescriptor(obj, prop) method\n>+ */\n>+package org.mozilla.javascript.tests.es5;\n>+import org.mozilla.javascript.*;\n>+import static org.mozilla.javascript.tests.Evaluator.eval;\n>+import static org.junit.Assert.assertEquals;\n>+import org.junit.Test;\n>+\n>+public class ObjectGetOwnPropertyDescriptorTest {\n>+\n>+  @Test\n>+  public void testContentsOfPropertyDescriptorShouldReflectAttributesOfProperty() {\n>+    NativeObject descriptor;\n>+    NativeObject object = new NativeObject();\n>+    object.defineProperty(\"a\", \"1\", ScriptableObject.EMPTY);\n>+    object.defineProperty(\"b\", \"2\", ScriptableObject.DONTENUM | ScriptableObject.READONLY | ScriptableObject.PERMANENT);\n>+\n>+    descriptor = (NativeObject) eval(\"Object.getOwnPropertyDescriptor(obj, 'a')\", \"obj\", object);\n>+    assertEquals(\"1\",  descriptor.get(\"value\"));\n>+    assertEquals(true, descriptor.get(\"enumerable\"));\n>+    assertEquals(true, descriptor.get(\"writable\"));\n>+    assertEquals(true, descriptor.get(\"configurable\"));\n>+\n>+    descriptor = (NativeObject) eval(\"Object.getOwnPropertyDescriptor(obj, 'b')\", \"obj\", object);\n>+    assertEquals(\"2\",  descriptor.get(\"value\"));\n>+    assertEquals(false, descriptor.get(\"enumerable\"));\n>+    assertEquals(false, descriptor.get(\"writable\"));\n>+    assertEquals(false, descriptor.get(\"configurable\"));\n>+  }\n>+\n>+}\n>diff --git a/testsrc/org/mozilla/javascript/tests/es5/ObjectGetOwnPropertyNamesTest.java b/testsrc/org/mozilla/javascript/tests/es5/ObjectGetOwnPropertyNamesTest.java\n>new file mode 100644\n>index 0000000..3ba1f9d\n>--- /dev/null\n>+++ b/testsrc/org/mozilla/javascript/tests/es5/ObjectGetOwnPropertyNamesTest.java\n>@@ -0,0 +1,27 @@\n>+/*\n>+ * Tests for the Object.getOwnPropertyNames(obj) method\n>+ */\n>+package org.mozilla.javascript.tests.es5;\n>+import org.mozilla.javascript.*;\n>+import static org.mozilla.javascript.tests.Evaluator.eval;\n>+import static org.junit.Assert.assertEquals;\n>+import org.junit.Test;\n>+\n>+public class ObjectGetOwnPropertyNamesTest {\n>+\n>+  @Test\n>+  public void testShouldReturnAllPropertiesOfArg() {\n>+    NativeObject object = new NativeObject();\n>+    object.defineProperty(\"a\", \"1\", ScriptableObject.EMPTY);\n>+    object.defineProperty(\"b\", \"2\", ScriptableObject.DONTENUM);\n>+\n>+    Object result = eval(\"Object.getOwnPropertyNames(obj)\", \"obj\", object);\n>+\n>+    NativeArray names = (NativeArray) result;\n>+\n>+    assertEquals(2, names.getLength());\n>+    assertEquals(\"a\", names.get(0, names));\n>+    assertEquals(\"b\", names.get(1, names));\n>+  }\n>+\n>+}\n>diff --git a/testsrc/org/mozilla/javascript/tests/es5/ObjectKeysTest.java b/testsrc/org/mozilla/javascript/tests/es5/ObjectKeysTest.java\n>new file mode 100644\n>index 0000000..9584c9f\n>--- /dev/null\n>+++ b/testsrc/org/mozilla/javascript/tests/es5/ObjectKeysTest.java\n>@@ -0,0 +1,28 @@\n>+/*\n>+ * Tests for the Object.keys(obj) method\n>+ */\n>+package org.mozilla.javascript.tests.es5;\n>+import org.mozilla.javascript.*;\n>+import static org.mozilla.javascript.tests.Evaluator.eval;\n>+import static org.junit.Assert.assertEquals;\n>+import org.junit.Test;\n>+\n>+public class ObjectKeysTest {\n>+\n>+  @Test\n>+  public void shouldReturnOnlyEnumerablePropertiesOfArg() {\n>+    NativeObject object = new NativeObject();\n>+    object.defineProperty(\"a\", \"1\", ScriptableObject.EMPTY);\n>+    object.defineProperty(\"b\", \"2\", ScriptableObject.EMPTY);\n>+    object.defineProperty(\"c\", \"3\", ScriptableObject.DONTENUM);\n>+\n>+    Object result = eval(\"Object.keys(obj)\", \"obj\", object);\n>+\n>+    NativeArray keys = (NativeArray) result;\n>+\n>+    assertEquals(2, keys.getLength());\n>+    assertEquals(\"a\", keys.get(0, keys));\n>+    assertEquals(\"b\", keys.get(1, keys));\n>+  }\n>+\n>+}\n>diff --git a/testsrc/org/mozilla/javascript/tests/es5/PropertyDescriptorTest.java b/testsrc/org/mozilla/javascript/tests/es5/PropertyDescriptorTest.java\n>new file mode 100644\n>index 0000000..15f767a\n>--- /dev/null\n>+++ b/testsrc/org/mozilla/javascript/tests/es5/PropertyDescriptorTest.java\n>@@ -0,0 +1,120 @@\n>+package org.mozilla.javascript.tests.es5;\n>+\n>+import org.mozilla.javascript.*;\n>+import java.util.Arrays;\n>+import static org.junit.Assert.assertEquals;\n>+import static org.junit.Assert.assertTrue;\n>+import static org.junit.Assert.assertFalse;\n>+import static org.junit.Assert.fail;\n>+import org.junit.Test;\n>+\n>+public class PropertyDescriptorTest {\n>+  private final PropertyDescriptor blank = new PropertyDescriptor();\n>+  private final Callable getter = new StubCallable();\n>+  private final Callable setter = new StubCallable();\n>+\n>+  @Test\n>+  public void shouldInitializeDataDescriptorThroughBuilderMethods() {\n>+    PropertyDescriptor desc = blank.value(\"a\").enumerable(true).writable(true).configurable(true);\n>+    assertEquals(\"a\", desc.getValue());\n>+    assertEquals(true, desc.isEnumerable());\n>+    assertEquals(true, desc.isWritable());\n>+    assertEquals(true, desc.isConfigurable());\n>+  }\n>+\n>+  @Test\n>+  public void shouldInitialiseAccessorDescriptorThroughBuilderMethods() {\n>+    PropertyDescriptor desc = blank.getter(getter).setter(setter).enumerable(true).configurable(true);\n>+    assertEquals(getter, desc.getGetter());\n>+    assertEquals(setter, desc.getSetter());\n>+    assertEquals(true, desc.isEnumerable());\n>+    assertEquals(true, desc.isConfigurable());\n>+  }\n>+\n>+  @Test(expected = UnsupportedOperationException.class)\n>+  public void shouldNotAllowGetterBeSetOnceValueHasBeenSet() {\n>+    blank.value(\"a\").getter(getter);\n>+  }\n>+  @Test(expected = UnsupportedOperationException.class)\n>+  public void shouldNotAllowGetterToBeSetOnceWritableHasBeenSet() {\n>+    blank.writable(true).getter(getter);\n>+  }\n>+  @Test(expected = UnsupportedOperationException.class)\n>+  public void shouldNotAllowSetterBeSetOnceValueHasBeenSet() {\n>+    blank.value(\"a\").setter(setter);\n>+  }\n>+  @Test(expected = UnsupportedOperationException.class)\n>+  public void shouldNotAllowSetterToBeSetOnceWritableHasBeenSet() {\n>+    blank.writable(true).setter(setter);\n>+  }\n>+\n>+  @Test(expected = UnsupportedOperationException.class)\n>+  public void shouldNotAllowValueToBeSetOnceGetterHasBeenSet() {\n>+    blank.getter(getter).value(\"a\");\n>+  }\n>+  @Test(expected = UnsupportedOperationException.class)\n>+  public void shouldNotAllowWritableToBeSetOnceGetterHasBeenSet() {\n>+    blank.getter(getter).writable(true);\n>+  }\n>+  @Test(expected = UnsupportedOperationException.class)\n>+  public void shouldNotAllowValueToBeSetOnceSetterHasBeenSet() {\n>+    blank.setter(setter).value(\"a\");\n>+  }\n>+  @Test(expected = UnsupportedOperationException.class)\n>+  public void shouldNotAllowWritableToBeSetOnceSetterHasBeenSet() {\n>+    blank.setter(setter).writable(true);\n>+  }\n>+\n>+  @Test\n>+  public void shouldBeDataDescriptorOnlyWhenValueOrWritableIsSet() {\n>+    assertFalse(blank.isDataDescriptor());\n>+    assertFalse(blank.enumerable(true).isDataDescriptor());\n>+    assertFalse(blank.configurable(true).isDataDescriptor());\n>+    assertFalse(blank.getter(getter).isDataDescriptor());\n>+    assertFalse(blank.setter(setter).isDataDescriptor());\n>+    assertTrue(blank.value(\"a\").isDataDescriptor());\n>+    assertTrue(blank.writable(true).isDataDescriptor());\n>+  }\n>+\n>+  @Test\n>+  public void shouldBeAccessorDescriptorOnlyWhenGetterOrSetterIsSet() {\n>+    assertFalse(blank.isAccessorDescriptor());\n>+    assertFalse(blank.enumerable(true).isAccessorDescriptor());\n>+    assertFalse(blank.configurable(true).isAccessorDescriptor());\n>+    assertFalse(blank.value(\"a\").isAccessorDescriptor());\n>+    assertFalse(blank.writable(true).isAccessorDescriptor());\n>+    assertTrue(blank.getter(getter).isAccessorDescriptor());\n>+    assertTrue(blank.setter(setter).isAccessorDescriptor());\n>+  }\n>+\n>+  @Test\n>+  public void shouldBeGenericDescriptorOnlyWhenNotDataOrAccessorDescriptor() {\n>+    assertTrue(blank.isGenericDescriptor());\n>+    assertTrue(blank.enumerable(true).isGenericDescriptor());\n>+    assertTrue(blank.configurable(true).isGenericDescriptor());\n>+    assertFalse(blank.value(\"a\").isGenericDescriptor());\n>+    assertFalse(blank.writable(true).isGenericDescriptor());\n>+    assertFalse(blank.getter(getter).isGenericDescriptor());\n>+    assertFalse(blank.setter(setter).isGenericDescriptor());\n>+  }\n>+\n>+  @Test\n>+  public void fromPropertyDescriptorShouldCreateValidObjectForDataDescriptor() {\n>+    NativeObject expected = new NativeObject();\n>+    expected.defineProperty(\"value\", Integer.valueOf(1), ScriptableObject.EMPTY);\n>+    expected.defineProperty(\"writable\", Boolean.TRUE, ScriptableObject.EMPTY);\n>+    expected.defineProperty(\"enumerable\", Boolean.TRUE, ScriptableObject.EMPTY);\n>+    expected.defineProperty(\"configurable\", Boolean.TRUE, ScriptableObject.EMPTY);\n>+\n>+    PropertyDescriptor desc = new PropertyDescriptor().value(1).writable(true).enumerable(true).configurable(true);\n>+    NativeObject actual = desc.fromPropertyDescriptor();\n>+\n>+    assertEquals(expected.entrySet(), actual.entrySet());\n>+  }\n>+\n>+  private static class StubCallable implements Callable {\n>+    public Object call(Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {\n>+      return null;\n>+    }\n>+  }\n>+}",
            "date": "20090521T02:43:39",
            "id": 2
        },
        {
            "author": "rspeyer@gmail.com",
            "body": "Created attachment 379412\nupdated patch\n\n- replaced use of PropertyDescriptor with plain ScriptableObject's\n- made Object.keys and Object.getOwnPropertyNames return ids of type string, not number\n- changed error message for missing or wrong-typed arguments\n- changed Object constructor methods to throw type error if they do not receive enough arguments",
            "date": "20090524T09:01:44",
            "id": 3
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "Thanks for the update!\n\nI tried applying the patch but ran into conflicts, I think because I have committed changes for one of your bug fixes. Can you sync to CVS head and send me a new patch? If you were at CVS head let me know and I'll investigate further on my end.",
            "date": "20090525T02:27:41",
            "id": 4
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "I have it patched successfully now and it passed all regression tests. I'll review the code tomorrow.",
            "date": "20090527T02:26:59",
            "id": 5
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "Comment on attachment 379412\nupdated patch\n\n>diff --git a/src/org/mozilla/javascript/NativeObject.java b/src/org/mozilla/javascript/NativeObject.java\n>index 39f4dd3..bdc0673 100644\n>--- a/src/org/mozilla/javascript/NativeObject.java\n>+++ b/src/org/mozilla/javascript/NativeObject.java\n>@@ -71,6 +71,20 @@ public class NativeObject extends IdScriptableObject\n>     }\n> \n>     @Override\n>+    protected void fillConstructorProperties(IdFunctionObject ctor)\n>+    {\n>+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_getPrototypeOf,\n>+                \"getPrototypeOf\", 1);\n>+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_keys,\n>+                \"keys\", 1);\n>+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_getOwnPropertyNames,\n>+                \"getOwnPropertyNames\", 1);\n>+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_getOwnPropertyDescriptor,\n>+                \"getOwnPropertyDescriptor\", 2);\n>+        super.fillConstructorProperties(ctor);\n>+    }\n>+\n>+    @Override\n>     protected void initPrototypeId(int id)\n>     {\n>         String s;\n>@@ -256,6 +270,66 @@ public class NativeObject extends IdScriptableObject\n>               }\n>               return Undefined.instance;\n> \n>+          case ConstructorId_getPrototypeOf:\n>+              {\n>+                if (args.length < 1)\n>+                    throw ScriptRuntime.typeError1(\"msg.arg.not.object\", ScriptRuntime.typeof(Undefined.instance));\n>+\n>+                Object arg = args[0];\n>+\n>+                if ( !(arg instanceof Scriptable) )\n>+                    throw ScriptRuntime.typeError1(\"msg.arg.not.object\", ScriptRuntime.typeof(arg));\n>+\n>+                Scriptable obj = (Scriptable) arg;\n>+                return obj.getPrototype();\n>+              }\n>+          case ConstructorId_keys:\n>+              {\n\nHow about \n\nObject arg = args.length < 1 ? Undefined.instance : args[0];\n\nto replace through the declaration of \"Object arg\" below?\n\n>+                if (args.length < 1)\n>+                    throw ScriptRuntime.typeError1(\"msg.arg.not.object\", ScriptRuntime.typeof(Undefined.instance));\n>+\n>+                Object arg = args[0];\n>+\n>+                if ( !(arg instanceof Scriptable) )\n>+                    throw ScriptRuntime.typeError1(\"msg.arg.not.object\", ScriptRuntime.typeof(arg));\n>+\n>+                Object[] ids = ((Scriptable) arg).getIds();\n>+                for (int i = 0; i < ids.length; i += 1) {\n\nJust use i++\n\n>+                  ids[i] = ScriptRuntime.toString(ids[i]);\n>+                }\n>+                return cx.newArray(scope, ids);\n>+              }\n>+          case ConstructorId_getOwnPropertyNames:\n>+              {\n>+                if (args.length < 1)\n>+                    throw ScriptRuntime.typeError1(\"msg.arg.not.object\", ScriptRuntime.typeof(Undefined.instance));\n>+\n>+                Object arg = args[0];\n>+\n>+                if ( !(arg instanceof ScriptableObject) )\n>+                    throw ScriptRuntime.typeError1(\"msg.arg.not.object\", ScriptRuntime.typeof(arg));\n>+\n>+                Object[] ids = ((ScriptableObject) arg).getAllIds();\n>+                for (int i = 0; i < ids.length; i += 1) {\n>+                  ids[i] = ScriptRuntime.toString(ids[i]);\n>+                }\n>+                return cx.newArray(scope, ids);\n>+              }\n>+          case ConstructorId_getOwnPropertyDescriptor:\n>+              {\n>+                if (args.length < 2)\n>+                    throw ScriptRuntime.typeError1(\"msg.arg.not.object\", ScriptRuntime.typeof(Undefined.instance));\n\nThe second parameter can be any type as long as it can be converted to string, right? In fact, as an edge case, I think you could have a property named \"undefined\" that you could get the property descriptor for by calling Object.getOwnPropertyDescriptor(obj).\n\n>+\n>+                Object arg = args[0];\n>+                if ( !(arg instanceof ScriptableObject) )\n>+                    throw ScriptRuntime.typeError1(\"msg.arg.not.object\", ScriptRuntime.typeof(arg));\n>+                ScriptableObject obj = (ScriptableObject) arg;\n>+                String name = ScriptRuntime.toString(args[1]);\n>+\n>+                Scriptable desc = obj.getOwnPropertyDescriptor(cx, name);\n>+                return desc == null ? Undefined.instance : desc;\n>+              }\n>+\n>           default:\n>             throw new IllegalArgumentException(String.valueOf(id));\n>         }\n>@@ -303,6 +377,11 @@ public class NativeObject extends IdScriptableObject\n>     }\n> \n>     private static final int\n>+        ConstructorId_getPrototypeOf = -1,\n>+        ConstructorId_keys = -2,\n>+        ConstructorId_getOwnPropertyNames = -3,\n>+        ConstructorId_getOwnPropertyDescriptor = -4,\n>+\n>         Id_constructor           = 1,\n>         Id_toString              = 2,\n>         Id_toLocaleString        = 3,\n>diff --git a/src/org/mozilla/javascript/ScriptableObject.java b/src/org/mozilla/javascript/ScriptableObject.java\n>index 38bec1d..68f6e2f 100644\n>--- a/src/org/mozilla/javascript/ScriptableObject.java\n>+++ b/src/org/mozilla/javascript/ScriptableObject.java\n>@@ -202,6 +202,15 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>             }\n>         }\n> \n>+        ScriptableObject getPropertyDescriptor(Context cx, Scriptable parent) {\n\ns/parent/scope/. This is where the \"Object\" constructor is looked up.\n\n>+          ScriptableObject desc = (ScriptableObject) cx.newObject(parent);\n\nI steered you wrong before in suggesting you call this. The 8.10.4 #2 says \"Let obj be the result of creating a new object as if by the expression new Object() where Object is the standard built-in constructor with that name.\" This code would allow someone to intercept that call by redefining \"Object\" in the global scope. Instead you should use\n\n        ScriptableObject desc = new NativeObject();\n        ScriptRuntime.setObjectProtoAndParent(desc, scope);\n\n>+          if (value != null) desc.defineProperty(\"value\", value, EMPTY);\n>+          desc.defineProperty(\"writable\",     (attributes & READONLY) == 0, EMPTY);\n>+          desc.defineProperty(\"enumerable\",   (attributes & DONTENUM) == 0, EMPTY);\n>+          desc.defineProperty(\"configurable\", (attributes & PERMANENT) == 0, EMPTY);\n>+          return desc;\n>+        }\n>+\n>     }\n> \n>     private static final class GetterSlot extends Slot\n>@@ -215,6 +224,16 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>         {\n>             super(name, indexOrHash, attributes);\n>         }\n>+\n>+        @Override\n>+        ScriptableObject getPropertyDescriptor(Context cx, Scriptable parent) {\n>+          ScriptableObject desc = super.getPropertyDescriptor(cx, parent);\n>+          desc.delete(\"value\");\n>+          desc.delete(\"writable\");\n>+          if (getter != null) desc.defineProperty(\"get\", getter, EMPTY);\n>+          if (setter != null) desc.defineProperty(\"set\", setter, EMPTY);\n>+          return desc;\n>+        }\n>     }\n> \n>     static void checkValidAttributes(int attributes)\n>@@ -2523,6 +2542,11 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>         }\n>     }\n> \n>+    protected ScriptableObject getOwnPropertyDescriptor(Context cx, String name) {\n>+      Slot slot = getSlot(name, 0, SLOT_QUERY);\n>+      return (slot == null) ? null : slot.getPropertyDescriptor(cx, getParentScope());\n>+    }\n>+\n>     // Methods and classes to implement java.util.Map interface\n> \n>     public int size() {\n>diff --git a/src/org/mozilla/javascript/resources/Messages.properties b/src/org/mozilla/javascript/resources/Messages.properties\n>index a80e6a5..545dc87 100644\n>--- a/src/org/mozilla/javascript/resources/Messages.properties\n>+++ b/src/org/mozilla/javascript/resources/Messages.properties\n>@@ -260,6 +260,9 @@ msg.bad.regexp.compile =\\\n>     Only one argument may be specified if the first argument to \\\n>     RegExp.prototype.compile is a RegExp object.\n> \n>+msg.arg.not.object =\\\n>+    Expected argument of type object, but instead had type {0}\n>+\n> # Parser\n> msg.got.syntax.errors = \\\n>     Compilation produced {0} syntax errors.\n>diff --git a/testsrc/doctests/object.getownpropertydescriptor.doctest b/testsrc/doctests/object.getownpropertydescriptor.doctest\n>new file mode 100644\n>index 0000000..8a2cb8a\n>--- /dev/null\n>+++ b/testsrc/doctests/object.getownpropertydescriptor.doctest\n>@@ -0,0 +1,43 @@\n>+js> load('testsrc/doctests/util.js');\n>+\n>+js> Object.getOwnPropertyDescriptor;\n>+function getOwnPropertyDescriptor() { [native code for Object.getOwnPropertyDescriptor, arity=2] }\n>+\n>+js> expectTypeError(function() { Object.getOwnPropertyDescriptor() })\n>+js> expectTypeError(function() { Object.getOwnPropertyDescriptor({}) })\n>+\n>+js> [undefined, null, true, 1, 'hello'].forEach(function(value) { \n>+  >   expectTypeError(function() { Object.getOwnPropertyDescriptor(value, 'p') }) \n>+  > })\n>+\n>+js> Object.getOwnPropertyDescriptor({}, 'p') === undefined;\n>+true\n>+\n>+js> var desc = Object.getOwnPropertyDescriptor({p:1}, 'p');\n>+js> desc.value\n>+1\n>+js> desc.writable\n>+true\n>+js> desc.enumerable\n>+true\n>+js> desc.configurable\n>+true\n>+\n>+js> var desc = Object.getOwnPropertyDescriptor({ get p() {}, set p() {} }, 'p');\n>+js> desc.value === undefined;\n>+true\n>+js> desc.writable === undefined;\n>+true\n>+js> desc.get.toSource()\n>+(function () {})\n>+js> desc.set.toSource()\n>+(function () {})\n>+js> desc.enumerable\n>+true\n>+js> desc.configurable\n>+true\n>+\n>+js> desc.__proto__ === Object.prototype\n>+true\n>+js> desc.__parent__;\n>+[object global]\n>diff --git a/testsrc/doctests/object.getownpropertynames.doctest b/testsrc/doctests/object.getownpropertynames.doctest\n>new file mode 100644\n>index 0000000..ddf91db\n>--- /dev/null\n>+++ b/testsrc/doctests/object.getownpropertynames.doctest\n>@@ -0,0 +1,55 @@\n>+js> load('testsrc/doctests/util.js');\n>+\n>+js> Object.getOwnPropertyNames;\n>+function getOwnPropertyNames() { [native code for Object.getOwnPropertyNames, arity=1] }\n>+\n>+js> expectTypeError(function() { Object.getOwnPropertyNames() })\n>+js> [undefined, null, true, 1, 'hello'].forEach(function(value) { \n>+  >   expectTypeError(function() { Object.getOwnPropertyNames(value) }) \n>+  > })\n>+\n>+js> Object.getOwnPropertyNames({}).toSource();\n>+[]\n>+js> Object.getOwnPropertyNames({a:2}).toSource();\n>+[\"a\"]\n>+js> Object.getOwnPropertyNames({a:1, b:2}).toSource();\n>+[\"a\", \"b\"]\n>+js> Object.getOwnPropertyNames({'a.b':1, 'c d':2}).toSource();\n>+[\"a.b\", \"c d\"]\n>+\n>+js> Object.getOwnPropertyNames([]).toSource();\n>+[\"length\"]\n>+js> Object.getOwnPropertyNames(['a', 'b', 'c']).toSource();\n>+[\"0\", \"1\", \"2\", \"length\"]\n>+\n>+js> function UserDefined() { this.a = 1; this.b = 2 };\n>+js> var obj = new UserDefined()\n>+js> Object.getOwnPropertyNames(obj).toSource()\n>+[\"a\", \"b\"]\n>+\n>+js> UserDefined.prototype.c = 3;\n>+3\n>+js> Object.getOwnPropertyNames(obj).toSource()\n>+[\"a\", \"b\"]\n>+\n>+js> // test properties of result are enumerable\n>+js> for (var p in Object.getOwnPropertyNames({a:2, b:3})) print(p)\n>+0\n>+1\n>+\n>+js> // test that properties of result are writable\n>+js> var k = Object.getOwnPropertyNames({a:2, b:3});\n>+js> k[1] = 'c'; k.toSource();\n>+[\"a\", \"c\"]\n>+\n>+js> // test that properties of result are configurable\n>+js> var k = Object.getOwnPropertyNames({a:2, b:3})\n>+js> delete k[1];\n>+true\n>+js> k\n>+a,\n>+js> // TODO test that the attributes of the properties can be changed\n>+\n>+js> var k = Object.getOwnPropertyNames({a:2, 5:6})\n>+js> typeof k[1]\n>+string\n>diff --git a/testsrc/doctests/object.getprototypeof.doctest b/testsrc/doctests/object.getprototypeof.doctest\n>new file mode 100644\n>index 0000000..5514e14\n>--- /dev/null\n>+++ b/testsrc/doctests/object.getprototypeof.doctest\n>@@ -0,0 +1,23 @@\n>+js> load('testsrc/doctests/util.js');\n>+\n>+js> Object.getPrototypeOf;\n>+function getPrototypeOf() { [native code for Object.getPrototypeOf, arity=1] }\n>+\n>+js> expectTypeError(function() { Object.getPrototypeOf() })\n>+js> [undefined, null, true, 1, 'hello'].forEach(function(value) { \n>+  >   expectTypeError(function() { Object.getPrototypeOf(value) }) \n>+  > })\n>+\n>+js> [(function(){}), [], {}].every(function(obj) {\n>+  >   return Object.getPrototypeOf(obj) === obj.__proto__;\n>+  > });\n>+true\n>+\n>+js> function UserDefined() {}\n>+js> [Date, UserDefined].every(function(type) {\n>+  >   var instance;\n>+  >   eval('instance = new '+type.name);\n>+  >   return Object.getPrototypeOf(instance) === type.prototype;\n>+  > });\n>+true\n>+\n>diff --git a/testsrc/doctests/object.keys.doctest b/testsrc/doctests/object.keys.doctest\n>new file mode 100644\n>index 0000000..e9aef8e\n>--- /dev/null\n>+++ b/testsrc/doctests/object.keys.doctest\n>@@ -0,0 +1,55 @@\n>+js> load('testsrc/doctests/util.js');\n>+\n>+js> Object.keys;\n>+function keys() { [native code for Object.keys, arity=1] }\n>+\n>+js> expectTypeError(function() { Object.keys() })\n>+js> [undefined, null, true, 1, 'hello'].forEach(function(value) { \n>+  >   expectTypeError(function() { Object.keys(value) }) \n>+  > })\n>+\n>+js> Object.keys({}).toSource();\n>+[]\n>+js> Object.keys({a:2}).toSource();\n>+[\"a\"]\n>+js> Object.keys({a:1, b:2}).toSource();\n>+[\"a\", \"b\"]\n>+js> Object.keys({'a.b':1, 'c d':2}).toSource();\n>+[\"a.b\", \"c d\"]\n>+\n>+js> Object.keys([]).toSource();\n>+[]\n>+js> Object.keys(['a', 'b', 'c']).toSource();\n>+[\"0\", \"1\", \"2\"]\n>+\n>+js> function UserDefined() { this.a = 1; this.b = 2 };\n>+js> var obj = new UserDefined()\n>+js> Object.keys(obj).toSource()\n>+[\"a\", \"b\"]\n>+\n>+js> UserDefined.prototype.c = 3;\n>+3\n>+js> Object.keys(obj).toSource()\n>+[\"a\", \"b\"]\n>+\n>+js> // test properties of result are enumerable\n>+js> for (var p in Object.keys({a:2, b:3})) print(p)\n>+0\n>+1\n>+\n>+js> // test that properties of result are writable\n>+js> var k = Object.keys({a:2, b:3});\n>+js> k[1] = 'c'; k.toSource();\n>+[\"a\", \"c\"]\n>+\n>+js> // test that properties of result are configurable\n>+js> var k = Object.keys({a:2, b:3})\n>+js> delete k[1];\n>+true\n>+js> k\n>+a,\n>+js> // TODO test that the attributes of the properties can be changed\n>+\n>+js> var k = Object.keys({ a:1, 3:2 });\n>+js> typeof k[1];\n>+string\n>diff --git a/testsrc/doctests/util.js b/testsrc/doctests/util.js\n>new file mode 100644\n>index 0000000..c17e4da\n>--- /dev/null\n>+++ b/testsrc/doctests/util.js\n>@@ -0,0 +1,8 @@\n>+function expectTypeError(code) {\n>+  try {\n>+    code();\n>+    throw (code.toSource() + ' should have thrown a TypeError');\n>+  } catch (e if e instanceof TypeError) {\n>+    // all good\n>+  }\n>+}\n>diff --git a/testsrc/org/mozilla/javascript/tests/Evaluator.java b/testsrc/org/mozilla/javascript/tests/Evaluator.java\n>new file mode 100644\n>index 0000000..491c0e7\n>--- /dev/null\n>+++ b/testsrc/org/mozilla/javascript/tests/Evaluator.java\n>@@ -0,0 +1,30 @@\n>+package org.mozilla.javascript.tests;\n>+import org.mozilla.javascript.*;\n>+import java.util.Collections;\n>+import java.util.Map;\n>+\n>+public class Evaluator {\n>+\n>+  public static Object eval(String source) {\n>+    return eval(source, Collections.EMPTY_MAP);\n>+  }\n>+\n>+  public static Object eval(String source, String id, Scriptable object) {\n>+    return eval(source, Collections.singletonMap(id, object));\n>+  }\n>+\n>+  public static Object eval(String source, Map<String, Scriptable> bindings) {\n>+    Context cx = ContextFactory.getGlobal().enterContext();\n>+    try {\n>+      Scriptable scope = cx.initStandardObjects();\n>+      for (String id : bindings.keySet()) {\n>+        Scriptable object = bindings.get(id);\n>+        object.setParentScope(scope);\n>+        scope.put(id, scope, object);\n>+      }\n>+      return cx.evaluateString(scope, source, \"source\", 1, null);\n>+    } finally {\n>+      Context.exit();\n>+    }\n>+  }\n>+}\n>diff --git a/testsrc/org/mozilla/javascript/tests/es5/ObjectGetOwnPropertyDescriptorTest.java b/testsrc/org/mozilla/javascript/tests/es5/ObjectGetOwnPropertyDescriptorTest.java\n>new file mode 100644\n>index 0000000..9eaf7a9\n>--- /dev/null\n>+++ b/testsrc/org/mozilla/javascript/tests/es5/ObjectGetOwnPropertyDescriptorTest.java\n>@@ -0,0 +1,32 @@\n>+/*\n>+ * Tests for the Object.getOwnPropertyDescriptor(obj, prop) method\n>+ */\n>+package org.mozilla.javascript.tests.es5;\n>+import org.mozilla.javascript.*;\n>+import static org.mozilla.javascript.tests.Evaluator.eval;\n>+import static org.junit.Assert.assertEquals;\n>+import org.junit.Test;\n>+\n>+public class ObjectGetOwnPropertyDescriptorTest {\n>+\n>+  @Test\n>+  public void testContentsOfPropertyDescriptorShouldReflectAttributesOfProperty() {\n>+    NativeObject descriptor;\n>+    NativeObject object = new NativeObject();\n>+    object.defineProperty(\"a\", \"1\", ScriptableObject.EMPTY);\n>+    object.defineProperty(\"b\", \"2\", ScriptableObject.DONTENUM | ScriptableObject.READONLY | ScriptableObject.PERMANENT);\n>+\n>+    descriptor = (NativeObject) eval(\"Object.getOwnPropertyDescriptor(obj, 'a')\", \"obj\", object);\n>+    assertEquals(\"1\",  descriptor.get(\"value\"));\n>+    assertEquals(true, descriptor.get(\"enumerable\"));\n>+    assertEquals(true, descriptor.get(\"writable\"));\n>+    assertEquals(true, descriptor.get(\"configurable\"));\n>+\n>+    descriptor = (NativeObject) eval(\"Object.getOwnPropertyDescriptor(obj, 'b')\", \"obj\", object);\n>+    assertEquals(\"2\",  descriptor.get(\"value\"));\n>+    assertEquals(false, descriptor.get(\"enumerable\"));\n>+    assertEquals(false, descriptor.get(\"writable\"));\n>+    assertEquals(false, descriptor.get(\"configurable\"));\n>+  }\n>+\n>+}\n>diff --git a/testsrc/org/mozilla/javascript/tests/es5/ObjectGetOwnPropertyNamesTest.java b/testsrc/org/mozilla/javascript/tests/es5/ObjectGetOwnPropertyNamesTest.java\n>new file mode 100644\n>index 0000000..3ba1f9d\n>--- /dev/null\n>+++ b/testsrc/org/mozilla/javascript/tests/es5/ObjectGetOwnPropertyNamesTest.java\n>@@ -0,0 +1,27 @@\n>+/*\n>+ * Tests for the Object.getOwnPropertyNames(obj) method\n>+ */\n>+package org.mozilla.javascript.tests.es5;\n>+import org.mozilla.javascript.*;\n>+import static org.mozilla.javascript.tests.Evaluator.eval;\n>+import static org.junit.Assert.assertEquals;\n>+import org.junit.Test;\n>+\n>+public class ObjectGetOwnPropertyNamesTest {\n>+\n>+  @Test\n>+  public void testShouldReturnAllPropertiesOfArg() {\n>+    NativeObject object = new NativeObject();\n>+    object.defineProperty(\"a\", \"1\", ScriptableObject.EMPTY);\n>+    object.defineProperty(\"b\", \"2\", ScriptableObject.DONTENUM);\n>+\n>+    Object result = eval(\"Object.getOwnPropertyNames(obj)\", \"obj\", object);\n>+\n>+    NativeArray names = (NativeArray) result;\n>+\n>+    assertEquals(2, names.getLength());\n>+    assertEquals(\"a\", names.get(0, names));\n>+    assertEquals(\"b\", names.get(1, names));\n>+  }\n>+\n>+}\n>diff --git a/testsrc/org/mozilla/javascript/tests/es5/ObjectKeysTest.java b/testsrc/org/mozilla/javascript/tests/es5/ObjectKeysTest.java\n>new file mode 100644\n>index 0000000..9584c9f\n>--- /dev/null\n>+++ b/testsrc/org/mozilla/javascript/tests/es5/ObjectKeysTest.java\n>@@ -0,0 +1,28 @@\n>+/*\n>+ * Tests for the Object.keys(obj) method\n>+ */\n>+package org.mozilla.javascript.tests.es5;\n>+import org.mozilla.javascript.*;\n>+import static org.mozilla.javascript.tests.Evaluator.eval;\n>+import static org.junit.Assert.assertEquals;\n>+import org.junit.Test;\n>+\n>+public class ObjectKeysTest {\n>+\n>+  @Test\n>+  public void shouldReturnOnlyEnumerablePropertiesOfArg() {\n>+    NativeObject object = new NativeObject();\n>+    object.defineProperty(\"a\", \"1\", ScriptableObject.EMPTY);\n>+    object.defineProperty(\"b\", \"2\", ScriptableObject.EMPTY);\n>+    object.defineProperty(\"c\", \"3\", ScriptableObject.DONTENUM);\n>+\n>+    Object result = eval(\"Object.keys(obj)\", \"obj\", object);\n>+\n>+    NativeArray keys = (NativeArray) result;\n>+\n>+    assertEquals(2, keys.getLength());\n>+    assertEquals(\"a\", keys.get(0, keys));\n>+    assertEquals(\"b\", keys.get(1, keys));\n>+  }\n>+\n>+}",
            "date": "20090527T16:01:09",
            "id": 6
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "Comment on attachment 379412\nupdated patch\n\n>diff --git a/src/org/mozilla/javascript/NativeObject.java b/src/org/mozilla/javascript/NativeObject.java\n>index 39f4dd3..bdc0673 100644\n>--- a/src/org/mozilla/javascript/NativeObject.java\n>+++ b/src/org/mozilla/javascript/NativeObject.java\n>@@ -71,6 +71,20 @@ public class NativeObject extends IdScriptableObject\n>     }\n> \n>     @Override\n>+    protected void fillConstructorProperties(IdFunctionObject ctor)\n>+    {\n>+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_getPrototypeOf,\n>+                \"getPrototypeOf\", 1);\n>+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_keys,\n>+                \"keys\", 1);\n>+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_getOwnPropertyNames,\n>+                \"getOwnPropertyNames\", 1);\n>+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_getOwnPropertyDescriptor,\n>+                \"getOwnPropertyDescriptor\", 2);\n>+        super.fillConstructorProperties(ctor);\n>+    }\n>+\n>+    @Override\n>     protected void initPrototypeId(int id)\n>     {\n>         String s;\n>@@ -256,6 +270,66 @@ public class NativeObject extends IdScriptableObject\n>               }\n>               return Undefined.instance;\n> \n>+          case ConstructorId_getPrototypeOf:\n>+              {\n>+                if (args.length < 1)\n>+                    throw ScriptRuntime.typeError1(\"msg.arg.not.object\", ScriptRuntime.typeof(Undefined.instance));\n>+\n>+                Object arg = args[0];\n>+\n>+                if ( !(arg instanceof Scriptable) )\n>+                    throw ScriptRuntime.typeError1(\"msg.arg.not.object\", ScriptRuntime.typeof(arg));\n>+\n>+                Scriptable obj = (Scriptable) arg;\n>+                return obj.getPrototype();\n>+              }\n>+          case ConstructorId_keys:\n>+              {\n\nHow about \n\nObject arg = args.length < 1 ? Undefined.instance : args[0];\n\nto replace through the declaration of \"Object arg\" below?\n\n>+                if (args.length < 1)\n>+                    throw ScriptRuntime.typeError1(\"msg.arg.not.object\", ScriptRuntime.typeof(Undefined.instance));\n>+\n>+                Object arg = args[0];\n>+\n>+                if ( !(arg instanceof Scriptable) )\n>+                    throw ScriptRuntime.typeError1(\"msg.arg.not.object\", ScriptRuntime.typeof(arg));\n>+\n>+                Object[] ids = ((Scriptable) arg).getIds();\n>+                for (int i = 0; i < ids.length; i += 1) {\n\nJust use i++\n\n>+                  ids[i] = ScriptRuntime.toString(ids[i]);\n>+                }\n>+                return cx.newArray(scope, ids);\n>+              }\n>+          case ConstructorId_getOwnPropertyNames:\n>+              {\n>+                if (args.length < 1)\n>+                    throw ScriptRuntime.typeError1(\"msg.arg.not.object\", ScriptRuntime.typeof(Undefined.instance));\n>+\n>+                Object arg = args[0];\n>+\n>+                if ( !(arg instanceof ScriptableObject) )\n>+                    throw ScriptRuntime.typeError1(\"msg.arg.not.object\", ScriptRuntime.typeof(arg));\n>+\n>+                Object[] ids = ((ScriptableObject) arg).getAllIds();\n>+                for (int i = 0; i < ids.length; i += 1) {\n>+                  ids[i] = ScriptRuntime.toString(ids[i]);\n>+                }\n>+                return cx.newArray(scope, ids);\n>+              }\n>+          case ConstructorId_getOwnPropertyDescriptor:\n>+              {\n>+                if (args.length < 2)\n>+                    throw ScriptRuntime.typeError1(\"msg.arg.not.object\", ScriptRuntime.typeof(Undefined.instance));\n\nThe second parameter can be any type as long as it can be converted to string, right? In fact, as an edge case, I think you could have a property named \"undefined\" that you could get the property descriptor for by calling Object.getOwnPropertyDescriptor(obj).\n\n>+\n>+                Object arg = args[0];\n>+                if ( !(arg instanceof ScriptableObject) )\n>+                    throw ScriptRuntime.typeError1(\"msg.arg.not.object\", ScriptRuntime.typeof(arg));\n>+                ScriptableObject obj = (ScriptableObject) arg;\n>+                String name = ScriptRuntime.toString(args[1]);\n>+\n>+                Scriptable desc = obj.getOwnPropertyDescriptor(cx, name);\n>+                return desc == null ? Undefined.instance : desc;\n>+              }\n>+\n>           default:\n>             throw new IllegalArgumentException(String.valueOf(id));\n>         }\n>@@ -303,6 +377,11 @@ public class NativeObject extends IdScriptableObject\n>     }\n> \n>     private static final int\n>+        ConstructorId_getPrototypeOf = -1,\n>+        ConstructorId_keys = -2,\n>+        ConstructorId_getOwnPropertyNames = -3,\n>+        ConstructorId_getOwnPropertyDescriptor = -4,\n>+\n>         Id_constructor           = 1,\n>         Id_toString              = 2,\n>         Id_toLocaleString        = 3,\n>diff --git a/src/org/mozilla/javascript/ScriptableObject.java b/src/org/mozilla/javascript/ScriptableObject.java\n>index 38bec1d..68f6e2f 100644\n>--- a/src/org/mozilla/javascript/ScriptableObject.java\n>+++ b/src/org/mozilla/javascript/ScriptableObject.java\n>@@ -202,6 +202,15 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>             }\n>         }\n> \n>+        ScriptableObject getPropertyDescriptor(Context cx, Scriptable parent) {\n\ns/parent/scope/. This is where the \"Object\" constructor is looked up.\n\n>+          ScriptableObject desc = (ScriptableObject) cx.newObject(parent);\n\nI steered you wrong before in suggesting you call this. The 8.10.4 #2 says \"Let obj be the result of creating a new object as if by the expression new Object() where Object is the standard built-in constructor with that name.\" This code would allow someone to intercept that call by redefining \"Object\" in the global scope. Instead you should use\n\n        ScriptableObject desc = new NativeObject();\n        ScriptRuntime.setObjectProtoAndParent(desc, scope);\n\n>+          if (value != null) desc.defineProperty(\"value\", value, EMPTY);\n>+          desc.defineProperty(\"writable\",     (attributes & READONLY) == 0, EMPTY);\n>+          desc.defineProperty(\"enumerable\",   (attributes & DONTENUM) == 0, EMPTY);\n>+          desc.defineProperty(\"configurable\", (attributes & PERMANENT) == 0, EMPTY);\n>+          return desc;\n>+        }\n>+\n>     }\n> \n>     private static final class GetterSlot extends Slot\n>@@ -215,6 +224,16 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>         {\n>             super(name, indexOrHash, attributes);\n>         }\n>+\n>+        @Override\n>+        ScriptableObject getPropertyDescriptor(Context cx, Scriptable parent) {\n>+          ScriptableObject desc = super.getPropertyDescriptor(cx, parent);\n>+          desc.delete(\"value\");\n>+          desc.delete(\"writable\");\n>+          if (getter != null) desc.defineProperty(\"get\", getter, EMPTY);\n>+          if (setter != null) desc.defineProperty(\"set\", setter, EMPTY);\n>+          return desc;\n>+        }\n>     }\n> \n>     static void checkValidAttributes(int attributes)\n>@@ -2523,6 +2542,11 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>         }\n>     }\n> \n>+    protected ScriptableObject getOwnPropertyDescriptor(Context cx, String name) {\n>+      Slot slot = getSlot(name, 0, SLOT_QUERY);\n>+      return (slot == null) ? null : slot.getPropertyDescriptor(cx, getParentScope());\n>+    }\n>+\n>     // Methods and classes to implement java.util.Map interface\n> \n>     public int size() {\n>diff --git a/src/org/mozilla/javascript/resources/Messages.properties b/src/org/mozilla/javascript/resources/Messages.properties\n>index a80e6a5..545dc87 100644\n>--- a/src/org/mozilla/javascript/resources/Messages.properties\n>+++ b/src/org/mozilla/javascript/resources/Messages.properties\n>@@ -260,6 +260,9 @@ msg.bad.regexp.compile =\\\n>     Only one argument may be specified if the first argument to \\\n>     RegExp.prototype.compile is a RegExp object.\n> \n>+msg.arg.not.object =\\\n>+    Expected argument of type object, but instead had type {0}\n>+\n> # Parser\n> msg.got.syntax.errors = \\\n>     Compilation produced {0} syntax errors.\n>diff --git a/testsrc/doctests/object.getownpropertydescriptor.doctest b/testsrc/doctests/object.getownpropertydescriptor.doctest\n>new file mode 100644\n>index 0000000..8a2cb8a\n>--- /dev/null\n>+++ b/testsrc/doctests/object.getownpropertydescriptor.doctest\n>@@ -0,0 +1,43 @@\n>+js> load('testsrc/doctests/util.js');\n>+\n>+js> Object.getOwnPropertyDescriptor;\n>+function getOwnPropertyDescriptor() { [native code for Object.getOwnPropertyDescriptor, arity=2] }\n>+\n>+js> expectTypeError(function() { Object.getOwnPropertyDescriptor() })\n>+js> expectTypeError(function() { Object.getOwnPropertyDescriptor({}) })\n>+\n>+js> [undefined, null, true, 1, 'hello'].forEach(function(value) { \n>+  >   expectTypeError(function() { Object.getOwnPropertyDescriptor(value, 'p') }) \n>+  > })\n>+\n>+js> Object.getOwnPropertyDescriptor({}, 'p') === undefined;\n>+true\n>+\n>+js> var desc = Object.getOwnPropertyDescriptor({p:1}, 'p');\n>+js> desc.value\n>+1\n>+js> desc.writable\n>+true\n>+js> desc.enumerable\n>+true\n>+js> desc.configurable\n>+true\n>+\n>+js> var desc = Object.getOwnPropertyDescriptor({ get p() {}, set p() {} }, 'p');\n>+js> desc.value === undefined;\n>+true\n>+js> desc.writable === undefined;\n>+true\n>+js> desc.get.toSource()\n>+(function () {})\n>+js> desc.set.toSource()\n>+(function () {})\n>+js> desc.enumerable\n>+true\n>+js> desc.configurable\n>+true\n>+\n>+js> desc.__proto__ === Object.prototype\n>+true\n>+js> desc.__parent__;\n>+[object global]\n>diff --git a/testsrc/doctests/object.getownpropertynames.doctest b/testsrc/doctests/object.getownpropertynames.doctest\n>new file mode 100644\n>index 0000000..ddf91db\n>--- /dev/null\n>+++ b/testsrc/doctests/object.getownpropertynames.doctest\n>@@ -0,0 +1,55 @@\n>+js> load('testsrc/doctests/util.js');\n>+\n>+js> Object.getOwnPropertyNames;\n>+function getOwnPropertyNames() { [native code for Object.getOwnPropertyNames, arity=1] }\n>+\n>+js> expectTypeError(function() { Object.getOwnPropertyNames() })\n>+js> [undefined, null, true, 1, 'hello'].forEach(function(value) { \n>+  >   expectTypeError(function() { Object.getOwnPropertyNames(value) }) \n>+  > })\n>+\n>+js> Object.getOwnPropertyNames({}).toSource();\n>+[]\n>+js> Object.getOwnPropertyNames({a:2}).toSource();\n>+[\"a\"]\n>+js> Object.getOwnPropertyNames({a:1, b:2}).toSource();\n>+[\"a\", \"b\"]\n>+js> Object.getOwnPropertyNames({'a.b':1, 'c d':2}).toSource();\n>+[\"a.b\", \"c d\"]\n>+\n>+js> Object.getOwnPropertyNames([]).toSource();\n>+[\"length\"]\n>+js> Object.getOwnPropertyNames(['a', 'b', 'c']).toSource();\n>+[\"0\", \"1\", \"2\", \"length\"]\n>+\n>+js> function UserDefined() { this.a = 1; this.b = 2 };\n>+js> var obj = new UserDefined()\n>+js> Object.getOwnPropertyNames(obj).toSource()\n>+[\"a\", \"b\"]\n>+\n>+js> UserDefined.prototype.c = 3;\n>+3\n>+js> Object.getOwnPropertyNames(obj).toSource()\n>+[\"a\", \"b\"]\n>+\n>+js> // test properties of result are enumerable\n>+js> for (var p in Object.getOwnPropertyNames({a:2, b:3})) print(p)\n>+0\n>+1\n>+\n>+js> // test that properties of result are writable\n>+js> var k = Object.getOwnPropertyNames({a:2, b:3});\n>+js> k[1] = 'c'; k.toSource();\n>+[\"a\", \"c\"]\n>+\n>+js> // test that properties of result are configurable\n>+js> var k = Object.getOwnPropertyNames({a:2, b:3})\n>+js> delete k[1];\n>+true\n>+js> k\n>+a,\n>+js> // TODO test that the attributes of the properties can be changed\n>+\n>+js> var k = Object.getOwnPropertyNames({a:2, 5:6})\n>+js> typeof k[1]\n>+string\n>diff --git a/testsrc/doctests/object.getprototypeof.doctest b/testsrc/doctests/object.getprototypeof.doctest\n>new file mode 100644\n>index 0000000..5514e14\n>--- /dev/null\n>+++ b/testsrc/doctests/object.getprototypeof.doctest\n>@@ -0,0 +1,23 @@\n>+js> load('testsrc/doctests/util.js');\n>+\n>+js> Object.getPrototypeOf;\n>+function getPrototypeOf() { [native code for Object.getPrototypeOf, arity=1] }\n>+\n>+js> expectTypeError(function() { Object.getPrototypeOf() })\n>+js> [undefined, null, true, 1, 'hello'].forEach(function(value) { \n>+  >   expectTypeError(function() { Object.getPrototypeOf(value) }) \n>+  > })\n>+\n>+js> [(function(){}), [], {}].every(function(obj) {\n>+  >   return Object.getPrototypeOf(obj) === obj.__proto__;\n>+  > });\n>+true\n>+\n>+js> function UserDefined() {}\n>+js> [Date, UserDefined].every(function(type) {\n>+  >   var instance;\n>+  >   eval('instance = new '+type.name);\n>+  >   return Object.getPrototypeOf(instance) === type.prototype;\n>+  > });\n>+true\n>+\n>diff --git a/testsrc/doctests/object.keys.doctest b/testsrc/doctests/object.keys.doctest\n>new file mode 100644\n>index 0000000..e9aef8e\n>--- /dev/null\n>+++ b/testsrc/doctests/object.keys.doctest\n>@@ -0,0 +1,55 @@\n>+js> load('testsrc/doctests/util.js');\n>+\n>+js> Object.keys;\n>+function keys() { [native code for Object.keys, arity=1] }\n>+\n>+js> expectTypeError(function() { Object.keys() })\n>+js> [undefined, null, true, 1, 'hello'].forEach(function(value) { \n>+  >   expectTypeError(function() { Object.keys(value) }) \n>+  > })\n>+\n>+js> Object.keys({}).toSource();\n>+[]\n>+js> Object.keys({a:2}).toSource();\n>+[\"a\"]\n>+js> Object.keys({a:1, b:2}).toSource();\n>+[\"a\", \"b\"]\n>+js> Object.keys({'a.b':1, 'c d':2}).toSource();\n>+[\"a.b\", \"c d\"]\n>+\n>+js> Object.keys([]).toSource();\n>+[]\n>+js> Object.keys(['a', 'b', 'c']).toSource();\n>+[\"0\", \"1\", \"2\"]\n>+\n>+js> function UserDefined() { this.a = 1; this.b = 2 };\n>+js> var obj = new UserDefined()\n>+js> Object.keys(obj).toSource()\n>+[\"a\", \"b\"]\n>+\n>+js> UserDefined.prototype.c = 3;\n>+3\n>+js> Object.keys(obj).toSource()\n>+[\"a\", \"b\"]\n>+\n>+js> // test properties of result are enumerable\n>+js> for (var p in Object.keys({a:2, b:3})) print(p)\n>+0\n>+1\n>+\n>+js> // test that properties of result are writable\n>+js> var k = Object.keys({a:2, b:3});\n>+js> k[1] = 'c'; k.toSource();\n>+[\"a\", \"c\"]\n>+\n>+js> // test that properties of result are configurable\n>+js> var k = Object.keys({a:2, b:3})\n>+js> delete k[1];\n>+true\n>+js> k\n>+a,\n>+js> // TODO test that the attributes of the properties can be changed\n>+\n>+js> var k = Object.keys({ a:1, 3:2 });\n>+js> typeof k[1];\n>+string\n>diff --git a/testsrc/doctests/util.js b/testsrc/doctests/util.js\n>new file mode 100644\n>index 0000000..c17e4da\n>--- /dev/null\n>+++ b/testsrc/doctests/util.js\n>@@ -0,0 +1,8 @@\n>+function expectTypeError(code) {\n>+  try {\n>+    code();\n>+    throw (code.toSource() + ' should have thrown a TypeError');\n>+  } catch (e if e instanceof TypeError) {\n>+    // all good\n>+  }\n>+}\n>diff --git a/testsrc/org/mozilla/javascript/tests/Evaluator.java b/testsrc/org/mozilla/javascript/tests/Evaluator.java\n>new file mode 100644\n>index 0000000..491c0e7\n>--- /dev/null\n>+++ b/testsrc/org/mozilla/javascript/tests/Evaluator.java\n>@@ -0,0 +1,30 @@\n>+package org.mozilla.javascript.tests;\n>+import org.mozilla.javascript.*;\n>+import java.util.Collections;\n>+import java.util.Map;\n>+\n>+public class Evaluator {\n>+\n>+  public static Object eval(String source) {\n>+    return eval(source, Collections.EMPTY_MAP);\n>+  }\n>+\n>+  public static Object eval(String source, String id, Scriptable object) {\n>+    return eval(source, Collections.singletonMap(id, object));\n>+  }\n>+\n>+  public static Object eval(String source, Map<String, Scriptable> bindings) {\n>+    Context cx = ContextFactory.getGlobal().enterContext();\n>+    try {\n>+      Scriptable scope = cx.initStandardObjects();\n>+      for (String id : bindings.keySet()) {\n>+        Scriptable object = bindings.get(id);\n>+        object.setParentScope(scope);\n>+        scope.put(id, scope, object);\n>+      }\n>+      return cx.evaluateString(scope, source, \"source\", 1, null);\n>+    } finally {\n>+      Context.exit();\n>+    }\n>+  }\n>+}\n>diff --git a/testsrc/org/mozilla/javascript/tests/es5/ObjectGetOwnPropertyDescriptorTest.java b/testsrc/org/mozilla/javascript/tests/es5/ObjectGetOwnPropertyDescriptorTest.java\n>new file mode 100644\n>index 0000000..9eaf7a9\n>--- /dev/null\n>+++ b/testsrc/org/mozilla/javascript/tests/es5/ObjectGetOwnPropertyDescriptorTest.java\n>@@ -0,0 +1,32 @@\n>+/*\n>+ * Tests for the Object.getOwnPropertyDescriptor(obj, prop) method\n>+ */\n>+package org.mozilla.javascript.tests.es5;\n>+import org.mozilla.javascript.*;\n>+import static org.mozilla.javascript.tests.Evaluator.eval;\n>+import static org.junit.Assert.assertEquals;\n>+import org.junit.Test;\n>+\n>+public class ObjectGetOwnPropertyDescriptorTest {\n>+\n>+  @Test\n>+  public void testContentsOfPropertyDescriptorShouldReflectAttributesOfProperty() {\n>+    NativeObject descriptor;\n>+    NativeObject object = new NativeObject();\n>+    object.defineProperty(\"a\", \"1\", ScriptableObject.EMPTY);\n>+    object.defineProperty(\"b\", \"2\", ScriptableObject.DONTENUM | ScriptableObject.READONLY | ScriptableObject.PERMANENT);\n>+\n>+    descriptor = (NativeObject) eval(\"Object.getOwnPropertyDescriptor(obj, 'a')\", \"obj\", object);\n>+    assertEquals(\"1\",  descriptor.get(\"value\"));\n>+    assertEquals(true, descriptor.get(\"enumerable\"));\n>+    assertEquals(true, descriptor.get(\"writable\"));\n>+    assertEquals(true, descriptor.get(\"configurable\"));\n>+\n>+    descriptor = (NativeObject) eval(\"Object.getOwnPropertyDescriptor(obj, 'b')\", \"obj\", object);\n>+    assertEquals(\"2\",  descriptor.get(\"value\"));\n>+    assertEquals(false, descriptor.get(\"enumerable\"));\n>+    assertEquals(false, descriptor.get(\"writable\"));\n>+    assertEquals(false, descriptor.get(\"configurable\"));\n>+  }\n>+\n>+}\n>diff --git a/testsrc/org/mozilla/javascript/tests/es5/ObjectGetOwnPropertyNamesTest.java b/testsrc/org/mozilla/javascript/tests/es5/ObjectGetOwnPropertyNamesTest.java\n>new file mode 100644\n>index 0000000..3ba1f9d\n>--- /dev/null\n>+++ b/testsrc/org/mozilla/javascript/tests/es5/ObjectGetOwnPropertyNamesTest.java\n>@@ -0,0 +1,27 @@\n>+/*\n>+ * Tests for the Object.getOwnPropertyNames(obj) method\n>+ */\n>+package org.mozilla.javascript.tests.es5;\n>+import org.mozilla.javascript.*;\n>+import static org.mozilla.javascript.tests.Evaluator.eval;\n>+import static org.junit.Assert.assertEquals;\n>+import org.junit.Test;\n>+\n>+public class ObjectGetOwnPropertyNamesTest {\n>+\n>+  @Test\n>+  public void testShouldReturnAllPropertiesOfArg() {\n>+    NativeObject object = new NativeObject();\n>+    object.defineProperty(\"a\", \"1\", ScriptableObject.EMPTY);\n>+    object.defineProperty(\"b\", \"2\", ScriptableObject.DONTENUM);\n>+\n>+    Object result = eval(\"Object.getOwnPropertyNames(obj)\", \"obj\", object);\n>+\n>+    NativeArray names = (NativeArray) result;\n>+\n>+    assertEquals(2, names.getLength());\n>+    assertEquals(\"a\", names.get(0, names));\n>+    assertEquals(\"b\", names.get(1, names));\n>+  }\n>+\n>+}\n>diff --git a/testsrc/org/mozilla/javascript/tests/es5/ObjectKeysTest.java b/testsrc/org/mozilla/javascript/tests/es5/ObjectKeysTest.java\n>new file mode 100644\n>index 0000000..9584c9f\n>--- /dev/null\n>+++ b/testsrc/org/mozilla/javascript/tests/es5/ObjectKeysTest.java\n>@@ -0,0 +1,28 @@\n>+/*\n>+ * Tests for the Object.keys(obj) method\n>+ */\n>+package org.mozilla.javascript.tests.es5;\n>+import org.mozilla.javascript.*;\n>+import static org.mozilla.javascript.tests.Evaluator.eval;\n>+import static org.junit.Assert.assertEquals;\n>+import org.junit.Test;\n>+\n>+public class ObjectKeysTest {\n>+\n>+  @Test\n>+  public void shouldReturnOnlyEnumerablePropertiesOfArg() {\n>+    NativeObject object = new NativeObject();\n>+    object.defineProperty(\"a\", \"1\", ScriptableObject.EMPTY);\n>+    object.defineProperty(\"b\", \"2\", ScriptableObject.EMPTY);\n>+    object.defineProperty(\"c\", \"3\", ScriptableObject.DONTENUM);\n>+\n>+    Object result = eval(\"Object.keys(obj)\", \"obj\", object);\n>+\n>+    NativeArray keys = (NativeArray) result;\n>+\n>+    assertEquals(2, keys.getLength());\n>+    assertEquals(\"a\", keys.get(0, keys));\n>+    assertEquals(\"b\", keys.get(1, keys));\n>+  }\n>+\n>+}",
            "date": "20090527T16:26:33",
            "id": 7
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "Since the remaining edits were small, I made them myself and submitted:\n\nChecking in src/org/mozilla/javascript/NativeObject.java;\n/cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/NativeObject.java,v  <--  NativeObject.java\nnew revision: 1.49; previous revision: 1.48\ndone\nChecking in src/org/mozilla/javascript/ScriptableObject.java;\n/cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/ScriptableObject.java,v  <--  ScriptableObject.java\nnew revision: 1.148; previous revision: 1.147\ndone\nChecking in src/org/mozilla/javascript/resources/Messages.properties;\n/cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/resources/Messages.properties,v  <--  Messages.properties\nnew revision: 1.93; previous revision: 1.92\ndone\nRCS file: /cvsroot/mozilla/js/rhino/testsrc/doctests/object.getownpropertydescriptor.doctest,v\ndone\nChecking in testsrc/doctests/object.getownpropertydescriptor.doctest;\n/cvsroot/mozilla/js/rhino/testsrc/doctests/object.getownpropertydescriptor.doctest,v  <--  object.getownpropertydescriptor.doctest\ninitial revision: 1.1\ndone\nRCS file: /cvsroot/mozilla/js/rhino/testsrc/doctests/object.getownpropertynames.doctest,v\ndone\nChecking in testsrc/doctests/object.getownpropertynames.doctest;\n/cvsroot/mozilla/js/rhino/testsrc/doctests/object.getownpropertynames.doctest,v  <--  object.getownpropertynames.doctest\ninitial revision: 1.1\ndone\nRCS file: /cvsroot/mozilla/js/rhino/testsrc/doctests/object.getprototypeof.doctest,v\ndone\nChecking in testsrc/doctests/object.getprototypeof.doctest;\n/cvsroot/mozilla/js/rhino/testsrc/doctests/object.getprototypeof.doctest,v  <--  object.getprototypeof.doctest\ninitial revision: 1.1\ndone\nRCS file: /cvsroot/mozilla/js/rhino/testsrc/doctests/object.keys.doctest,v\ndone\nChecking in testsrc/doctests/object.keys.doctest;\n/cvsroot/mozilla/js/rhino/testsrc/doctests/object.keys.doctest,v  <--  object.keys.doctest\ninitial revision: 1.1\ndone\nRCS file: /cvsroot/mozilla/js/rhino/testsrc/doctests/util.js,v\ndone\nChecking in testsrc/doctests/util.js;\n/cvsroot/mozilla/js/rhino/testsrc/doctests/util.js,v  <--  util.js\ninitial revision: 1.1\ndone\nRCS file: /cvsroot/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/Evaluator.java,v\ndone\nChecking in testsrc/org/mozilla/javascript/tests/Evaluator.java;\n/cvsroot/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/Evaluator.java,v  <--  Evaluator.java\ninitial revision: 1.1\ndone\nRCS file: /cvsroot/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/es5/ObjectGetOwnPropertyDescriptorTest.java,v\ndone\nChecking in testsrc/org/mozilla/javascript/tests/es5/ObjectGetOwnPropertyDescriptorTest.java;\n/cvsroot/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/es5/ObjectGetOwnPropertyDescriptorTest.java,v  <--  ObjectGetOwnPropertyDescriptorTest.java\ninitial revision: 1.1\ndone\nRCS file: /cvsroot/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/es5/ObjectGetOwnPropertyNamesTest.java,v\ndone\nChecking in testsrc/org/mozilla/javascript/tests/es5/ObjectGetOwnPropertyNamesTest.java;\n/cvsroot/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/es5/ObjectGetOwnPropertyNamesTest.java,v  <--  ObjectGetOwnPropertyNamesTest.java\ninitial revision: 1.1\ndone\nRCS file: /cvsroot/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/es5/ObjectKeysTest.java,v\ndone\nChecking in testsrc/org/mozilla/javascript/tests/es5/ObjectKeysTest.java;\n/cvsroot/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/es5/ObjectKeysTest.java,v  <--  ObjectKeysTest.java\ninitial revision: 1.1\ndone",
            "date": "20090527T16:48:28",
            "id": 8
        },
        {
            "author": "rspeyer@gmail.com",
            "body": "Created attachment 380047\nmakes junit run new tests\n\nSorry, I left this out of the previous patch. It just gets junit to execute the new test files which are currently under an es5 subpackage.",
            "date": "20090528T06:19:26",
            "id": 9
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "Checking in testsrc/build.xml;\n/cvsroot/mozilla/js/rhino/testsrc/build.xml,v  <--  build.xml\nnew revision: 1.15; previous revision: 1.14\ndone",
            "date": "20090528T12:11:43",
            "id": 10
        },
        {
            "author": "rspeyer@gmail.com",
            "body": "Created attachment 380379\npatch for isExtensible, preventExtensions and defineProperty\n\nInitial implementation for isExtensible, preventExtensions and defineProperty",
            "date": "20090529T06:26:47",
            "id": 11
        },
        {
            "author": "rspeyer@gmail.com",
            "body": "Created attachment 380698\nnew patch for isExtensible, preventExtensions and defineProperty\n\nThis is a slight revision of patch 380379 such that defineProperty now throws a TypeError when defining a new property on a non-extensible object, rather than just failing silently.",
            "date": "20090531T10:24:17",
            "id": 12
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "Comment on attachment 380698\nnew patch for isExtensible, preventExtensions and defineProperty\n\n>diff --git a/src/org/mozilla/javascript/NativeObject.java b/src/org/mozilla/javascript/NativeObject.java\n>index 46cc101..b08aa68 100644\n>--- a/src/org/mozilla/javascript/NativeObject.java\n>+++ b/src/org/mozilla/javascript/NativeObject.java\n>@@ -81,6 +81,12 @@ public class NativeObject extends IdScriptableObject\n>                 \"getOwnPropertyNames\", 1);\n>         addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_getOwnPropertyDescriptor,\n>                 \"getOwnPropertyDescriptor\", 2);\n>+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_defineProperty,\n>+                \"defineProperty\", 3);\n>+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_isExtensible,\n>+                \"isExtensible\", 1);\n>+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_preventExtensions,\n>+                \"preventExtensions\", 1);\n>         super.fillConstructorProperties(ctor);\n>     }\n> \n>@@ -273,21 +279,14 @@ public class NativeObject extends IdScriptableObject\n>           case ConstructorId_getPrototypeOf:\n>               {\n>                 Object arg = args.length < 1 ? Undefined.instance : args[0];\n>-                if (!(arg instanceof Scriptable)) {\n>-                    throw ScriptRuntime.typeError1(\"msg.arg.not.object\",\n>-                                                   ScriptRuntime.typeof(arg));\n>-                }\n>-                Scriptable obj = (Scriptable) arg;\n>+                Scriptable obj = ensureScriptable(arg);\n>                 return obj.getPrototype();\n>               }\n>           case ConstructorId_keys:\n>               {\n>                 Object arg = args.length < 1 ? Undefined.instance : args[0];\n>-                if (!(arg instanceof Scriptable)) {\n>-                    throw ScriptRuntime.typeError1(\"msg.arg.not.object\",\n>-                                                   ScriptRuntime.typeof(arg));\n>-                }\n>-                Object[] ids = ((Scriptable) arg).getIds();\n>+                Scriptable obj = ensureScriptable(arg);\n>+                Object[] ids = obj.getIds();\n>                 for (int i = 0; i < ids.length; i++) {\n>                   ids[i] = ScriptRuntime.toString(ids[i]);\n>                 }\n>@@ -296,11 +295,8 @@ public class NativeObject extends IdScriptableObject\n>           case ConstructorId_getOwnPropertyNames:\n>               {\n>                 Object arg = args.length < 1 ? Undefined.instance : args[0];\n>-                if (!(arg instanceof Scriptable)) {\n>-                    throw ScriptRuntime.typeError1(\"msg.arg.not.object\",\n>-                                                   ScriptRuntime.typeof(arg));\n>-                }\n>-                Object[] ids = ((ScriptableObject) arg).getAllIds();\n>+                ScriptableObject obj = ensureScriptableObject(arg);\n>+                Object[] ids = obj.getAllIds();\n>                 for (int i = 0; i < ids.length; i++) {\n>                   ids[i] = ScriptRuntime.toString(ids[i]);\n>                 }\n>@@ -309,25 +305,56 @@ public class NativeObject extends IdScriptableObject\n>           case ConstructorId_getOwnPropertyDescriptor:\n>               {\n>                 Object arg = args.length < 1 ? Undefined.instance : args[0];\n>-                if (!(arg instanceof ScriptableObject)) {\n>                     // TODO(norris): There's a deeper issue here if\n>                     // arg instanceof Scriptable. Should we create a new\n>                     // interface to admit the new ECMAScript 5 operations?\n>-                    throw ScriptRuntime.typeError1(\"msg.arg.not.object\",\n>-                                                   ScriptRuntime.typeof(arg));\n>-                }\n>-                ScriptableObject obj = (ScriptableObject) arg;\n>+                ScriptableObject obj = ensureScriptableObject(arg);\n>                 Object nameArg = args.length < 2 ? Undefined.instance : args[1];\n>                 String name = ScriptRuntime.toString(nameArg);\n>                 Scriptable desc = obj.getOwnPropertyDescriptor(cx, name);\n>                 return desc == null ? Undefined.instance : desc;\n>               }\n>+          case ConstructorId_defineProperty:\n>+              {\n>+                Object arg = args.length < 1 ? Undefined.instance : args[0];\n>+                ScriptableObject obj = ensureScriptableObject(arg);\n>+                Object nameArg = args.length < 2 ? Undefined.instance : args[1];\n>+                String name = ScriptRuntime.toString(nameArg);\n>+                Object descArg = args.length < 3 ? Undefined.instance : args[2];\n>+                ScriptableObject desc = ensureScriptableObject(descArg);\n>+                obj.defineOwnProperty(name, desc);\n>+                return obj;\n>+              }\n>+          case ConstructorId_isExtensible:\n>+              {\n>+                Object arg = args.length < 1 ? Undefined.instance : args[0];\n>+                ScriptableObject obj = ensureScriptableObject(arg);\n>+                return obj.isExtensible();\n>+              }\n>+          case ConstructorId_preventExtensions:\n>+              {\n>+                Object arg = args.length < 1 ? Undefined.instance : args[0];\n>+                ScriptableObject obj = ensureScriptableObject(arg);\n>+                obj.preventExtensions();\n>+                return obj;\n>+              }\n> \n>           default:\n>             throw new IllegalArgumentException(String.valueOf(id));\n>         }\n>     }\n> \n>+    private Scriptable ensureScriptable(Object arg) {\n>+      if ( !(arg instanceof Scriptable) )\n>+        throw ScriptRuntime.typeError1(\"msg.arg.not.object\", ScriptRuntime.typeof(arg));\n>+      return (Scriptable) arg;\n>+    }\n\nAdd 1 line between\n\n>+    private ScriptableObject ensureScriptableObject(Object arg) {\n>+      if ( !(arg instanceof ScriptableObject) )\n>+        throw ScriptRuntime.typeError1(\"msg.arg.not.object\", ScriptRuntime.typeof(arg));\n>+      return (ScriptableObject) arg;\n>+    }\n>+\n> // #string_id_map#\n> \n>     @Override\n>@@ -374,6 +401,9 @@ public class NativeObject extends IdScriptableObject\n>         ConstructorId_keys = -2,\n>         ConstructorId_getOwnPropertyNames = -3,\n>         ConstructorId_getOwnPropertyDescriptor = -4,\n>+        ConstructorId_defineProperty = -5,\n>+        ConstructorId_isExtensible = -6,\n>+        ConstructorId_preventExtensions = -7,\n> \n>         Id_constructor           = 1,\n>         Id_toString              = 2,\n>diff --git a/src/org/mozilla/javascript/ScriptableObject.java b/src/org/mozilla/javascript/ScriptableObject.java\n>index 87984f0..2044eb8 100644\n>--- a/src/org/mozilla/javascript/ScriptableObject.java\n>+++ b/src/org/mozilla/javascript/ScriptableObject.java\n>@@ -154,6 +154,9 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>     private static final int SLOT_REMOVE = 3;\n>     private static final int SLOT_MODIFY_GETTER_SETTER = 4;\n>     private static final int SLOT_MODIFY_CONST = 5;\n>+    private static final int SLOT_CONVERT_ACCESSOR_TO_DATA = 6;\n>+\n>+    private boolean isExtensible = true;\n\nIn the current Rhino, \"sealed\" is pretty much equivalent to !extensible in es5. I don't think it makes sense to have both concepts running around independently, especially since now there's a new \"sealed\" in es5 that means something different!\n\nThinking about it, go ahead and add this boolean and I'll think about how to handle this change in the most backwards compatible way.\n\n> \n>     private static class Slot implements Serializable\n>     {\n>@@ -574,13 +577,30 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>     public void setGetterOrSetter(String name, int index,\n>                                   Callable getterOrSetter, boolean isSetter)\n>     {\n>+        setGetterOrSetter(name, index, getterOrSetter, isSetter, false);\n>+    }\n>+\n>+    private void setGetterOrSetter(String name, int index, Callable getterOrSetter, boolean isSetter, boolean force)\n>+    {\n>         if (name != null && index != 0)\n>             throw new IllegalArgumentException(name);\n> \n>+        if (!force) {\n>         checkNotSealed(name, index);\n>-        GetterSlot gslot = (GetterSlot)getSlot(name, index,\n>-                                               SLOT_MODIFY_GETTER_SETTER);\n>+        }\n>+\n>+        final GetterSlot gslot;\n>+        if (isExtensible()) {\n>+          gslot = (GetterSlot)getSlot(name, index, SLOT_MODIFY_GETTER_SETTER);\n>+        } else {\n>+          gslot = (GetterSlot)getSlot(name, index, SLOT_QUERY);\n>+          if (gslot == null)\n>+            return;\n>+        }\n>+        \n>+        if (!force) {\n>         gslot.checkNotReadonly();\n>+        }\n>         if (isSetter) {\n>             gslot.setter = getterOrSetter;\n>         } else {\n>@@ -1476,6 +1496,117 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>         gslot.setter = setterBox;\n>     }\n> \n>+    public void defineOwnProperty(String name, ScriptableObject desc) {\n\nAdd javadoc, at least with reference to ES5 spec section.\n\n>+      Slot slot = getSlot(name, 0, SLOT_QUERY);\n>+      final int attributes;\n>+\n>+      if (slot == null) { // new slot\n>+        if (!isExtensible()) throw ScriptRuntime.typeError(\"msg.not.extensible\");\n>+        slot = getSlot(name, 0, SLOT_MODIFY);\n>+        attributes = applyDescriptorToAttributeBitset(DONTENUM|READONLY|PERMANENT, desc);\n>+      } else {\n>+        checkLegalPropertyRedefinition(name, desc);\n>+        attributes = applyDescriptorToAttributeBitset(getAttributes(name), desc);\n>+      }\n>+\n>+      defineOwnProperty(slot, desc, attributes);\n>+    }\n>+\n>+    private void defineOwnProperty(Slot slot, ScriptableObject desc, int attributes) {\n>+      if (isAccessorDescriptor(desc)) {\n>+        if ( !(slot instanceof GetterSlot) ) \n>+          slot = getSlot(slot.name, 0, SLOT_MODIFY_GETTER_SETTER);\n>+\n>+        Object getter = desc.get(\"get\");\n>+        Object setter = desc.get(\"set\");\n>+\n>+        if (getter != null && !(getter instanceof Callable) ) {\n\nIf not found, get() returns NOT_FOUND, not null (since null is a valid value).\n\n>+          throw ScriptRuntime.notFunctionError(getter);\n>+        }\n>+        if (setter != null && !(setter instanceof Callable) ) {\n>+          throw ScriptRuntime.notFunctionError(setter);\n>+        }\n>+\n>+        defineOwnAccessorProperty( (GetterSlot) slot, (Callable) getter, (Callable) setter, attributes);\n>+      } else  {\n>+        if (slot instanceof GetterSlot && isDataDescriptor(desc)) {\n>+          slot = getSlot(slot.name, 0, SLOT_CONVERT_ACCESSOR_TO_DATA);\n>+        }\n>+        defineOwnDataProperty(slot, desc.get(\"value\"), attributes);\n>+      }\n>+    }\n>+\n>+    private void defineOwnDataProperty(Slot slot, Object value, int attributes) {\n>+      if (value != null) {\n>+        slot.value = value;\n>+      }\n>+      slot.setAttributes(attributes);\n>+    }\n>+\n>+    private void defineOwnAccessorProperty(GetterSlot slot, Callable getter, Callable setter, int attributes) {\n>+      if (getter != null) {\n>+        slot.getter = getter;\n>+      } if (setter != null) {\n>+        slot.setter = setter;\n>+      }\n>+      slot.value = Undefined.instance;\n>+      slot.setAttributes(attributes);\n>+    }\n>+\n>+    private void checkLegalPropertyRedefinition(String name, ScriptableObject desc) {\n>+      ScriptableObject current = getOwnPropertyDescriptor(Context.getContext(), name);\n>+      if (Boolean.FALSE.equals(current.get(\"configurable\"))) {\n\nFrom reading 8.10.5, a couple of changes are needed:\n* [[Get]] is not equivalent to ScriptableObject.get. [[Get]] will look in the prototype chain if need be, and will call getters if need be. I think getProperty will do what is needed here, but double check that getters are honored. There are other places in this patch that need to use a method other than get() as well.\n* Step 4b specifies that ToBoolean is called. So use ScriptRuntime.toBoolean rather than comparing with Boolean.FALSE.\n\nThis is as far as I got tonight, but it'll give you something to work on.\n\n>+\n>+        if (Boolean.TRUE.equals(desc.get(\"configurable\"))) \n>+          throw ScriptRuntime.typeError1(\"msg.change.configurable.false.to.true\", name);\n>+        if (desc.has(\"enumerable\", desc) && !current.get(\"enumerable\").equals(desc.get(\"enumerable\")))\n>+          throw ScriptRuntime.typeError1(\"msg.change.enumerable.with.configurable.false\", name);\n>+\n>+        if (isGenericDescriptor(desc)) {\n>+          // no further validation required\n>+        } else if (isDataDescriptor(desc) && isDataDescriptor(current)) {\n>+          if (Boolean.FALSE.equals(current.get(\"writable\"))) {\n>+            if (Boolean.TRUE.equals(desc.get(\"writable\")))\n>+              throw ScriptRuntime.typeError1(\"msg.change.writable.false.to.true.with.configurable.false\", name);\n>+\n>+            if (desc.has(\"value\", desc) && !ScriptRuntime.shallowEq(current.get(\"value\"), desc.get(\"value\"))) \n>+              throw ScriptRuntime.typeError1(\"msg.change.value.with.writable.false\", name);\n>+          }\n>+        } else if (isAccessorDescriptor(desc) && isAccessorDescriptor(current)) {\n>+          if (desc.has(\"set\", desc) && !ScriptRuntime.shallowEq(current.get(\"set\"), desc.get(\"set\")))\n>+            throw ScriptRuntime.typeError1(\"msg.change.setter.with.configurable.false\", name);\n>+\n>+          if (desc.has(\"get\", desc) && !ScriptRuntime.shallowEq(current.get(\"get\"), desc.get(\"get\"))) \n>+            throw ScriptRuntime.typeError1(\"msg.change.getter.with.configurable.false\", name);\n>+        } else {\n>+          throw ScriptRuntime.typeError1(\"msg.change.descriptor.type.with.configurable.false\", name);\n>+        }\n>+      }\n>+    }\n>+\n>+    private int applyDescriptorToAttributeBitset(int attributes, ScriptableObject desc) {\n>+      Boolean enumerable = (Boolean) desc.get(\"enumerable\");\n>+      if (enumerable != null) attributes = (enumerable ? attributes & ~DONTENUM : attributes | DONTENUM);\n>+\n>+      Boolean writable = (Boolean) desc.get(\"writable\");\n>+      if (writable != null) attributes = (writable ? attributes & ~READONLY : attributes | READONLY);\n>+\n>+      Boolean configurable = (Boolean) desc.get(\"configurable\");\n>+      if (configurable != null) attributes = (configurable ? attributes & ~PERMANENT : attributes | PERMANENT);\n>+\n>+      return attributes;\n>+    }\n>+\n>+    private boolean isDataDescriptor(ScriptableObject desc) {\n>+      return desc.has(\"value\", desc) || desc.has(\"writable\", desc);\n>+    }\n>+    private boolean isAccessorDescriptor(ScriptableObject desc) {\n>+      return desc.has(\"get\", desc) || desc.has(\"set\", desc);\n>+    }\n>+    private boolean isGenericDescriptor(ScriptableObject desc) {\n>+      return !isDataDescriptor(desc) && !isAccessorDescriptor(desc);\n>+    }\n>+\n>     /**\n>      * Search for names in a class, adding the resulting methods\n>      * as properties.\n>@@ -1576,6 +1707,14 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>         }\n>     }\n> \n>+    public boolean isExtensible() {\n>+      return isExtensible;\n>+    }\n>+\n>+    public void preventExtensions() {\n>+      isExtensible = false;\n>+    }\n>+\n>     /**\n>      * Seal this object.\n>      *\n>@@ -2082,6 +2221,11 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>             if (slot == null) {\n>                 return false;\n>             }\n>+        } else if (!isExtensible()) {\n>+            slot = getSlot(name, index, SLOT_QUERY);\n>+            if (slot == null) {\n>+                return true;\n>+            }\n>         } else {\n>             checkNotSealed(name, index);\n>             // either const hoisted declaration or initialization\n>@@ -2188,6 +2332,10 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>                 !(slot instanceof GetterSlot))\n>                 break lastAccessCheck;\n> \n>+            if (accessType == SLOT_CONVERT_ACCESSOR_TO_DATA &&\n>+                (slot instanceof GetterSlot))\n>+                break lastAccessCheck;\n>+\n>             return slot;\n>         }\n> \n>@@ -2206,7 +2354,8 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>         if (accessType == SLOT_QUERY ||\n>             accessType == SLOT_MODIFY ||\n>             accessType == SLOT_MODIFY_CONST ||\n>-            accessType == SLOT_MODIFY_GETTER_SETTER)\n>+            accessType == SLOT_MODIFY_GETTER_SETTER ||\n>+            accessType == SLOT_CONVERT_ACCESSOR_TO_DATA)\n>         {\n>             // Check the hashtable without using synchronization\n> \n>@@ -2249,6 +2398,9 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>                 } else if (accessType == SLOT_MODIFY_CONST) {\n>                     if (slot != null)\n>                         return slot;\n>+                } else if (accessType == SLOT_CONVERT_ACCESSOR_TO_DATA) {\n>+                    if ( !(slot instanceof GetterSlot) )\n>+                        return slot;\n>                 }\n>             }\n> \n>@@ -2288,11 +2440,19 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>                         // implementation it is harmless with the only\n>                         // complication is the need to replace the added slot\n>                         // if we need GetterSlot and the old one is not.\n>-                        if (accessType == SLOT_MODIFY_GETTER_SETTER &&\n>-                            !(slot instanceof GetterSlot))\n>-                        {\n>-                            GetterSlot newSlot = new GetterSlot(name,\n>-                                    indexOrHash, slot.getAttributes());\n>+\n>+                        Slot newSlot;\n>+\n>+                        if (accessType == SLOT_MODIFY_GETTER_SETTER && !(slot instanceof GetterSlot)) {\n>+                            newSlot = new GetterSlot(name, indexOrHash, slot.getAttributes());\n>+                        } else if (accessType == SLOT_CONVERT_ACCESSOR_TO_DATA && (slot instanceof GetterSlot)) {\n>+                            newSlot = new Slot(name, indexOrHash, slot.getAttributes());\n>+                        } else if (accessType == SLOT_MODIFY_CONST) {\n>+                          return null;\n>+                        } else {\n>+                          return slot;\n>+                        }\n>+\n>                             newSlot.value = slot.value;\n>                             newSlot.next = slot.next;\n>                             // add new slot to linked list\n>@@ -2314,13 +2474,8 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>                             if (slot == lastAccess) {\n>                                 lastAccess = REMOVED;\n>                             }\n>-                            slot = newSlot;\n>-                        } else if (accessType == SLOT_MODIFY_CONST) {\n>-                            return null;\n>-                        }\n>-                        return slot;\n>-                    }\n>-\n>+                        return newSlot;\n>+                    } else {\n>                     // Check if the table is not too full before inserting.\n>                     if (4 * (count + 1) > 3 * slotsLocalRef.length) {\n>                         slotsLocalRef = new Slot[slotsLocalRef.length * 2 + 1];\n>@@ -2330,7 +2485,7 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>                                 indexOrHash);\n>                     }\n>                 }\n>-\n>+                }\n>                 Slot newSlot = (accessType == SLOT_MODIFY_GETTER_SETTER\n>                                 ? new GetterSlot(name, indexOrHash, 0)\n>                                 : new Slot(name, indexOrHash, 0));\n>diff --git a/src/org/mozilla/javascript/resources/Messages.properties b/src/org/mozilla/javascript/resources/Messages.properties\n>index 545dc87..6ad9097 100644\n>--- a/src/org/mozilla/javascript/resources/Messages.properties\n>+++ b/src/org/mozilla/javascript/resources/Messages.properties\n>@@ -667,6 +667,32 @@ msg.modify.sealed =\\\n> msg.modify.readonly =\\\n>     Cannot modify readonly property: {0}.\n> \n>+msg.change.configurable.false.to.true =\\\n>+    Cannot change the configurable attribute of \"{0}\" from false to true.\n>+\n>+msg.change.enumerable.with.configurable.false =\\\n>+    Cannot change the enumerable attribute of \"{0}\" because configurable is false.\n>+\n>+msg.change.writable.false.to.true.with.configurable.false =\\\n>+    Cannot change the writable attribute of \"{0}\" from false to true because configurable is false.\n>+\n>+# TODO should we be using msg.modify.readonly here instead?\n>+msg.change.value.with.writable.false =\\\n>+    Cannot change the value of attribute \"{0}\" because writable is false.\n>+\n>+msg.change.getter.with.configurable.false =\\\n>+    Cannot change the get attribute of \"{0}\" because configurable is false.\n>+\n>+msg.change.setter.with.configurable.false =\\\n>+    Cannot change the set attribute of \"{0}\" because configurable is false.\n>+\n>+# TODO not sure about how descriptive this message is\n>+msg.change.descriptor.type.with.configurable.false =\\\n>+    Cannot change type of property \"{0}\" because configurable is false.\n>+\n>+msg.not.extensible =\\\n>+    Cannot add properties to this object because extensible is false.\n>+\n> # TokenStream\n> msg.missing.exponent =\\\n>     missing exponent\n>diff --git a/testsrc/doctests/480758.doctest b/testsrc/doctests/480758.doctest\n>index 675483a..3893400 100755\n>diff --git a/testsrc/doctests/object.defineproperty.doctest b/testsrc/doctests/object.defineproperty.doctest\n>new file mode 100644\n>index 0000000..e40e972\n>--- /dev/null\n>+++ b/testsrc/doctests/object.defineproperty.doctest\n>@@ -0,0 +1,169 @@\n>+js> load('testsrc/doctests/util.js');\n>+\n>+js> Object.defineProperty\n>+function defineProperty() { [native code for Object.defineProperty, arity=3] }\n>+\n>+js> expectTypeError(function() { Object.defineProperty() });\n>+js> expectTypeError(function() { Object.defineProperty({}) });\n>+js> expectTypeError(function() { Object.defineProperty({}, 'p') });\n>+js> [undefined, null, true, 1, 'hello'].forEach(function(value) { \n>+  >   expectTypeError(function() { Object.defineProperty(value, 'p', {}) }) \n>+  > })\n>+\n>+js> Object.defineProperty({}, 'p', {value:1}).p\n>+1\n>+js> var obj = {}\n>+js> Object.defineProperty(obj, 'a', {\n>+  >   value: 1,\n>+  >   enumerable: false,\n>+  >   writable: false,\n>+  >   configurable: false\n>+  > })  \n>+[object Object]\n>+js> for (var p in obj) print(p); // check it has no enumerable properties\n>+js> obj.a = 2; obj.a; // check that the property is not writable\n>+1\n>+js> delete obj.a; obj.a // check that the property is not deletable\n>+1\n>+\n>+js> var define = Object.defineProperty;\n>+js> var describe = Object.getOwnPropertyDescriptor;\n>+\n>+js> // when define new property with empty descriptor then default values are used for the descriptor\n>+js> var obj = define({}, 'a', {});\n>+js> describe(obj, 'a').toSource()\n>+({writable:false, enumerable:false, configurable:false})\n>+\n>+js> // when define new property with data descriptor then those values are used for the descriptor\n>+js> var obj = define({}, 'a', { value: 2, writable: true });\n>+js> var {value:v, writable:w} = describe(obj, 'a'); [v, w].toSource();\n>+[2, true]\n>+js> obj.a\n>+2\n>+\n>+js> // when define new property with accessor descriptor then those values are used for the descriptor\n>+js> var obj = define({}, 'a', { get: function() { return 3; }, set: function(value) {} });\n>+js> var {get:g, set:s} = describe(obj, 'a'); [g, s].toSource();\n>+[(function () {return 3;}), (function (value) {})]\n>+js> obj.a\n>+3\n>+\n>+js> // when define existing property with empty descriptor then descriptor is left unchanged\n>+js> var descriptor = {value:1, writable:true, enumerable:true, configurable:true};\n>+js> var obj = define({},  'a', descriptor);\n>+js> var obj = define(obj, 'a', {});\n>+js> describe(obj, 'a').toSource()\n>+({value:1, writable:true, enumerable:true, configurable:true})\n>+\n>+js> // when define existing property with same descriptor then descriptor is left unchanged\n>+js> var descriptor = {value:1, writable:true, enumerable:true, configurable:true};\n>+js> var obj = define({},  'a', descriptor);\n>+js> var obj = define(obj, 'a', descriptor);\n>+js> describe(obj, 'a').toSource()\n>+({value:1, writable:true, enumerable:true, configurable:true})\n>+\n>+js> // may not change configurable from false to true\n>+js> expectTypeError(function() {\n>+  >   var obj = define({}, 'a', {configurable : false});\n>+  >   define(obj, 'a',          {configurable : true});\n>+  > });\n>+\n>+js> // may not change enumerable when configurable is false\n>+js> expectTypeError(function() {\n>+  >   var obj = define({}, 'a', {enumerable : true, configurable:false});\n>+  >   define(obj, 'a',          {enumerable : false});\n>+  > });\n>+\n>+js> // may not change writable from false to true when configurable is false\n>+js> expectTypeError(function() {\n>+  >   var obj = define({}, 'a', {writable : false, configurable: false});\n>+  >   define(obj, 'a',          {writable : true});\n>+  > });\n>+\n>+js> // may not change value when writable is false\n>+js> expectTypeError(function() {\n>+  >   var obj = define({}, 'a', {value : 1, writable:false});\n>+  >   define(obj, 'a',          {value : 2});\n>+  > });\n>+\n>+js> // may not change getter when configurable is false\n>+js> expectTypeError(function() {\n>+  >   var obj = define({}, 'a', {get: function() { return 1 }, configurable:false});\n>+  >   define(obj, 'a',          {get: function() { return 1 }});\n>+  > });\n>+\n>+js> // may not change setter when configurable is false\n>+js> expectTypeError(function() {\n>+  >   var obj = define({}, 'a', {set: function(val) {}, configurable:false});\n>+  >   define(obj, 'a',          {set: function(val) {}});\n>+  > });\n>+\n>+js> // may not change from data property to accessor property when configurable is false\n>+js> expectTypeError(function() {\n>+  >   var obj = define({}, 'a', {value : 1, configurable:false});\n>+  >   define(obj, 'a',          {get   : function() { return 1 }});\n>+  > });\n>+\n>+js> // may not change from accessor property to data property when configurable is false\n>+js> expectTypeError(function() {\n>+  >   var obj = define({}, 'a', {get   : function() { return 1 }, configurable:false});\n>+  >   define(obj, 'a',          {value : 1});\n>+  > });\n>+\n>+js> // can change writable from true to false when configurable is false\n>+js> var obj = define({},  'a', {writable:true, configurable:false});\n>+js> var obj = define(obj, 'a', {writable:false});\n>+\n>+js> // can set enumerable to the same value when configuable is false\n>+js> var obj = define({},  'a', {enumerable:true, configurable:false});\n>+js> var obj = define(obj, 'a', {enumerable:true});\n>+\n>+js> // can change from data property to accessor property when configurable is true\n>+js> var obj = define({},  'a', {value : 1, configurable: true});\n>+js> var obj = define(obj, 'a', {get   : function() { return 4 }});\n>+js> obj.a\n>+4\n>+js> describe(obj, 'a').toSource()\n>+({enumerable:false, configurable:true, get:(function () {return 4;})})\n>+\n>+js> // can change from accessor property to data property when configurable is true\n>+js> var obj = define({},  'a', {get   : function() { return 2 }, configurable:true});\n>+js> var obj = define(obj, 'a', {value : 5});\n>+js> obj.a\n>+5\n>+js> describe(obj, 'a').toSource()\n>+({value:5, writable:false, enumerable:false, configurable:true})\n>+\n>+js> // can change enumerable and writable to true when configurable is true\n>+js> var obj = define({},  'a', {writable : false, enumerable : false, configurable:true});\n>+js> var obj = define(obj, 'a', {writable : true,  enumerable : true, configurable:true});\n>+\n>+js> // can change the value if writable is true\n>+js> var obj = define({},  'a', {value:6, writable:true})\n>+js> obj.a\n>+6\n>+js> var obj = define(obj, 'a', {value:7})\n>+js> obj.a\n>+7\n>+\n>+js> // defining a new property should fail loudly when object is not extensible\n>+js> var obj = Object.preventExtensions({});\n>+js> expectTypeError(function() { define(obj, 'a', {value:1}) })\n>+\n>+js> // defining new property should succeed when object is extensible\n>+js> var obj = {}\n>+js> Object.isExtensible(obj);\n>+true\n>+js> obj.a = 8; obj.a\n>+8\n>+\n>+js> // changing existing property should succeed when object is not extensible\n>+js> var obj = define({},  'a', {value:1, writable:true});\n>+js> var obj = Object.preventExtensions(obj);\n>+js> obj.a = 9; obj.a\n>+9\n>+\n>+js> // defined getters and setters must be functions\n>+js> expectTypeError(function() { define({}, 'a', {get:1}); })\n>+js> expectTypeError(function() { define({}, 'a', {set:1}); })\n>+\n>diff --git a/testsrc/doctests/object.extensible.doctest b/testsrc/doctests/object.extensible.doctest\n>new file mode 100644\n>index 0000000..841511d\n>--- /dev/null\n>+++ b/testsrc/doctests/object.extensible.doctest\n>@@ -0,0 +1,30 @@\n>+js> load('testsrc/doctests/util.js');\n>+\n>+js> Object.isExtensible;\n>+function isExtensible() { [native code for Object.isExtensible, arity=1] }\n>+js> expectTypeError(function() { Object.isExtensible() });\n>+js> [undefined, null, true, 1, 'hello'].forEach(function(value) { \n>+  >   expectTypeError(function() { Object.isExtensible(value) }) \n>+  > })\n>+\n>+js> Object.preventExtensions;\n>+function preventExtensions() { [native code for Object.preventExtensions, arity=1] }\n>+js> expectTypeError(function() { Object.preventExtensions() });\n>+js> [undefined, null, true, 1, 'hello'].forEach(function(value) { \n>+  >   expectTypeError(function() { Object.preventExtensions(value) }) \n>+  > })\n>+\n>+js> var x = {};\n>+js> Object.isExtensible(x);\n>+true\n>+js> var y = Object.preventExtensions(x);\n>+js> y === x;\n>+true\n>+js> Object.isExtensible(x);\n>+false\n>+\n>+js> x.a = 1; x.a\n>+js>\n>+\n>+js> x.__defineGetter__('b', function() { return 1 }); x.b\n>+js>",
            "date": "20090601T03:05:09",
            "id": 13
        },
        {
            "author": "rspeyer@gmail.com",
            "body": "Created attachment 381099\nupdates from comment 14 (https://bugzilla.mozilla.org/show_bug.cgi?id=489329#c14)\n\n- added line between methods\n- Added javadoc for ScriptableObject#defineOwnProperty\n- replaced use of `get` with `getProperty` and `has` with `hasProperty` when dealing with property descriptors\n- called ScriptRuntime.toBoolean on the boolean properties of any property descriptors passed in",
            "date": "20090602T16:53:54",
            "id": 14
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "Comment on attachment 381099\nupdates from comment 14 (https://bugzilla.mozilla.org/show_bug.cgi?id=489329#c14)\n\n>diff --git a/src/org/mozilla/javascript/NativeObject.java b/src/org/mozilla/javascript/NativeObject.java\n>index 46cc101..f9f3bdd 100644\n>--- a/src/org/mozilla/javascript/NativeObject.java\n>+++ b/src/org/mozilla/javascript/NativeObject.java\n>@@ -81,6 +81,12 @@ public class NativeObject extends IdScriptableObject\n>                 \"getOwnPropertyNames\", 1);\n>         addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_getOwnPropertyDescriptor,\n>                 \"getOwnPropertyDescriptor\", 2);\n>+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_defineProperty,\n>+                \"defineProperty\", 3);\n>+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_isExtensible,\n>+                \"isExtensible\", 1);\n>+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_preventExtensions,\n>+                \"preventExtensions\", 1);\n>         super.fillConstructorProperties(ctor);\n>     }\n> \n>@@ -273,21 +279,14 @@ public class NativeObject extends IdScriptableObject\n>           case ConstructorId_getPrototypeOf:\n>               {\n>                 Object arg = args.length < 1 ? Undefined.instance : args[0];\n>-                if (!(arg instanceof Scriptable)) {\n>-                    throw ScriptRuntime.typeError1(\"msg.arg.not.object\",\n>-                                                   ScriptRuntime.typeof(arg));\n>-                }\n>-                Scriptable obj = (Scriptable) arg;\n>+                Scriptable obj = ensureScriptable(arg);\n>                 return obj.getPrototype();\n>               }\n>           case ConstructorId_keys:\n>               {\n>                 Object arg = args.length < 1 ? Undefined.instance : args[0];\n>-                if (!(arg instanceof Scriptable)) {\n>-                    throw ScriptRuntime.typeError1(\"msg.arg.not.object\",\n>-                                                   ScriptRuntime.typeof(arg));\n>-                }\n>-                Object[] ids = ((Scriptable) arg).getIds();\n>+                Scriptable obj = ensureScriptable(arg);\n>+                Object[] ids = obj.getIds();\n>                 for (int i = 0; i < ids.length; i++) {\n>                   ids[i] = ScriptRuntime.toString(ids[i]);\n>                 }\n>@@ -296,11 +295,8 @@ public class NativeObject extends IdScriptableObject\n>           case ConstructorId_getOwnPropertyNames:\n>               {\n>                 Object arg = args.length < 1 ? Undefined.instance : args[0];\n>-                if (!(arg instanceof Scriptable)) {\n>-                    throw ScriptRuntime.typeError1(\"msg.arg.not.object\",\n>-                                                   ScriptRuntime.typeof(arg));\n>-                }\n>-                Object[] ids = ((ScriptableObject) arg).getAllIds();\n>+                ScriptableObject obj = ensureScriptableObject(arg);\n>+                Object[] ids = obj.getAllIds();\n>                 for (int i = 0; i < ids.length; i++) {\n>                   ids[i] = ScriptRuntime.toString(ids[i]);\n>                 }\n>@@ -309,25 +305,57 @@ public class NativeObject extends IdScriptableObject\n>           case ConstructorId_getOwnPropertyDescriptor:\n>               {\n>                 Object arg = args.length < 1 ? Undefined.instance : args[0];\n>-                if (!(arg instanceof ScriptableObject)) {\n>-                    // TODO(norris): There's a deeper issue here if\n>-                    // arg instanceof Scriptable. Should we create a new\n>-                    // interface to admit the new ECMAScript 5 operations?\n>-                    throw ScriptRuntime.typeError1(\"msg.arg.not.object\",\n>-                                                   ScriptRuntime.typeof(arg));\n>-                }\n>-                ScriptableObject obj = (ScriptableObject) arg;\n>+                // TODO(norris): There's a deeper issue here if\n>+                // arg instanceof Scriptable. Should we create a new\n>+                // interface to admit the new ECMAScript 5 operations?\n>+                ScriptableObject obj = ensureScriptableObject(arg);\n>                 Object nameArg = args.length < 2 ? Undefined.instance : args[1];\n>                 String name = ScriptRuntime.toString(nameArg);\n>                 Scriptable desc = obj.getOwnPropertyDescriptor(cx, name);\n>                 return desc == null ? Undefined.instance : desc;\n>               }\n>+          case ConstructorId_defineProperty:\n>+              {\n>+                Object arg = args.length < 1 ? Undefined.instance : args[0];\n>+                ScriptableObject obj = ensureScriptableObject(arg);\n>+                Object nameArg = args.length < 2 ? Undefined.instance : args[1];\n>+                String name = ScriptRuntime.toString(nameArg);\n>+                Object descArg = args.length < 3 ? Undefined.instance : args[2];\n>+                ScriptableObject desc = ensureScriptableObject(descArg);\n>+                obj.defineOwnProperty(name, desc);\n>+                return obj;\n>+              }\n>+          case ConstructorId_isExtensible:\n>+              {\n>+                Object arg = args.length < 1 ? Undefined.instance : args[0];\n>+                ScriptableObject obj = ensureScriptableObject(arg);\n>+                return obj.isExtensible();\n>+              }\n>+          case ConstructorId_preventExtensions:\n>+              {\n>+                Object arg = args.length < 1 ? Undefined.instance : args[0];\n>+                ScriptableObject obj = ensureScriptableObject(arg);\n>+                obj.preventExtensions();\n>+                return obj;\n>+              }\n> \n>           default:\n>             throw new IllegalArgumentException(String.valueOf(id));\n>         }\n>     }\n> \n>+    private Scriptable ensureScriptable(Object arg) {\n>+      if ( !(arg instanceof Scriptable) )\n>+        throw ScriptRuntime.typeError1(\"msg.arg.not.object\", ScriptRuntime.typeof(arg));\n>+      return (Scriptable) arg;\n>+    }\n>+\n>+    private ScriptableObject ensureScriptableObject(Object arg) {\n>+      if ( !(arg instanceof ScriptableObject) )\n>+        throw ScriptRuntime.typeError1(\"msg.arg.not.object\", ScriptRuntime.typeof(arg));\n>+      return (ScriptableObject) arg;\n>+    }\n>+\n> // #string_id_map#\n> \n>     @Override\n>@@ -374,6 +402,9 @@ public class NativeObject extends IdScriptableObject\n>         ConstructorId_keys = -2,\n>         ConstructorId_getOwnPropertyNames = -3,\n>         ConstructorId_getOwnPropertyDescriptor = -4,\n>+        ConstructorId_defineProperty = -5,\n>+        ConstructorId_isExtensible = -6,\n>+        ConstructorId_preventExtensions = -7,\n> \n>         Id_constructor           = 1,\n>         Id_toString              = 2,\n>diff --git a/src/org/mozilla/javascript/ScriptableObject.java b/src/org/mozilla/javascript/ScriptableObject.java\n>index 87984f0..a4146d0 100644\n>--- a/src/org/mozilla/javascript/ScriptableObject.java\n>+++ b/src/org/mozilla/javascript/ScriptableObject.java\n>@@ -154,6 +154,9 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>     private static final int SLOT_REMOVE = 3;\n>     private static final int SLOT_MODIFY_GETTER_SETTER = 4;\n>     private static final int SLOT_MODIFY_CONST = 5;\n>+    private static final int SLOT_CONVERT_ACCESSOR_TO_DATA = 6;\n>+\n>+    private boolean isExtensible = true;\n> \n>     private static class Slot implements Serializable\n>     {\n>@@ -574,13 +577,30 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>     public void setGetterOrSetter(String name, int index,\n>                                   Callable getterOrSetter, boolean isSetter)\n>     {\n>+        setGetterOrSetter(name, index, getterOrSetter, isSetter, false);\n>+    }\n>+\n>+    private void setGetterOrSetter(String name, int index, Callable getterOrSetter, boolean isSetter, boolean force)\n>+    {\n>         if (name != null && index != 0)\n>             throw new IllegalArgumentException(name);\n> \n>-        checkNotSealed(name, index);\n>-        GetterSlot gslot = (GetterSlot)getSlot(name, index,\n>-                                               SLOT_MODIFY_GETTER_SETTER);\n>-        gslot.checkNotReadonly();\n>+        if (!force) {\n>+          checkNotSealed(name, index);\n>+        }\n>+\n>+        final GetterSlot gslot;\n>+        if (isExtensible()) {\n>+          gslot = (GetterSlot)getSlot(name, index, SLOT_MODIFY_GETTER_SETTER);\n>+        } else {\n>+          gslot = (GetterSlot)getSlot(name, index, SLOT_QUERY);\n>+          if (gslot == null)\n>+            return;\n>+        }\n>+        \n>+        if (!force) {\n>+          gslot.checkNotReadonly();\n>+        }\n>         if (isSetter) {\n>             gslot.setter = getterOrSetter;\n>         } else {\n>@@ -588,7 +608,7 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>         }\n>         gslot.value = Undefined.instance;\n>     }\n>-    \n>+\n>     /**\n>      * Get the getter or setter for a given property. Used by __lookupGetter__\n>      * and __lookupSetter__.\n>@@ -1477,6 +1497,130 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>     }\n> \n>     /**\n>+     * Defines a property on an object\n>+     *\n>+     * Based on [[DefineOwnProperty]] from 8.12.10 of the spec\n>+     *\n>+     * @param name the name of the property\n>+     * @param desc the new property descriptor, as described in 8.6.1\n>+     */\n>+    public void defineOwnProperty(String name, ScriptableObject desc) {\n>+      Slot slot = getSlot(name, 0, SLOT_QUERY);\n>+      final int attributes;\n>+\n>+      if (slot == null) { // new slot\n>+        if (!isExtensible()) throw ScriptRuntime.typeError(\"msg.not.extensible\");\n>+        slot = getSlot(name, 0, SLOT_MODIFY);\n>+        attributes = applyDescriptorToAttributeBitset(DONTENUM|READONLY|PERMANENT, desc);\n>+      } else {\n>+        checkLegalPropertyRedefinition(name, desc);\n>+        attributes = applyDescriptorToAttributeBitset(getAttributes(name), desc);\n>+      }\n>+\n>+      defineOwnProperty(slot, desc, attributes);\n>+    }\n>+\n>+    private void defineOwnProperty(Slot slot, ScriptableObject desc, int attributes) {\n>+      if (isAccessorDescriptor(desc)) {\n>+        if ( !(slot instanceof GetterSlot) ) \n>+          slot = getSlot(slot.name, 0, SLOT_MODIFY_GETTER_SETTER);\n>+\n>+        GetterSlot gslot = (GetterSlot) slot;\n>+\n>+        if (hasProperty(desc, \"get\")) {\n>+          Object getter = getProperty(desc, \"get\");\n\nBoth hasProperty and getProperty traverse the prototype chain looking for the property. So it's more efficient to call getProperty once and compare the result to NOT_FOUND.\n\n>+          if ( !(getter instanceof Callable) ) {\n>+            throw ScriptRuntime.notFunctionError(getter);\n>+          } else {\n>+            gslot.getter = getter;\n>+          }\n>+        }\n>+        if (hasProperty(desc, \"set\")) {\n>+          Object setter = getProperty(desc, \"set\");\n>+          if ( !(setter instanceof Callable) ) {\n>+            throw ScriptRuntime.notFunctionError(setter);\n>+          } else {\n>+            gslot.setter = setter;\n>+          }\n>+        }\n>+\n>+        gslot.value = Undefined.instance;\n>+        gslot.setAttributes(attributes);\n>+      } else {\n>+        if (slot instanceof GetterSlot && isDataDescriptor(desc)) {\n>+          slot = getSlot(slot.name, 0, SLOT_CONVERT_ACCESSOR_TO_DATA);\n>+        }\n>+\n>+        if (hasProperty(desc, \"value\")) {\n>+          slot.value = getProperty(desc, \"value\");\n>+        }\n>+        slot.setAttributes(attributes);\n>+      }\n>+    }\n>+\n>+\n>+\n>+\n>+    private void checkLegalPropertyRedefinition(String name, ScriptableObject desc) {\n>+      ScriptableObject current = getOwnPropertyDescriptor(Context.getContext(), name);\n>+      if (Boolean.FALSE.equals(getProperty(current, \"configurable\"))) {\n\nI assume you're not calling toBoolean on the properties of current because you know that they will\nbe Boolean objects. Seems like you'd also know that they'd be defined in current rather than in its prototype chain you could call get(). Come to think of it, you don't have to create current at all\nbut instead could just compare against the bits in attributes.\n\n>+        if (hasProperty(desc, \"configurable\") && ScriptRuntime.toBoolean(getProperty(desc, \"configurable\")))\n>+          throw ScriptRuntime.typeError1(\"msg.change.configurable.false.to.true\", name);\n>+        if (hasProperty(desc, \"enumerable\") && !getProperty(current, \"enumerable\").equals(ScriptRuntime.toBoolean(getProperty(desc, \"enumerable\"))))\n>+          throw ScriptRuntime.typeError1(\"msg.change.enumerable.with.configurable.false\", name);\n>+\n>+        if (isGenericDescriptor(desc)) {\n>+          // no further validation required\n>+        } else if (isDataDescriptor(desc) && isDataDescriptor(current)) {\n>+          if (Boolean.FALSE.equals(getProperty(current, \"writable\"))) {\n>+            if (hasProperty(desc, \"writable\") && ScriptRuntime.toBoolean(getProperty(desc, \"writable\")))\n>+              throw ScriptRuntime.typeError1(\"msg.change.writable.false.to.true.with.configurable.false\", name);\n>+\n>+            if (hasProperty(desc, \"value\") && !ScriptRuntime.shallowEq(getProperty(current, \"value\"), getProperty(desc, \"value\"))) \n>+              throw ScriptRuntime.typeError1(\"msg.change.value.with.writable.false\", name);\n>+          }\n>+        } else if (isAccessorDescriptor(desc) && isAccessorDescriptor(current)) {\n>+          if (hasProperty(desc, \"set\") && !ScriptRuntime.shallowEq(getProperty(current, \"set\"), getProperty(desc, \"set\")))\n>+            throw ScriptRuntime.typeError1(\"msg.change.setter.with.configurable.false\", name);\n>+\n>+          if (hasProperty(desc, \"get\") && !ScriptRuntime.shallowEq(getProperty(current, \"get\"), getProperty(desc, \"get\"))) \n>+            throw ScriptRuntime.typeError1(\"msg.change.getter.with.configurable.false\", name);\n>+        } else {\n>+          throw ScriptRuntime.typeError1(\"msg.change.descriptor.type.with.configurable.false\", name);\n\nWhat does this correspond to in the spec? I'm not sure where this comes from.\n\n>+        }\n>+      }\n>+    }\n>+\n>+    private int applyDescriptorToAttributeBitset(int attributes, ScriptableObject desc) {\n>+      if (hasProperty(desc, \"enumerable\")) {\n>+        boolean enumerable = ScriptRuntime.toBoolean(getProperty(desc, \"enumerable\"));\n>+        attributes = (enumerable ? attributes & ~DONTENUM : attributes | DONTENUM);\n>+      }\n>+\n>+      if (hasProperty(desc, \"writable\")) {\n>+        boolean writable = ScriptRuntime.toBoolean(getProperty(desc, \"writable\"));\n>+        attributes = (writable ? attributes & ~READONLY : attributes | READONLY);\n>+      }\n>+\n>+      if (hasProperty(desc, \"configurable\")) {\n>+        boolean configurable = ScriptRuntime.toBoolean(getProperty(desc, \"configurable\"));\n>+        attributes = (configurable ? attributes & ~PERMANENT : attributes | PERMANENT);\n>+      }\n>+\n>+      return attributes;\n>+    }\n>+\n>+    private boolean isDataDescriptor(ScriptableObject desc) {\n>+      return hasProperty(desc, \"value\") || hasProperty(desc, \"writable\");\n>+    }\n>+    private boolean isAccessorDescriptor(ScriptableObject desc) {\n>+      return hasProperty(desc, \"get\") || hasProperty(desc, \"set\");\n>+    }\n>+    private boolean isGenericDescriptor(ScriptableObject desc) {\n>+      return !isDataDescriptor(desc) && !isAccessorDescriptor(desc);\n>+    }\n>+\n>+    /**\n>      * Search for names in a class, adding the resulting methods\n>      * as properties.\n>      *\n>@@ -1576,6 +1720,14 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>         }\n>     }\n> \n>+    public boolean isExtensible() {\n>+      return isExtensible;\n>+    }\n>+\n>+    public void preventExtensions() {\n>+      isExtensible = false;\n>+    }\n>+\n>     /**\n>      * Seal this object.\n>      *\n>@@ -2082,6 +2234,11 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>             if (slot == null) {\n>                 return false;\n>             }\n>+        } else if (!isExtensible()) {\n>+            slot = getSlot(name, index, SLOT_QUERY);\n>+            if (slot == null) {\n>+                return true;\n>+            }\n>         } else {\n>             checkNotSealed(name, index);\n>             // either const hoisted declaration or initialization\n>@@ -2188,6 +2345,10 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>                 !(slot instanceof GetterSlot))\n>                 break lastAccessCheck;\n> \n>+            if (accessType == SLOT_CONVERT_ACCESSOR_TO_DATA &&\n>+                (slot instanceof GetterSlot))\n>+                break lastAccessCheck;\n>+\n>             return slot;\n>         }\n> \n>@@ -2206,7 +2367,8 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>         if (accessType == SLOT_QUERY ||\n>             accessType == SLOT_MODIFY ||\n>             accessType == SLOT_MODIFY_CONST ||\n>-            accessType == SLOT_MODIFY_GETTER_SETTER)\n>+            accessType == SLOT_MODIFY_GETTER_SETTER ||\n>+            accessType == SLOT_CONVERT_ACCESSOR_TO_DATA)\n>         {\n>             // Check the hashtable without using synchronization\n> \n>@@ -2249,6 +2411,9 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>                 } else if (accessType == SLOT_MODIFY_CONST) {\n>                     if (slot != null)\n>                         return slot;\n>+                } else if (accessType == SLOT_CONVERT_ACCESSOR_TO_DATA) {\n>+                    if ( !(slot instanceof GetterSlot) )\n>+                        return slot;\n>                 }\n>             }\n> \n>@@ -2288,49 +2453,52 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>                         // implementation it is harmless with the only\n>                         // complication is the need to replace the added slot\n>                         // if we need GetterSlot and the old one is not.\n>-                        if (accessType == SLOT_MODIFY_GETTER_SETTER &&\n>-                            !(slot instanceof GetterSlot))\n>-                        {\n>-                            GetterSlot newSlot = new GetterSlot(name,\n>-                                    indexOrHash, slot.getAttributes());\n>-                            newSlot.value = slot.value;\n>-                            newSlot.next = slot.next;\n>-                            // add new slot to linked list\n>-                            if (lastAdded != null)\n>-                                lastAdded.orderedNext = newSlot;\n>-                            if (firstAdded == null)\n>-                                firstAdded = newSlot;\n>-                            lastAdded = newSlot;\n>-                            // add new slot to hash table\n>-                            if (prev == slot) {\n>-                                slotsLocalRef[insertPos] = newSlot;\n>-                            } else {\n>-                                prev.next = newSlot;\n>-                            }\n>-                            // other housekeeping\n>-                            slot.wasDeleted = true;\n>-                            slot.value = null;\n>-                            slot.name = null;\n>-                            if (slot == lastAccess) {\n>-                                lastAccess = REMOVED;\n>-                            }\n>-                            slot = newSlot;\n>+\n>+                        Slot newSlot;\n>+\n>+                        if (accessType == SLOT_MODIFY_GETTER_SETTER && !(slot instanceof GetterSlot)) {\n>+                            newSlot = new GetterSlot(name, indexOrHash, slot.getAttributes());\n>+                        } else if (accessType == SLOT_CONVERT_ACCESSOR_TO_DATA && (slot instanceof GetterSlot)) {\n>+                            newSlot = new Slot(name, indexOrHash, slot.getAttributes());\n>                         } else if (accessType == SLOT_MODIFY_CONST) {\n>-                            return null;\n>+                          return null;\n>+                        } else {\n>+                          return slot;\n>                         }\n>-                        return slot;\n>-                    }\n> \n>-                    // Check if the table is not too full before inserting.\n>-                    if (4 * (count + 1) > 3 * slotsLocalRef.length) {\n>-                        slotsLocalRef = new Slot[slotsLocalRef.length * 2 + 1];\n>-                        copyTable(slots, slotsLocalRef, count);\n>-                        slots = slotsLocalRef;\n>-                        insertPos = getSlotIndex(slotsLocalRef.length,\n>-                                indexOrHash);\n>+                        newSlot.value = slot.value;\n>+                        newSlot.next = slot.next;\n>+                        // add new slot to linked list\n>+                        if (lastAdded != null)\n>+                            lastAdded.orderedNext = newSlot;\n>+                        if (firstAdded == null)\n>+                            firstAdded = newSlot;\n>+                        lastAdded = newSlot;\n>+                        // add new slot to hash table\n>+                        if (prev == slot) {\n>+                            slotsLocalRef[insertPos] = newSlot;\n>+                        } else {\n>+                            prev.next = newSlot;\n>+                        }\n>+                        // other housekeeping\n>+                        slot.wasDeleted = true;\n>+                        slot.value = null;\n>+                        slot.name = null;\n>+                        if (slot == lastAccess) {\n>+                            lastAccess = REMOVED;\n>+                        }\n>+                        return newSlot;\n>+                    } else {\n>+                      // Check if the table is not too full before inserting.\n>+                      if (4 * (count + 1) > 3 * slotsLocalRef.length) {\n>+                          slotsLocalRef = new Slot[slotsLocalRef.length * 2 + 1];\n>+                          copyTable(slots, slotsLocalRef, count);\n>+                          slots = slotsLocalRef;\n>+                          insertPos = getSlotIndex(slotsLocalRef.length,\n>+                                  indexOrHash);\n>+                      }\n>                     }\n>                 }\n>-\n>                 Slot newSlot = (accessType == SLOT_MODIFY_GETTER_SETTER\n>                                 ? new GetterSlot(name, indexOrHash, 0)\n>                                 : new Slot(name, indexOrHash, 0));\n>diff --git a/src/org/mozilla/javascript/resources/Messages.properties b/src/org/mozilla/javascript/resources/Messages.properties\n>index 545dc87..6ad9097 100644\n>--- a/src/org/mozilla/javascript/resources/Messages.properties\n>+++ b/src/org/mozilla/javascript/resources/Messages.properties\n>@@ -667,6 +667,32 @@ msg.modify.sealed =\\\n> msg.modify.readonly =\\\n>     Cannot modify readonly property: {0}.\n> \n>+msg.change.configurable.false.to.true =\\\n>+    Cannot change the configurable attribute of \"{0}\" from false to true.\n>+\n>+msg.change.enumerable.with.configurable.false =\\\n>+    Cannot change the enumerable attribute of \"{0}\" because configurable is false.\n>+\n>+msg.change.writable.false.to.true.with.configurable.false =\\\n>+    Cannot change the writable attribute of \"{0}\" from false to true because configurable is false.\n>+\n>+# TODO should we be using msg.modify.readonly here instead?\n\nNo, it's fine to have a separate message given that it's coming from a new ES5 function\n\n>+msg.change.value.with.writable.false =\\\n>+    Cannot change the value of attribute \"{0}\" because writable is false.\n>+\n>+msg.change.getter.with.configurable.false =\\\n>+    Cannot change the get attribute of \"{0}\" because configurable is false.\n>+\n>+msg.change.setter.with.configurable.false =\\\n>+    Cannot change the set attribute of \"{0}\" because configurable is false.\n>+\n>+# TODO not sure about how descriptive this message is\n>+msg.change.descriptor.type.with.configurable.false =\\\n>+    Cannot change type of property \"{0}\" because configurable is false.\n>+\n>+msg.not.extensible =\\\n>+    Cannot add properties to this object because extensible is false.\n>+\n> # TokenStream\n> msg.missing.exponent =\\\n>     missing exponent\n>diff --git a/testsrc/doctests/object.defineproperty.doctest b/testsrc/doctests/object.defineproperty.doctest\n>new file mode 100644\n>index 0000000..e40e972\n>--- /dev/null\n>+++ b/testsrc/doctests/object.defineproperty.doctest\n>@@ -0,0 +1,169 @@\n>+js> load('testsrc/doctests/util.js');\n>+\n>+js> Object.defineProperty\n>+function defineProperty() { [native code for Object.defineProperty, arity=3] }\n>+\n>+js> expectTypeError(function() { Object.defineProperty() });\n>+js> expectTypeError(function() { Object.defineProperty({}) });\n>+js> expectTypeError(function() { Object.defineProperty({}, 'p') });\n>+js> [undefined, null, true, 1, 'hello'].forEach(function(value) { \n>+  >   expectTypeError(function() { Object.defineProperty(value, 'p', {}) }) \n>+  > })\n>+\n>+js> Object.defineProperty({}, 'p', {value:1}).p\n>+1\n>+js> var obj = {}\n>+js> Object.defineProperty(obj, 'a', {\n>+  >   value: 1,\n>+  >   enumerable: false,\n>+  >   writable: false,\n>+  >   configurable: false\n>+  > })  \n>+[object Object]\n>+js> for (var p in obj) print(p); // check it has no enumerable properties\n>+js> obj.a = 2; obj.a; // check that the property is not writable\n>+1\n>+js> delete obj.a; obj.a // check that the property is not deletable\n>+1\n>+\n>+js> var define = Object.defineProperty;\n>+js> var describe = Object.getOwnPropertyDescriptor;\n>+\n>+js> // when define new property with empty descriptor then default values are used for the descriptor\n>+js> var obj = define({}, 'a', {});\n>+js> describe(obj, 'a').toSource()\n>+({writable:false, enumerable:false, configurable:false})\n>+\n>+js> // when define new property with data descriptor then those values are used for the descriptor\n>+js> var obj = define({}, 'a', { value: 2, writable: true });\n>+js> var {value:v, writable:w} = describe(obj, 'a'); [v, w].toSource();\n>+[2, true]\n>+js> obj.a\n>+2\n>+\n>+js> // when define new property with accessor descriptor then those values are used for the descriptor\n>+js> var obj = define({}, 'a', { get: function() { return 3; }, set: function(value) {} });\n>+js> var {get:g, set:s} = describe(obj, 'a'); [g, s].toSource();\n>+[(function () {return 3;}), (function (value) {})]\n>+js> obj.a\n>+3\n>+\n>+js> // when define existing property with empty descriptor then descriptor is left unchanged\n>+js> var descriptor = {value:1, writable:true, enumerable:true, configurable:true};\n>+js> var obj = define({},  'a', descriptor);\n>+js> var obj = define(obj, 'a', {});\n>+js> describe(obj, 'a').toSource()\n>+({value:1, writable:true, enumerable:true, configurable:true})\n>+\n>+js> // when define existing property with same descriptor then descriptor is left unchanged\n>+js> var descriptor = {value:1, writable:true, enumerable:true, configurable:true};\n>+js> var obj = define({},  'a', descriptor);\n>+js> var obj = define(obj, 'a', descriptor);\n>+js> describe(obj, 'a').toSource()\n>+({value:1, writable:true, enumerable:true, configurable:true})\n>+\n>+js> // may not change configurable from false to true\n>+js> expectTypeError(function() {\n>+  >   var obj = define({}, 'a', {configurable : false});\n>+  >   define(obj, 'a',          {configurable : true});\n>+  > });\n>+\n>+js> // may not change enumerable when configurable is false\n>+js> expectTypeError(function() {\n>+  >   var obj = define({}, 'a', {enumerable : true, configurable:false});\n>+  >   define(obj, 'a',          {enumerable : false});\n>+  > });\n>+\n>+js> // may not change writable from false to true when configurable is false\n>+js> expectTypeError(function() {\n>+  >   var obj = define({}, 'a', {writable : false, configurable: false});\n>+  >   define(obj, 'a',          {writable : true});\n>+  > });\n>+\n>+js> // may not change value when writable is false\n>+js> expectTypeError(function() {\n>+  >   var obj = define({}, 'a', {value : 1, writable:false});\n>+  >   define(obj, 'a',          {value : 2});\n>+  > });\n>+\n>+js> // may not change getter when configurable is false\n>+js> expectTypeError(function() {\n>+  >   var obj = define({}, 'a', {get: function() { return 1 }, configurable:false});\n>+  >   define(obj, 'a',          {get: function() { return 1 }});\n>+  > });\n>+\n>+js> // may not change setter when configurable is false\n>+js> expectTypeError(function() {\n>+  >   var obj = define({}, 'a', {set: function(val) {}, configurable:false});\n>+  >   define(obj, 'a',          {set: function(val) {}});\n>+  > });\n>+\n>+js> // may not change from data property to accessor property when configurable is false\n>+js> expectTypeError(function() {\n>+  >   var obj = define({}, 'a', {value : 1, configurable:false});\n>+  >   define(obj, 'a',          {get   : function() { return 1 }});\n>+  > });\n>+\n>+js> // may not change from accessor property to data property when configurable is false\n>+js> expectTypeError(function() {\n>+  >   var obj = define({}, 'a', {get   : function() { return 1 }, configurable:false});\n>+  >   define(obj, 'a',          {value : 1});\n>+  > });\n>+\n>+js> // can change writable from true to false when configurable is false\n>+js> var obj = define({},  'a', {writable:true, configurable:false});\n>+js> var obj = define(obj, 'a', {writable:false});\n>+\n>+js> // can set enumerable to the same value when configuable is false\n>+js> var obj = define({},  'a', {enumerable:true, configurable:false});\n>+js> var obj = define(obj, 'a', {enumerable:true});\n>+\n>+js> // can change from data property to accessor property when configurable is true\n>+js> var obj = define({},  'a', {value : 1, configurable: true});\n>+js> var obj = define(obj, 'a', {get   : function() { return 4 }});\n>+js> obj.a\n>+4\n>+js> describe(obj, 'a').toSource()\n>+({enumerable:false, configurable:true, get:(function () {return 4;})})\n>+\n>+js> // can change from accessor property to data property when configurable is true\n>+js> var obj = define({},  'a', {get   : function() { return 2 }, configurable:true});\n>+js> var obj = define(obj, 'a', {value : 5});\n>+js> obj.a\n>+5\n>+js> describe(obj, 'a').toSource()\n>+({value:5, writable:false, enumerable:false, configurable:true})\n>+\n>+js> // can change enumerable and writable to true when configurable is true\n>+js> var obj = define({},  'a', {writable : false, enumerable : false, configurable:true});\n>+js> var obj = define(obj, 'a', {writable : true,  enumerable : true, configurable:true});\n>+\n>+js> // can change the value if writable is true\n>+js> var obj = define({},  'a', {value:6, writable:true})\n>+js> obj.a\n>+6\n>+js> var obj = define(obj, 'a', {value:7})\n>+js> obj.a\n>+7\n>+\n>+js> // defining a new property should fail loudly when object is not extensible\n>+js> var obj = Object.preventExtensions({});\n>+js> expectTypeError(function() { define(obj, 'a', {value:1}) })\n>+\n>+js> // defining new property should succeed when object is extensible\n>+js> var obj = {}\n>+js> Object.isExtensible(obj);\n>+true\n>+js> obj.a = 8; obj.a\n>+8\n>+\n>+js> // changing existing property should succeed when object is not extensible\n>+js> var obj = define({},  'a', {value:1, writable:true});\n>+js> var obj = Object.preventExtensions(obj);\n>+js> obj.a = 9; obj.a\n>+9\n>+\n>+js> // defined getters and setters must be functions\n>+js> expectTypeError(function() { define({}, 'a', {get:1}); })\n>+js> expectTypeError(function() { define({}, 'a', {set:1}); })\n>+\n>diff --git a/testsrc/doctests/object.extensible.doctest b/testsrc/doctests/object.extensible.doctest\n>new file mode 100644\n>index 0000000..841511d\n>--- /dev/null\n>+++ b/testsrc/doctests/object.extensible.doctest\n>@@ -0,0 +1,30 @@\n>+js> load('testsrc/doctests/util.js');\n>+\n>+js> Object.isExtensible;\n>+function isExtensible() { [native code for Object.isExtensible, arity=1] }\n>+js> expectTypeError(function() { Object.isExtensible() });\n>+js> [undefined, null, true, 1, 'hello'].forEach(function(value) { \n>+  >   expectTypeError(function() { Object.isExtensible(value) }) \n>+  > })\n>+\n>+js> Object.preventExtensions;\n>+function preventExtensions() { [native code for Object.preventExtensions, arity=1] }\n>+js> expectTypeError(function() { Object.preventExtensions() });\n>+js> [undefined, null, true, 1, 'hello'].forEach(function(value) { \n>+  >   expectTypeError(function() { Object.preventExtensions(value) }) \n>+  > })\n>+\n>+js> var x = {};\n>+js> Object.isExtensible(x);\n>+true\n>+js> var y = Object.preventExtensions(x);\n>+js> y === x;\n>+true\n>+js> Object.isExtensible(x);\n>+false\n>+\n>+js> x.a = 1; x.a\n>+js>\n>+\n>+js> x.__defineGetter__('b', function() { return 1 }); x.b\n>+js>",
            "date": "20090604T01:09:17",
            "id": 15
        },
        {
            "author": "rspeyer@gmail.com",
            "body": "(In reply to comment #16)\n\n...snip...\n\n> >+        if (isGenericDescriptor(desc)) {\n> >+          // no further validation required\n> >+        } else if (isDataDescriptor(desc) && isDataDescriptor(current)) {\n> >+          if (Boolean.FALSE.equals(getProperty(current, \"writable\"))) {\n> >+            if (hasProperty(desc, \"writable\") && ScriptRuntime.toBoolean(getProperty(desc, \"writable\")))\n> >+              throw ScriptRuntime.typeError1(\"msg.change.writable.false.to.true.with.configurable.false\", name);\n> >+\n> >+            if (hasProperty(desc, \"value\") && !ScriptRuntime.shallowEq(getProperty(current, \"value\"), getProperty(desc, \"value\"))) \n> >+              throw ScriptRuntime.typeError1(\"msg.change.value.with.writable.false\", name);\n> >+          }\n> >+        } else if (isAccessorDescriptor(desc) && isAccessorDescriptor(current)) {\n> >+          if (hasProperty(desc, \"set\") && !ScriptRuntime.shallowEq(getProperty(current, \"set\"), getProperty(desc, \"set\")))\n> >+            throw ScriptRuntime.typeError1(\"msg.change.setter.with.configurable.false\", name);\n> >+\n> >+          if (hasProperty(desc, \"get\") && !ScriptRuntime.shallowEq(getProperty(current, \"get\"), getProperty(desc, \"get\"))) \n> >+            throw ScriptRuntime.typeError1(\"msg.change.getter.with.configurable.false\", name);\n> >+        } else {\n> >+          throw ScriptRuntime.typeError1(\"msg.change.descriptor.type.with.configurable.false\", name);\n> \n> What does this correspond to in the spec? I'm not sure where this comes from.\n> \n\nThis comes from to 8.10.12 Step 9.a\n\n...snip...",
            "date": "20090604T01:45:06",
            "id": 16
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "(In reply to comment #17)\n> (In reply to comment #16)\n> \n> ...snip...\n> \n> > >+        if (isGenericDescriptor(desc)) {\n> > >+          // no further validation required\n> > >+        } else if (isDataDescriptor(desc) && isDataDescriptor(current)) {\n> > >+          if (Boolean.FALSE.equals(getProperty(current, \"writable\"))) {\n> > >+            if (hasProperty(desc, \"writable\") && ScriptRuntime.toBoolean(getProperty(desc, \"writable\")))\n> > >+              throw ScriptRuntime.typeError1(\"msg.change.writable.false.to.true.with.configurable.false\", name);\n> > >+\n> > >+            if (hasProperty(desc, \"value\") && !ScriptRuntime.shallowEq(getProperty(current, \"value\"), getProperty(desc, \"value\"))) \n> > >+              throw ScriptRuntime.typeError1(\"msg.change.value.with.writable.false\", name);\n> > >+          }\n> > >+        } else if (isAccessorDescriptor(desc) && isAccessorDescriptor(current)) {\n> > >+          if (hasProperty(desc, \"set\") && !ScriptRuntime.shallowEq(getProperty(current, \"set\"), getProperty(desc, \"set\")))\n> > >+            throw ScriptRuntime.typeError1(\"msg.change.setter.with.configurable.false\", name);\n> > >+\n> > >+          if (hasProperty(desc, \"get\") && !ScriptRuntime.shallowEq(getProperty(current, \"get\"), getProperty(desc, \"get\"))) \n> > >+            throw ScriptRuntime.typeError1(\"msg.change.getter.with.configurable.false\", name);\n> > >+        } else {\n> > >+          throw ScriptRuntime.typeError1(\"msg.change.descriptor.type.with.configurable.false\", name);\n> > \n> > What does this correspond to in the spec? I'm not sure where this comes from.\n> > \n> \n> This comes from to 8.10.12 Step 9.a\n> \n> ...snip...\n\nAh, thanks. The \"type\" confused me there as I was thinking runtime types. Perhaps a better error message would be something like \"can't add or remove getters or setters because configurable is false\" (Does that error message cover all the cases?)",
            "date": "20090604T02:28:11",
            "id": 17
        },
        {
            "author": "rspeyer@gmail.com",
            "body": "(In reply to comment #18)\n> (In reply to comment #17)\n> > (In reply to comment #16)\n> > \n> > ...snip...\n> > \n> > > >+        if (isGenericDescriptor(desc)) {\n> > > >+          // no further validation required\n> > > >+        } else if (isDataDescriptor(desc) && isDataDescriptor(current)) {\n> > > >+          if (Boolean.FALSE.equals(getProperty(current, \"writable\"))) {\n> > > >+            if (hasProperty(desc, \"writable\") && ScriptRuntime.toBoolean(getProperty(desc, \"writable\")))\n> > > >+              throw ScriptRuntime.typeError1(\"msg.change.writable.false.to.true.with.configurable.false\", name);\n> > > >+\n> > > >+            if (hasProperty(desc, \"value\") && !ScriptRuntime.shallowEq(getProperty(current, \"value\"), getProperty(desc, \"value\"))) \n> > > >+              throw ScriptRuntime.typeError1(\"msg.change.value.with.writable.false\", name);\n> > > >+          }\n> > > >+        } else if (isAccessorDescriptor(desc) && isAccessorDescriptor(current)) {\n> > > >+          if (hasProperty(desc, \"set\") && !ScriptRuntime.shallowEq(getProperty(current, \"set\"), getProperty(desc, \"set\")))\n> > > >+            throw ScriptRuntime.typeError1(\"msg.change.setter.with.configurable.false\", name);\n> > > >+\n> > > >+          if (hasProperty(desc, \"get\") && !ScriptRuntime.shallowEq(getProperty(current, \"get\"), getProperty(desc, \"get\"))) \n> > > >+            throw ScriptRuntime.typeError1(\"msg.change.getter.with.configurable.false\", name);\n> > > >+        } else {\n> > > >+          throw ScriptRuntime.typeError1(\"msg.change.descriptor.type.with.configurable.false\", name);\n> > > \n> > > What does this correspond to in the spec? I'm not sure where this comes from.\n> > > \n> > \n> > This comes from to 8.10.12 Step 9.a\n> > \n> > ...snip...\n> \n> Ah, thanks. The \"type\" confused me there as I was thinking runtime types.\n> Perhaps a better error message would be something like \"can't add or remove\n> getters or setters because configurable is false\" (Does that error message\n> cover all the cases?)\n\nWell in principle they could just be defining a writable attribute to an existing accessor property, e.g.\n\njs> var obj = Object.defineProperty({}, 'a', {configurable:false, get:function() { return 1 }})\njs> Object.defineProperty(obj, 'a', {writable:false})\n\nWhat about something more explicit:\n'Cannot change property \"a\" from an accessor property to a data property because configurable is false\" \nfor the accessor -> data case, and \n'Cannot change property \"a\" from a data property to an accessor property because configurable is false\" \nfor the other?\n\nOr even:\n'Cannot set value or writable on property \"a\" because it is currently a getter/setter property and configurable is false'\nand\n'Cannot set getter or setter on property \"a\" because it is currently a value/writable property and configurable is false'\n?",
            "date": "20090604T02:47:02",
            "id": 18
        },
        {
            "author": "rspeyer@gmail.com",
            "body": "Created attachment 381475\nupdates from comment 16, 18, 19\n\n- replaced calls to hasProperty, with checks for for NOT_FOUND\n- replaced calls to getProperty(current, ...) with current.get(...)\n- didn't replace current.get() with direct slot attribute checks as that seemed to require duplication and reduced readability of the code, is it worthwhile for efficiency?\n- made error messages more descriptive for changing property data->accessor or accessor->data when configurable is false",
            "date": "20090604T07:40:25",
            "id": 19
        },
        {
            "author": "rspeyer@gmail.com",
            "body": "Created attachment 381478\nupdates from comment 16, 18, 19 again\n\n- same as previous but also removed hasProperty/getProperty pairing from applyDescriptorToAttributeBitset\n- have not attempted to optimise calls to isAccessorProperty/isDataProperty/isGenericProperty. worthwhile?",
            "date": "20090604T08:32:10",
            "id": 20
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "(In reply to comment #19)\n> (In reply to comment #18)\n> > (In reply to comment #17)\n> > > (In reply to comment #16)\n> > > \n> > > ...snip...\n> > > \n> > > > >+        if (isGenericDescriptor(desc)) {\n> > > > >+          // no further validation required\n> > > > >+        } else if (isDataDescriptor(desc) && isDataDescriptor(current)) {\n> > > > >+          if (Boolean.FALSE.equals(getProperty(current, \"writable\"))) {\n> > > > >+            if (hasProperty(desc, \"writable\") && ScriptRuntime.toBoolean(getProperty(desc, \"writable\")))\n> > > > >+              throw ScriptRuntime.typeError1(\"msg.change.writable.false.to.true.with.configurable.false\", name);\n> > > > >+\n> > > > >+            if (hasProperty(desc, \"value\") && !ScriptRuntime.shallowEq(getProperty(current, \"value\"), getProperty(desc, \"value\"))) \n> > > > >+              throw ScriptRuntime.typeError1(\"msg.change.value.with.writable.false\", name);\n> > > > >+          }\n> > > > >+        } else if (isAccessorDescriptor(desc) && isAccessorDescriptor(current)) {\n> > > > >+          if (hasProperty(desc, \"set\") && !ScriptRuntime.shallowEq(getProperty(current, \"set\"), getProperty(desc, \"set\")))\n> > > > >+            throw ScriptRuntime.typeError1(\"msg.change.setter.with.configurable.false\", name);\n> > > > >+\n> > > > >+          if (hasProperty(desc, \"get\") && !ScriptRuntime.shallowEq(getProperty(current, \"get\"), getProperty(desc, \"get\"))) \n> > > > >+            throw ScriptRuntime.typeError1(\"msg.change.getter.with.configurable.false\", name);\n> > > > >+        } else {\n> > > > >+          throw ScriptRuntime.typeError1(\"msg.change.descriptor.type.with.configurable.false\", name);\n> > > > \n> > > > What does this correspond to in the spec? I'm not sure where this comes from.\n> > > > \n> > > \n> > > This comes from to 8.10.12 Step 9.a\n> > > \n> > > ...snip...\n> > \n> > Ah, thanks. The \"type\" confused me there as I was thinking runtime types.\n> > Perhaps a better error message would be something like \"can't add or remove\n> > getters or setters because configurable is false\" (Does that error message\n> > cover all the cases?)\n> \n> Well in principle they could just be defining a writable attribute to an\n> existing accessor property, e.g.\n> \n> js> var obj = Object.defineProperty({}, 'a', {configurable:false,\n> get:function() { return 1 }})\n> js> Object.defineProperty(obj, 'a', {writable:false})\n> \n> What about something more explicit:\n> 'Cannot change property \"a\" from an accessor property to a data property\n> because configurable is false\" \n> for the accessor -> data case, and \n> 'Cannot change property \"a\" from a data property to an accessor property\n> because configurable is false\" \n> for the other?\n\nYes, I like these, thanks.\n\n> \n> Or even:\n> 'Cannot set value or writable on property \"a\" because it is currently a\n> getter/setter property and configurable is false'\n> and\n> 'Cannot set getter or setter on property \"a\" because it is currently a\n> value/writable property and configurable is false'\n> ?",
            "date": "20090604T11:43:30",
            "id": 21
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "Submitted:\n\nChecking in src/org/mozilla/javascript/NativeObject.java;\n/cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/NativeObject.java,v  <--  NativeObject.java\nnew revision: 1.50; previous revision: 1.49\ndone\nChecking in src/org/mozilla/javascript/ScriptableObject.java;\n/cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/ScriptableObject.java,v  <--  ScriptableObject.java\nnew revision: 1.149; previous revision: 1.148\ndone\nChecking in src/org/mozilla/javascript/resources/Messages.properties;\n/cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/resources/Messages.properties,v  <--  Messages.properties\nnew revision: 1.94; previous revision: 1.93\ndone\nRCS file: /cvsroot/mozilla/js/rhino/testsrc/doctests/object.defineproperty.doctest,v\ndone\nChecking in testsrc/doctests/object.defineproperty.doctest;\n/cvsroot/mozilla/js/rhino/testsrc/doctests/object.defineproperty.doctest,v  <--  object.defineproperty.doctest\ninitial revision: 1.1\ndone\nRCS file: /cvsroot/mozilla/js/rhino/testsrc/doctests/object.extensible.doctest,vdone\nChecking in testsrc/doctests/object.extensible.doctest;\n/cvsroot/mozilla/js/rhino/testsrc/doctests/object.extensible.doctest,v  <--  object.extensible.doctest\ninitial revision: 1.1\ndone",
            "date": "20090605T12:09:16",
            "id": 22
        },
        {
            "author": "rspeyer@gmail.com",
            "body": "Created attachment 381889\npatch for Object.create and Object.defineProperties\n\n- added Object.defineProperties and Object.defineProperties\n- moved all validation of new properties into a separated method so it could be done independently\n- small change to ScriptableObject#getOwnPropertyDescriptor so that if the current parent scope is null, it uses this as descriptor's scope\n- also added small change to DoctestsTest so that it also prints out failing tests",
            "date": "20090606T01:31:22",
            "id": 23
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "Comment on attachment 381889\npatch for Object.create and Object.defineProperties\n\n>diff --git a/src/org/mozilla/javascript/NativeObject.java b/src/org/mozilla/javascript/NativeObject.java\n>index f9f3bdd..4be509e 100644\n>--- a/src/org/mozilla/javascript/NativeObject.java\n>+++ b/src/org/mozilla/javascript/NativeObject.java\n>@@ -40,6 +40,8 @@\n>  * ***** END LICENSE BLOCK ***** */\n> \n> package org.mozilla.javascript;\n>+import java.util.Map;\n>+import java.util.LinkedHashMap;\n> \n> /**\n>  * This class implements the Object native object.\n>@@ -87,6 +89,10 @@ public class NativeObject extends IdScriptableObject\n>                 \"isExtensible\", 1);\n>         addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_preventExtensions,\n>                 \"preventExtensions\", 1);\n>+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_defineProperties,\n>+                \"defineProperties\", 2);\n>+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_create,\n>+                \"create\", 2);\n>         super.fillConstructorProperties(ctor);\n>     }\n> \n>@@ -338,22 +344,36 @@ public class NativeObject extends IdScriptableObject\n>                 obj.preventExtensions();\n>                 return obj;\n>               }\n>-\n>-          default:\n>-            throw new IllegalArgumentException(String.valueOf(id));\n>+          case ConstructorId_defineProperties:\n>+              {\n>+                Object arg = args.length < 1 ? Undefined.instance : args[0];\n>+                ScriptableObject obj = ensureScriptableObject(arg);\n>+                Object propsObj = args.length < 2 ? Undefined.instance : args[1];\n>+                Scriptable props = Context.toObject(propsObj, getParentScope());\n>+                obj.defineOwnProperties(ensureScriptableObject(props));\n>+                return obj;\n>         }\n>+          case ConstructorId_create:\n>+              {\n>+                Object arg = args.length < 1 ? Undefined.instance : args[0];\n>+                Scriptable obj = ensureScriptable(arg);\n>+                Object propsObj = args.length < 2 ? Undefined.instance : args[1];\n>+\n>+                ScriptableObject newObject = new NativeObject();\n>+                newObject.setParentScope(this.getParentScope());\n>+                newObject.setPrototype(obj);\n>+\n>+                if (propsObj != Undefined.instance) {\n\nSeems clearer to just check against args.length and define propsObj inside the if.\n\n>+                    Scriptable props = Context.toObject(propsObj, getParentScope());\n>+                    newObject.defineOwnProperties(ensureScriptableObject(props));\n>     }\n> \n>-    private Scriptable ensureScriptable(Object arg) {\n>-      if ( !(arg instanceof Scriptable) )\n>-        throw ScriptRuntime.typeError1(\"msg.arg.not.object\", ScriptRuntime.typeof(arg));\n>-      return (Scriptable) arg;\n>+                return newObject;\n>     }\n> \n>-    private ScriptableObject ensureScriptableObject(Object arg) {\n>-      if ( !(arg instanceof ScriptableObject) )\n>-        throw ScriptRuntime.typeError1(\"msg.arg.not.object\", ScriptRuntime.typeof(arg));\n>-      return (ScriptableObject) arg;\n>+          default:\n>+            throw new IllegalArgumentException(String.valueOf(id));\n>+        }\n>     }\n> \n> // #string_id_map#\n>@@ -405,6 +425,8 @@ public class NativeObject extends IdScriptableObject\n>         ConstructorId_defineProperty = -5,\n>         ConstructorId_isExtensible = -6,\n>         ConstructorId_preventExtensions = -7,\n>+        ConstructorId_defineProperties= -8,\n>+        ConstructorId_create = -9,\n> \n>         Id_constructor           = 1,\n>         Id_toString              = 2,\n>diff --git a/src/org/mozilla/javascript/ScriptableObject.java b/src/org/mozilla/javascript/ScriptableObject.java\n>index 9ac6840..1021cdf 100644\n>--- a/src/org/mozilla/javascript/ScriptableObject.java\n>+++ b/src/org/mozilla/javascript/ScriptableObject.java\n>@@ -1496,6 +1496,21 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>         gslot.setter = setterBox;\n>     }\n> \n>+    public void defineOwnProperties(ScriptableObject props) {\n>+        Object[] ids = props.getIds();\n>+        for (Object id : ids) {\n>+            String name = ScriptRuntime.toString(id);\n>+            Object descObj = props.get(id);\n>+            ScriptableObject desc = ensureScriptableObject(descObj);\n>+            checkValidPropertyDefinition(getSlot(name, 0, SLOT_QUERY), desc);\n\nHmm. Does getSlot actually need \"name\" here rather than \"id\"? In other words, does this work with integer \"names\"?\n\n>+        }\n>+        for (Object id : ids) {\n>+            String name = ScriptRuntime.toString(id);\n>+            ScriptableObject desc = (ScriptableObject) props.get(id);\n>+            defineOwnProperty(name, desc, false);\n>+        }\n>+    }\n>+\n>     /**\n>      * Defines a property on an object\n>      *\n>@@ -1505,15 +1520,20 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>      * @param desc the new property descriptor, as described in 8.6.1\n>      */\n>     public void defineOwnProperty(String name, ScriptableObject desc) {\n>+      defineOwnProperty(name, desc, true);\n>+    }\n>+\n>+    private void defineOwnProperty(String name, ScriptableObject desc, boolean checkValid) {\n>       Slot slot = getSlot(name, 0, SLOT_QUERY);\n>       final int attributes;\n> \n>+      if (checkValid)\n>+        checkValidPropertyDefinition(slot, desc);\n>+      \n>       if (slot == null) { // new slot\n>-        if (!isExtensible()) throw ScriptRuntime.typeError(\"msg.not.extensible\");\n>         slot = getSlot(name, 0, SLOT_MODIFY);\n>         attributes = applyDescriptorToAttributeBitset(DONTENUM|READONLY|PERMANENT, desc);\n>       } else {\n>-        checkLegalPropertyRedefinition(name, desc);\n>         attributes = applyDescriptorToAttributeBitset(getAttributes(name), desc);\n>       }\n> \n>@@ -1529,20 +1549,12 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n> \n>         Object getter = getProperty(desc, \"get\");\n>         if (getter != NOT_FOUND) {\n>-          if ( !(getter instanceof Callable) ) {\n>-            throw ScriptRuntime.notFunctionError(getter);\n>-          } else {\n>             gslot.getter = getter;\n>           }\n>-        }\n>         Object setter = getProperty(desc, \"set\");\n>         if (setter != NOT_FOUND) {\n>-          if ( !(setter instanceof Callable) ) {\n>-            throw ScriptRuntime.notFunctionError(setter);\n>-          } else {\n>             gslot.setter = setter;\n>           }\n>-        }\n> \n>         gslot.value = Undefined.instance;\n>         gslot.setAttributes(attributes);\n>@@ -1559,7 +1571,20 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>       }\n>     }\n> \n>-    private void checkLegalPropertyRedefinition(String name, ScriptableObject desc) {\n>+    private void checkValidPropertyDefinition(Slot slot, ScriptableObject desc) {\n>+      Object getter = getProperty(desc, \"get\");\n>+      if (getter != NOT_FOUND && !(getter instanceof Callable) ) {\n>+        throw ScriptRuntime.notFunctionError(getter);\n>+      }\n>+      Object setter = getProperty(desc, \"set\");\n>+      if (setter != NOT_FOUND && !(setter instanceof Callable) ) {\n>+        throw ScriptRuntime.notFunctionError(setter);\n>+      }\n>+\n>+      if (slot == null) { // new property\n>+        if (!isExtensible()) throw ScriptRuntime.typeError(\"msg.not.extensible\");\n>+      } else {\n>+        String name = slot.name;\n>       ScriptableObject current = getOwnPropertyDescriptor(Context.getContext(), name);\n>       if (Boolean.FALSE.equals(current.get(\"configurable\")) ) {\n>         if (Boolean.TRUE.equals(tryBoolean(getProperty(desc, \"configurable\")))) \n>@@ -1578,10 +1603,10 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>               throw ScriptRuntime.typeError1(\"msg.change.value.with.writable.false\", name);\n>           }\n>         } else if (isAccessorDescriptor(desc) && isAccessorDescriptor(current)) {\n>-          if (changes(current.get(\"set\"), getProperty(desc, \"set\")))\n>+            if (changes(current.get(\"set\"), setter))\n>             throw ScriptRuntime.typeError1(\"msg.change.setter.with.configurable.false\", name);\n> \n>-          if (changes(current.get(\"get\"), getProperty(desc, \"get\"))) \n>+            if (changes(current.get(\"get\"), getter)) \n>             throw ScriptRuntime.typeError1(\"msg.change.getter.with.configurable.false\", name);\n>         } else {\n>           if (isDataDescriptor(current))\n>@@ -1591,6 +1616,7 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>         }\n>       }\n>     }\n>+    }\n> \n>     private static Object tryBoolean(Object value) {\n>       if (value == NOT_FOUND) return NOT_FOUND;\n>@@ -1636,6 +1662,18 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>       return !isDataDescriptor(desc) && !isAccessorDescriptor(desc);\n>     }\n> \n>+    protected Scriptable ensureScriptable(Object arg) {\n>+      if ( !(arg instanceof Scriptable) )\n>+        throw ScriptRuntime.typeError1(\"msg.arg.not.object\", ScriptRuntime.typeof(arg));\n>+      return (Scriptable) arg;\n>+    }\n>+\n>+    protected ScriptableObject ensureScriptableObject(Object arg) {\n>+      if ( !(arg instanceof ScriptableObject) )\n>+        throw ScriptRuntime.typeError1(\"msg.arg.not.object\", ScriptRuntime.typeof(arg));\n>+      return (ScriptableObject) arg;\n>+    }\n>+\n>     /**\n>      * Search for names in a class, adding the resulting methods\n>      * as properties.\n>@@ -2729,7 +2767,8 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n> \n>     protected ScriptableObject getOwnPropertyDescriptor(Context cx, String name) {\n>       Slot slot = getSlot(name, 0, SLOT_QUERY);\n>-      return (slot == null) ? null : slot.getPropertyDescriptor(cx, getParentScope());\n>+      Scriptable scope = getParentScope();\n>+      return (slot == null) ? null : slot.getPropertyDescriptor(cx, (scope == null ? this : scope));\n>     }\n> \n>     // Methods and classes to implement java.util.Map interface\n>diff --git a/testsrc/doctests/object.create.doctest b/testsrc/doctests/object.create.doctest\n>new file mode 100644\n>index 0000000..3ba51d5\n>--- /dev/null\n>+++ b/testsrc/doctests/object.create.doctest\n>@@ -0,0 +1,30 @@\n>+js> load('testsrc/doctests/util.js');\n>+\n>+js> Object.create;\n>+function create() { [native code for Object.create, arity=2] }\n>+\n>+js> expectTypeError(function() { Object.create() });\n>+js> [undefined, null, true, 1, 'hello'].forEach(function(value) { \n>+  >   expectTypeError(function() { Object.create(value) }) \n>+  > })\n>+js> expectTypeError(function() { Object.create({}, null) }) \n>+\n>+js> var obj = Object.create({});\n>+js> var obj = Object.create({}, {});\n>+js> var obj = Object.create({}, undefined);\n>+\n>+js> var orig = {}\n>+js> var next = Object.create(orig);\n>+js> Object.getPrototypeOf(next) === orig;\n>+true\n>+\n>+js> var obj = Object.create({}, {a: {value:1}, b: {value:2}});\n>+js> [obj.a, obj.b].toSource();\n>+[1, 2]\n>+\n>+js> var orig = {a:1};\n>+js> var obj = Object.create(orig, {a:{value:2}, b:{value:3}});\n>+js> [obj.a, obj.b].toSource()\n>+[2, 3]\n>+\n>+js> expectTypeError(function() { Object.create({}, {b: {value:1}, c:1}) });\n>diff --git a/testsrc/doctests/object.defineproperties.doctest b/testsrc/doctests/object.defineproperties.doctest\n>new file mode 100644\n>index 0000000..0541f75\n>--- /dev/null\n>+++ b/testsrc/doctests/object.defineproperties.doctest\n>@@ -0,0 +1,39 @@\n>+js> load('testsrc/doctests/util.js');\n>+\n>+js> Object.defineProperties\n>+function defineProperties() { [native code for Object.defineProperties, arity=2] }\n>+\n>+js> expectTypeError(function() { Object.defineProperties() });\n>+js> expectTypeError(function() { Object.defineProperties({}) });\n>+js> [undefined, null, true, 1, 'hello'].forEach(function(value) { \n>+  >   expectTypeError(function() { Object.defineProperties(value, {}) }) \n>+  > })\n>+\n>+js> Object.defineProperties({}, {p: {value:1}}).p\n>+1\n>+\n>+js> var obj = Object.defineProperties({}, {a: {value:1}, b: {value:2}});\n>+js> [obj.a, obj.b].toSource();\n>+[1, 2]\n>+\n>+js> Object.defineProperties({}, {'wierd name': {value:1}})['wierd name']\n>+1\n>+\n>+js> Object.defineProperties({}, {}).toSource()\n>+({})\n>+\n>+js> var obj = {a:1};\n>+js> var obj = Object.defineProperties(obj, {a:{value:2}, b:{value:3}});\n>+js> [obj.a, obj.b].toSource()\n>+[2, 3]\n>+\n>+js> expectTypeError(function() { Object.defineProperties({}, {a: null}) })\n>+js> expectTypeError(function() { Object.defineProperties({}, {a: 1}) })\n>+js> expectTypeError(function() { Object.defineProperties({}, {a: {get: 1}}) })\n>+\n>+js> var obj = {a:1}\n>+js> expectTypeError(function() { \n>+  >   obj = Object.defineProperties(obj, {b: {value:1}, c:1});\n>+  > });\n>+js> obj.b\n>+js>\n>diff --git a/testsrc/org/mozilla/javascript/tests/DoctestsTest.java b/testsrc/org/mozilla/javascript/tests/DoctestsTest.java\n>index f03343f..8081253 100644\n>--- a/testsrc/org/mozilla/javascript/tests/DoctestsTest.java\n>+++ b/testsrc/org/mozilla/javascript/tests/DoctestsTest.java\n>@@ -93,6 +93,9 @@ public class DoctestsTest {\n>             System.out.println(name + \"(\" + optimizationLevel + \"): \" +\n>                     testsPassed + \" passed.\");\n>             assertTrue(testsPassed > 0);\n>+        } catch (Exception ex) {\n>+          System.out.println(name + \"(\" + optimizationLevel + \"): FAILED due to \"+ex);\n>+          throw ex;\n>         } finally {\n>             Context.exit();\n>         }",
            "date": "20090609T20:58:08",
            "id": 24
        },
        {
            "author": "rspeyer@gmail.com",
            "body": "Created attachment 382834\ncreate, defineProperty and defineProperties, and proper handling of numerical ids\n\nfixed methods to handle numerical property ids correctly",
            "date": "20090611T21:52:36",
            "id": 25
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "Submitted to CVS HEAD. Thanks!",
            "date": "20090612T11:47:39",
            "id": 26
        },
        {
            "author": "rspeyer@gmail.com",
            "body": "Created attachment 383057\npatch for seal, isSealed, freeze and isFrozen\n\nImplements Object.seal, Object.isSealed, Object.freeze and Object.isFrozen",
            "date": "20090613T02:09:28",
            "id": 27
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "Comment on attachment 383057\npatch for seal, isSealed, freeze and isFrozen\n\n>diff --git a/src/org/mozilla/javascript/NativeObject.java b/src/org/mozilla/javascript/NativeObject.java\n>index a46af60..325395f 100644\n>--- a/src/org/mozilla/javascript/NativeObject.java\n>+++ b/src/org/mozilla/javascript/NativeObject.java\n>@@ -93,6 +93,14 @@ public class NativeObject extends IdScriptableObject\n>                 \"defineProperties\", 2);\n>         addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_create,\n>                 \"create\", 2);\n>+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_isSealed,\n>+                \"isSealed\", 1);\n>+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_isFrozen,\n>+                \"isFrozen\", 1);\n>+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_seal,\n>+                \"seal\", 1);\n>+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_freeze,\n>+                \"freeze\", 1);\n>         super.fillConstructorProperties(ctor);\n>     }\n> \n>@@ -364,10 +372,73 @@ public class NativeObject extends IdScriptableObject\n>                 if (args.length > 1 && args[1] != Undefined.instance) {\n>                   Scriptable props = Context.toObject(args[1], getParentScope());\n>                   newObject.defineOwnProperties(cx, ensureScriptableObject(props));\n>-    }\n>+                }\n> \n>                 return newObject;\n>-    }\n>+              }\n>+\n>+          case ConstructorId_isSealed:\n>+              {\n>+                Object arg = args.length < 1 ? Undefined.instance : args[0];\n>+                ScriptableObject obj = ensureScriptableObject(arg);\n>+\n>+                for (Object name: obj.getAllIds()) {\n>+                  Object configurable = obj.getOwnPropertyDescriptor(cx, name).get(\"configurable\");\n>+                  if (Boolean.TRUE.equals(configurable)) \n>+                    return false;\n>+                }\n>+\n>+                return !obj.isExtensible();\n\nHow about testing this first since it's cheap to test?\n\n>+              }\n>+          case ConstructorId_isFrozen:\n>+              {\n>+                Object arg = args.length < 1 ? Undefined.instance : args[0];\n>+                ScriptableObject obj = ensureScriptableObject(arg);\n>+\n>+                for (Object name: obj.getAllIds()) {\n>+                  ScriptableObject desc = obj.getOwnPropertyDescriptor(cx, name);\n>+                  if (Boolean.TRUE.equals(desc.get(\"configurable\"))) \n>+                    return false;\n>+                  if (isDataDescriptor(desc) && Boolean.TRUE.equals(desc.get(\"writable\")))\n>+                    return false;\n>+                }\n>+\n>+                return !obj.isExtensible();\n\nHere too.\n\n>+              }\n>+          case ConstructorId_seal:\n>+              {\n>+                Object arg = args.length < 1 ? Undefined.instance : args[0];\n>+                ScriptableObject obj = ensureScriptableObject(arg);\n>+\n>+                for (Object name: obj.getAllIds()) {\n>+                  ScriptableObject desc = obj.getOwnPropertyDescriptor(cx, name);\n>+                  if (Boolean.TRUE.equals(desc.get(\"configurable\"))) {\n>+                    desc.put(\"configurable\", desc, false);\n>+                    obj.defineOwnProperty(cx, name, desc); \n>+                  }\n>+                }\n>+                obj.preventExtensions();\n\nThe spec has wording \"The above algorithm is specified as a set of sequential steps that include the possibility of an exception being thrown at various intermediate points. Rather than failing after a partial update of O, this function must be implemented such that it either atomically completes all property updates successfully or fails without making any update to the properties of object O.\" Do you know where the exceptions could be thrown, and do you avoid partial updates?\n\nSame question for freeze.\n\n>+\n>+                return obj;\n>+              }\n>+          case ConstructorId_freeze:\n>+              {\n>+                Object arg = args.length < 1 ? Undefined.instance : args[0];\n>+                ScriptableObject obj = ensureScriptableObject(arg);\n>+\n>+                for (Object name: obj.getAllIds()) {\n>+                  ScriptableObject desc = obj.getOwnPropertyDescriptor(cx, name);\n>+                  if (isDataDescriptor(desc) && Boolean.TRUE.equals(desc.get(\"writable\")))\n>+                    desc.put(\"writable\", desc, false);\n>+                  if (Boolean.TRUE.equals(desc.get(\"configurable\")))\n>+                    desc.put(\"configurable\", desc, false);\n>+                  obj.defineOwnProperty(cx, name, desc);\n>+                }\n>+                obj.preventExtensions();\n>+\n>+                return obj;\n>+              }\n>+\n> \n>           default:\n>             throw new IllegalArgumentException(String.valueOf(id));\n>@@ -425,6 +496,10 @@ public class NativeObject extends IdScriptableObject\n>         ConstructorId_preventExtensions = -7,\n>         ConstructorId_defineProperties= -8,\n>         ConstructorId_create = -9,\n>+        ConstructorId_isSealed = -10,\n>+        ConstructorId_isFrozen = -11,\n>+        ConstructorId_seal = -12,\n>+        ConstructorId_freeze = -13,\n> \n>         Id_constructor           = 1,\n>         Id_toString              = 2,\n>diff --git a/src/org/mozilla/javascript/ScriptableObject.java b/src/org/mozilla/javascript/ScriptableObject.java\n>index 15fe398..31ab96c 100644\n>--- a/src/org/mozilla/javascript/ScriptableObject.java\n>+++ b/src/org/mozilla/javascript/ScriptableObject.java\n>@@ -1653,15 +1653,15 @@ public abstract class ScriptableObject implements Scriptable, Serializable,\n>       return attributes;\n>     }\n> \n>-    private boolean isDataDescriptor(ScriptableObject desc) {\n>+    protected boolean isDataDescriptor(ScriptableObject desc) {\n>       return hasProperty(desc, \"value\") || hasProperty(desc, \"writable\");\n>     }\n>-    \n>-    private boolean isAccessorDescriptor(ScriptableObject desc) {\n>+\n>+    protected boolean isAccessorDescriptor(ScriptableObject desc) {\n>       return hasProperty(desc, \"get\") || hasProperty(desc, \"set\");\n>     }\n>-    \n>-    private boolean isGenericDescriptor(ScriptableObject desc) {\n>+\n>+    protected boolean isGenericDescriptor(ScriptableObject desc) {\n>       return !isDataDescriptor(desc) && !isAccessorDescriptor(desc);\n>     }\n> \n>diff --git a/testsrc/doctests/object.freeze.doctest b/testsrc/doctests/object.freeze.doctest\n>new file mode 100644\n>index 0000000..db3f023\n>--- /dev/null\n>+++ b/testsrc/doctests/object.freeze.doctest\n>@@ -0,0 +1,27 @@\n>+js> load('testsrc/doctests/util.js');\n>+\n>+js> Object.freeze;\n>+function freeze() { [native code for Object.freeze, arity=1] }\n>+\n>+js> [undefined, null, true, 1, 'hello'].forEach(function(value) { \n>+  >   expectTypeError(function() { Object.freeze(value) }) \n>+  > })\n>+js> expectTypeError(function() { Object.freeze() })\n>+\n>+js> var x = {}\n>+js> var y = Object.freeze(x)\n>+js> x === y\n>+true\n>+\n>+js> var obj = Object.defineProperty({}, 'a', {configurable:true, writable:true})\n>+js> var _ = Object.freeze(obj)\n>+js> var a = Object.getOwnPropertyDescriptor(obj, 'a');\n>+js> a.configurable\n>+false\n>+js> a.writable\n>+false\n>+js> Object.isExtensible(obj)\n>+false\n>+\n>+js> Object.isFrozen(obj)\n>+true\n>diff --git a/testsrc/doctests/object.isfrozen.doctest b/testsrc/doctests/object.isfrozen.doctest\n>new file mode 100644\n>index 0000000..b2206f9\n>--- /dev/null\n>+++ b/testsrc/doctests/object.isfrozen.doctest\n>@@ -0,0 +1,37 @@\n>+js> load('testsrc/doctests/util.js');\n>+\n>+js> Object.isFrozen\n>+function isFrozen() { [native code for Object.isFrozen, arity=1] }\n>+\n>+js> expectTypeError(function() { Object.isFrozen() });\n>+js> [undefined, null, true, 1, 'hello'].forEach(function(value) { \n>+  >   expectTypeError(function() { Object.isFrozen(value) }) \n>+  > })\n>+\n>+js> Object.isFrozen({})\n>+false\n>+\n>+js> var obj = Object.preventExtensions({});\n>+js> Object.isFrozen(obj);\n>+true\n>+\n>+js> var obj = Object.defineProperty({}, 'a', {configurable:true, writable:false})\n>+js> var _ = Object.preventExtensions(obj);\n>+js> Object.isFrozen(obj);\n>+false\n>+\n>+js> var obj = Object.defineProperty({}, 'a', {configurable:false, writable:true})\n>+js> var _ = Object.preventExtensions(obj);\n>+js> Object.isFrozen(obj);\n>+false\n>+\n>+js> var obj = Object.defineProperty({}, 'a', {configurable:false, writable:false})\n>+js> var _ = Object.preventExtensions(obj);\n>+js> Object.isFrozen(obj);\n>+true\n>+\n>+js> var obj = Object.defineProperty({}, 'a', {configurable:false, set: function(){} })\n>+js> var _ = Object.preventExtensions(obj);\n>+js> Object.isFrozen(obj);\n>+true\n>+\n>diff --git a/testsrc/doctests/object.issealed.doctest b/testsrc/doctests/object.issealed.doctest\n>new file mode 100644\n>index 0000000..275b4ac\n>--- /dev/null\n>+++ b/testsrc/doctests/object.issealed.doctest\n>@@ -0,0 +1,26 @@\n>+js> load('testsrc/doctests/util.js');\n>+\n>+js> Object.isSealed\n>+function isSealed() { [native code for Object.isSealed, arity=1] }\n>+\n>+js> expectTypeError(function() { Object.isSealed() });\n>+js> [undefined, null, true, 1, 'hello'].forEach(function(value) { \n>+  >   expectTypeError(function() { Object.isSealed(value) }) \n>+  > })\n>+\n>+js> Object.isSealed({})\n>+false\n>+\n>+js> var obj = Object.preventExtensions({});\n>+js> Object.isSealed(obj);\n>+true\n>+\n>+js> var obj = Object.defineProperty({}, 'a', {configurable:false});\n>+js> var _ = Object.preventExtensions(obj);\n>+js> Object.isSealed(obj);\n>+true\n>+\n>+js> var obj = Object.defineProperty({}, 'a', {configurable:true});\n>+js> var _ = Object.preventExtensions(obj);\n>+js> Object.isSealed(obj);\n>+false\n>diff --git a/testsrc/doctests/object.seal.doctest b/testsrc/doctests/object.seal.doctest\n>new file mode 100644\n>index 0000000..2f50804\n>--- /dev/null\n>+++ b/testsrc/doctests/object.seal.doctest\n>@@ -0,0 +1,24 @@\n>+js> load('testsrc/doctests/util.js');\n>+\n>+js> Object.seal;\n>+function seal() { [native code for Object.seal, arity=1] }\n>+\n>+js> [undefined, null, true, 1, 'hello'].forEach(function(value) { \n>+  >   expectTypeError(function() { Object.seal(value) }) \n>+  > })\n>+js> expectTypeError(function() { Object.seal() })\n>+\n>+js> var x = {}\n>+js> var y = Object.seal(x)\n>+js> x === y\n>+true\n>+\n>+js> var obj = Object.defineProperty({}, 'a', {configurable:true})\n>+js> var _ = Object.seal(obj)\n>+js> Object.getOwnPropertyDescriptor(obj, 'a').configurable\n>+false\n>+js> Object.isExtensible(obj)\n>+false\n>+\n>+js> Object.isSealed(obj)\n>+true",
            "date": "20090621T00:57:46",
            "id": 28
        },
        {
            "author": "rspeyer@gmail.com",
            "body": "(In reply to comment #29)\n> (From update of attachment 383057 [details])\n...\n> >+          case ConstructorId_seal:\n> >+              {\n> >+                Object arg = args.length < 1 ? Undefined.instance : args[0];\n> >+                ScriptableObject obj = ensureScriptableObject(arg);\n> >+\n> >+                for (Object name: obj.getAllIds()) {\n> >+                  ScriptableObject desc = obj.getOwnPropertyDescriptor(cx, name);\n> >+                  if (Boolean.TRUE.equals(desc.get(\"configurable\"))) {\n> >+                    desc.put(\"configurable\", desc, false);\n> >+                    obj.defineOwnProperty(cx, name, desc); \n> >+                  }\n> >+                }\n> >+                obj.preventExtensions();\n> \n> The spec has wording \"The above algorithm is specified as a set of sequential\n> steps that include the possibility of an exception being thrown at various\n> intermediate points. Rather than failing after a partial update of O, this\n> function must be implemented such that it either atomically completes all\n> property updates successfully or fails without making any update to the\n> properties of object O.\" Do you know where the exceptions could be thrown, and\n> do you avoid partial updates?\n> \n> Same question for freeze.\n...\n\nBy my reading of 8.12.10, this algorithm shouldn't throw any exceptions, and since we create the descriptor ourselves with data properties, the descriptors' setters won't throw. All the properties we're defining attributes on come from getAllIds, so we shouldn't have to worry about a null descriptor (unless another thread in application code deletes a property part-way through, should we worry about that?).",
            "date": "20090621T10:27:26",
            "id": 29
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "No, we shouldn't worry about the multithreaded case. I'll submit these changes. Thanks!",
            "date": "20090621T20:41:50",
            "id": 30
        },
        {
            "author": "rspeyer@gmail.com",
            "body": "Created attachment 386879\nmake isSealed and isFrozen slightly more efficient in the common case\n\ncheck isExtensible at the beginning of the isSealed and isFrozen implementations, as it is fast that will typically be true, making checking all the attributes unnecessary.",
            "date": "20090705T14:50:40",
            "id": 31
        },
        {
            "author": "rspeyer@gmail.com",
            "body": "Created attachment 386880\nmake getOwnPropertyDescriptor and defineProperty work property for arrays\n\nAllows getting and setting attributes on index properties when the array is in dense mode.",
            "date": "20090705T14:58:03",
            "id": 32
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "I saw the org.hamcrest.* references. Are they sufficiently useful with a good license to merit including them in Rhino?",
            "date": "20090708T14:01:45",
            "id": 33
        },
        {
            "author": "rspeyer@gmail.com",
            "body": "The particular hamcrest packages that are used (Is and IsNot) are included in junit. See http://junit.sourceforge.net/javadoc/org/hamcrest/core/package-summary.html\n\n(In reply to comment #34)\n> I saw the org.hamcrest.* references. Are they sufficiently useful with a good\n> license to merit including them in Rhino?",
            "date": "20090708T16:27:39",
            "id": 34
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "Thanks. They're not working for me inside eclipse. I'll investigate.",
            "date": "20090708T16:56:53",
            "id": 35
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "(In reply to comment #32)\n> Created an attachment (id=386879) [details]\n> make isSealed and isFrozen slightly more efficient in the common case\n> \n> check isExtensible at the beginning of the isSealed and isFrozen\n> implementations, as it is fast that will typically be true, making checking all\n> the attributes unnecessary.\n\nCommitted this patch:\n\nChecking in src/org/mozilla/javascript/NativeObject.java;\n/cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/NativeObject.java,v  <--  NativeObject.java\nnew revision: 1.53; previous revision: 1.52\ndone",
            "date": "20090708T16:57:32",
            "id": 36
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "(In reply to comment #36)\n> Thanks. They're not working for me inside eclipse. I'll investigate.\n\nI've resolved the Eclipse issues, run the regression tests, and committed the code:\n\nChecking in src/org/mozilla/javascript/NativeArray.java;\n/cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/NativeArray.java,v  <--  NativeArray.java\nnew revision: 1.102; previous revision: 1.101\ndone\nRCS file: /cvsroot/mozilla/js/rhino/testsrc/doctests/arrays.doctest,v\ndone\nChecking in testsrc/doctests/arrays.doctest;\n/cvsroot/mozilla/js/rhino/testsrc/doctests/arrays.doctest,v  <--  arrays.doctest\ninitial revision: 1.1\ndone\nChecking in testsrc/doctests/object.defineproperty.doctest;\n/cvsroot/mozilla/js/rhino/testsrc/doctests/object.defineproperty.doctest,v  <--  object.defineproperty.doctest\nnew revision: 1.3; previous revision: 1.2\ndone\nChecking in testsrc/doctests/object.getownpropertydescriptor.doctest;\n/cvsroot/mozilla/js/rhino/testsrc/doctests/object.getownpropertydescriptor.doctest,v  <--  object.getownpropertydescriptor.doctest\nnew revision: 1.3; previous revision: 1.2\ndone\nRCS file: /cvsroot/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/NativeArrayTest.java,v\ndone\nChecking in testsrc/org/mozilla/javascript/tests/NativeArrayTest.java;\n/cvsroot/mozilla/js/rhino/testsrc/org/mozilla/javascript/tests/NativeArrayTest.java,v  <--  NativeArrayTest.java\ninitial revision: 1.1\ndone",
            "date": "20090715T15:49:02",
            "id": 37
        },
        {
            "author": "rspeyer@gmail.com",
            "body": "Created attachment 388877\nAllow Object.create to accept null as a first argument\n\nAllow Object.create to accept null as a first argument\n\nThis reflects updates in the spec since Object.create was first implemented.",
            "date": "20090716T07:04:03",
            "id": 38
        },
        {
            "author": "rspeyer@gmail.com",
            "body": "Created attachment 388878\nMake Object.getOwnPropertyDescriptor work for members of builtin objects\n\nPreviously Object.getOwnPropertyDescriptor(Math, \"PI\") returned undefined. \n\nThis patch makes the members of builtin objects have descriptors with \nWritable=true, Enumerable=false, Configurable=true for function properties, and\nWritable=false, Enumerable=false, Configurable=false for non-function properties",
            "date": "20090716T07:12:02",
            "id": 39
        },
        {
            "author": "rspeyer@gmail.com",
            "body": "Created attachment 389384\nadding JSON object\n\nAdded JSON object. Includes some new files (JsonLexer and JsonParser) for parsing JSON source.",
            "date": "20090719T19:45:21",
            "id": 40
        },
        {
            "author": "rspeyer@gmail.com",
            "body": "Comment on attachment 389384\nadding JSON object\n\nMoved to bug 505211",
            "date": "20090720T12:48:48",
            "id": 41
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "Submitted patches from #39 and #40.",
            "date": "20090721T00:43:00",
            "id": 42
        },
        {
            "author": "rspeyer@gmail.com",
            "body": "Created attachment 390393\ncorrected the descriptor properties of built-ins\n\nIn attachment 388878 I had some of the logic inverted. This is fix for that.",
            "date": "20090724T02:07:52",
            "id": 43
        },
        {
            "author": "rspeyer@gmail.com",
            "body": "Created attachment 390629\nensure that getters/setters defined through defineProperty are actually used",
            "date": "20090725T07:24:44",
            "id": 44
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "(In reply to comment #45)\n> Created an attachment (id=390629) [details]\n> ensure that getters/setters defined through defineProperty are actually used\n\nChecking in src/org/mozilla/javascript/ScriptableObject.java;\n/cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/ScriptableObject.java,v  <--  ScriptableObject.java\nnew revision: 1.153; previous revision: 1.152\ndone\nChecking in testsrc/doctests/object.defineproperty.doctest;\n/cvsroot/mozilla/js/rhino/testsrc/doctests/object.defineproperty.doctest,v  <--  object.defineproperty.doctest\nnew revision: 1.4; previous revision: 1.3\ndone",
            "date": "20090727T15:00:08",
            "id": 45
        },
        {
            "author": "rspeyer@gmail.com",
            "body": "Created attachment 390825\nallow getOwnPropertyDescriptor to be called for objects with no scope\n\ne.g. functions returned from Function.bind",
            "date": "20090727T15:42:56",
            "id": 46
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "(In reply to comment #44)\n> Created an attachment (id=390393) [details]\n> corrected the descriptor properties of built-ins\n> \n> In attachment 388878 [details] I had some of the logic inverted. This is fix for that.\n\nIt's writable and configurable only if it is a method? That seems backward, and\nI couldn't see where in the spec it mentioned different behavior for function\nproperties. Can you describe more?",
            "date": "20090727T16:15:26",
            "id": 47
        },
        {
            "author": "rspeyer@gmail.com",
            "body": "(In reply to comment #48)\n> (In reply to comment #44)\n> > Created an attachment (id=390393) [details] [details]\n> > corrected the descriptor properties of built-ins\n> > \n> > In attachment 388878 [details] [details] I had some of the logic inverted. This is fix for that.\n> \n> It's writable and configurable only if it is a method? That seems backward, and\n> I couldn't see where in the spec it mentioned different behavior for function\n> properties. Can you describe more?\n\nWell the last paragraph of section 15 (before 15.1) says: \n\n\"In every case, the length property of a built-in Function object described in this section has the attributes \n{ [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } (and no others). Every other property \n \ndescribed in this section has the attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true } \nunless otherwise specified.\"\n\nLooking through the other properties specified on objects in section 15, it seems that all the non-function properties are \"otherwise specified\" to have all-false descriptors, while function properties all seem to take the default above.",
            "date": "20090727T17:06:17",
            "id": 48
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "Checking in src/org/mozilla/javascript/IdScriptableObject.java;\n/cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/IdScriptableObject.java,v  <--  IdScriptableObject.java\nnew revision: 1.14; previous revision: 1.13\ndone\n(In reply to comment #49)\n> (In reply to comment #48)\n> > (In reply to comment #44)\n> > > Created an attachment (id=390393) [details] [details] [details]\n> > > corrected the descriptor properties of built-ins\n> > > \n> > > In attachment 388878 [details] [details] [details] I had some of the logic inverted. This is fix for that.\n> > \n> > It's writable and configurable only if it is a method? That seems backward, and\n> > I couldn't see where in the spec it mentioned different behavior for function\n> > properties. Can you describe more?\n> \n> Well the last paragraph of section 15 (before 15.1) says: \n> \n> \"In every case, the length property of a built-in Function object described in\n> this section has the attributes \n> { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } (and no\n> others). Every other property \n> \n> described in this section has the attributes { [[Writable]]: true,\n> [[Enumerable]]: false, [[Configurable]]: true } \n> unless otherwise specified.\"\n> \n> Looking through the other properties specified on objects in section 15, it\n> seems that all the non-function properties are \"otherwise specified\" to have\n> all-false descriptors, while function properties all seem to take the default\n> above.\n\nOk, thanks.\n\nChecking in src/org/mozilla/javascript/IdScriptableObject.java;\n/cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/IdScriptableObject.java,v  <--  IdScriptableObject.java\nnew revision: 1.14; previous revision: 1.13\ndone",
            "date": "20090728T02:00:05",
            "id": 49
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "(In reply to comment #47)\n> Created an attachment (id=390825) [details]\n> allow getOwnPropertyDescriptor to be called for objects with no scope\n> \n> e.g. functions returned from Function.bind\n\nChecking in src/org/mozilla/javascript/IdScriptableObject.java;\n/cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/IdScriptableObject.java,v  <--  IdScriptableObject.java\nnew revision: 1.15; previous revision: 1.14",
            "date": "20090728T02:24:32",
            "id": 50
        },
        {
            "author": "rspeyer@gmail.com",
            "body": "Created attachment 391263\nmake defineProperty throw a TypeError when attributes is both data and accessor descriptor\n\nAs per 8.10.5 step 9 of the spec.",
            "date": "20090729T02:24:53",
            "id": 51
        },
        {
            "author": "rspeyer@gmail.com",
            "body": "Created attachment 391276\nFor getters and setters of accessor propeties, make being absent is equivalent to having value undefined\n\nAs per 8.6.1 Table 3.\n\nAssumes attachment 391263 has been applied.",
            "date": "20090729T05:20:44",
            "id": 52
        },
        {
            "author": "rspeyer@gmail.com",
            "body": "Created attachment 391299\nmade getOwnPropertDescriptor use the actual attributes for builtins, rather than the isMethod heuristic",
            "date": "20090729T09:15:41",
            "id": 53
        },
        {
            "author": "rspeyer@gmail.com",
            "body": "Created attachment 391768\nmake Object.defineProperty work for builtin properties\n\nSuch as Math.pow, or JSON.stringify",
            "date": "20090731T01:31:11",
            "id": 54
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "(In reply to comment #52)\n> Created an attachment (id=391263) [details]\n> make defineProperty throw a TypeError when attributes is both data and accessor\n> descriptor\n> \n> As per 8.10.5 step 9 of the spec.\n\nChecking in src/org/mozilla/javascript/ScriptableObject.java;\n/cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/ScriptableObject.java,v  <--  ScriptableObject.java\nnew revision: 1.154; previous revision: 1.153\ndone\nChecking in src/org/mozilla/javascript/resources/Messages.properties;\n/cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/resources/Messages.properties,v  <--  Messages.properties\nnew revision: 1.98; previous revision: 1.97\ndone",
            "date": "20090802T01:40:55",
            "id": 55
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "(In reply to comment #53)\n> Created an attachment (id=391276) [details]\n> For getters and setters of accessor propeties, make being absent is equivalent\n> to having value undefined\n> \n> As per 8.6.1 Table 3.\n> \n> Assumes attachment 391263 [details] has been applied.\n\nChecking in src/org/mozilla/javascript/ScriptableObject.java;\n/cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/ScriptableObject.java,v  <--  ScriptableObject.java\nnew revision: 1.155; previous revision: 1.154\ndone\nChecking in testsrc/doctests/object.defineproperty.doctest;\n/cvsroot/mozilla/js/rhino/testsrc/doctests/object.defineproperty.doctest,v  <--  object.defineproperty.doctest\nnew revision: 1.5; previous revision: 1.4\ndone",
            "date": "20090807T14:05:23",
            "id": 56
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "(In reply to comment #54)\n> Created an attachment (id=391299) [details]\n> made getOwnPropertDescriptor use the actual attributes for builtins, rather\n> than the isMethod heuristic\n\nChecking in src/org/mozilla/javascript/IdScriptableObject.java;\n/cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/IdScriptableObject.java,v  <--  IdScriptableObject.java\nnew revision: 1.16; previous revision: 1.15\ndone\nChecking in src/org/mozilla/javascript/ScriptableObject.java;\n/cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/ScriptableObject.java,v  <--  ScriptableObject.java\nnew revision: 1.156; previous revision: 1.155\ndone\nChecking in testsrc/doctests/object.defineproperty.doctest;\n/cvsroot/mozilla/js/rhino/testsrc/doctests/object.defineproperty.doctest,v  <--  object.defineproperty.doctest\nnew revision: 1.6; previous revision: 1.5\ndone",
            "date": "20090808T20:58:00",
            "id": 57
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "(In reply to comment #55)\n> Created an attachment (id=391768) [details]\n> make Object.defineProperty work for builtin properties\n> \n> Such as Math.pow, or JSON.stringify\n\nChecking in src/org/mozilla/javascript/IdScriptableObject.java;\n/cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/IdScriptableObject.java,v  <--  IdScriptableObject.java\nnew revision: 1.17; previous revision: 1.16\ndone\nChecking in src/org/mozilla/javascript/ScriptableObject.java;\n/cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/ScriptableObject.java,v  <--  ScriptableObject.java\nnew revision: 1.157; previous revision: 1.156\ndone\nChecking in testsrc/doctests/object.defineproperty.doctest;\n/cvsroot/mozilla/js/rhino/testsrc/doctests/object.defineproperty.doctest,v  <--  object.defineproperty.doctest\nnew revision: 1.7; previous revision: 1.6\ndone",
            "date": "20090809T02:57:52",
            "id": 58
        },
        {
            "author": "rspeyer@gmail.com",
            "body": "Created attachment 418627\nmake Object.freeze work with functions, arrays, regexp\n\nsetInstanceIdValue, called by defineOwnProperty, called by freeze, was not handing all id-identifiable properties, and so when freeze tried to freeze them all, setInstanceIdValue was deferring onto IdScriptableObject.setInstanceIdValue, which just throws an IllegalStateException.\n\nI made setInstanceIdValue always handle all the ids that getInstanceIdValue does.",
            "date": "20091221T13:45:37",
            "id": 59
        },
        {
            "author": "norrisboyd@gmail.com",
            "body": "Committed:\n\nChecking in src/org/mozilla/javascript/BaseFunction.java;\n/cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/BaseFunction.java,v  <--  BaseFunction.java\nnew revision: 1.72; previous revision: 1.71\ndone\nChecking in src/org/mozilla/javascript/regexp/NativeRegExp.java;\n/cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/regexp/NativeRegExp.java,v  <--  NativeRegExp.java\nnew revision: 1.112; previous revision: 1.111\ndone\nChecking in src/org/mozilla/javascript/regexp/NativeRegExpCtor.java;\n/cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/regexp/NativeRegExpCtor.java,v  <--  NativeRegExpCtor.java\nnew revision: 1.22; previous revision: 1.21\ndone\nChecking in testsrc/doctests/object.freeze.doctest;\n/cvsroot/mozilla/js/rhino/testsrc/doctests/object.freeze.doctest,v  <--  object.freeze.doctest\nnew revision: 1.2; previous revision: 1.1\ndone",
            "date": "20091222T13:04:13",
            "id": 60
        }
    ],
    "component": "Core",
    "description": "User-Agent:       Opera/9.64 (Macintosh; Intel Mac OS X; U; en) Presto/2.1.1\nBuild Identifier: Rhino 1.7 release 2 2009 03 22\n\nObject.getPrototypeOf should return the prototype of a given object\n\nReproducible: Always\n\nActual Results:  \njs> Object.getPrototypeOf\njs> Object.getPrototypeOf() === undefined;\njs: \"<stdin>\", line 3: uncaught JavaScript runtime exception: TypeError: Cannot find function getPrototypeOf in object function Object() { [native code for Object.Object, arity=1] }\n.\n\tat <stdin>:3\n\njs> [undefined, null, true, 1, 'hello'].every(function(value) {\n  >   try {\n  >     Object.getPrototypeOf(value);\n  >     return false;\n  >   } catch (e if e instanceof TypeError) {\n  >     return true;\n  >   } catch (e) {\n  >     return false;\n  >   }\n  > });\ntrue\njs> [(function(){}), [], {}].every(function(obj) {\n  >   return Object.getPrototypeOf(obj) === obj.__proto__;\n  > });\njs: \"<stdin>\", line 17: uncaught JavaScript runtime exception: TypeError: Cannot find function getPrototypeOf in object function Object() { [native code for Object.Object, arity=1] }\n.\n\tat <stdin>:17\n\tat <stdin>:16\n\njs> function UserDefined() {}\njs> [Date, UserDefined].every(function(type) {\n  >   var instance;\n  >   eval('instance = new '+type.name);\n  >   return Object.getPrototypeOf(instance) === type.prototype;\n  > });\njs: \"<stdin>\", line 25: uncaught JavaScript runtime exception: TypeError: Cannot find function getPrototypeOf in object function Object() { [native code for Object.Object, arity=1] }\n.\n\tat <stdin>:25\n\tat <stdin>:22\n\njs> \n\n\nExpected Results:  \njs> Object.getPrototypeOf;\nfunction getPrototypeOf() { [native code for Object.getPrototypeOf, arity=1] }\njs> Object.getPrototypeOf() === undefined;\ntrue\njs> var nonObjects = [undefined, null, true, 1, 'hello'];\njs> nonObjects.every(function(value) {\n  >   try {\n  >     Object.getPrototypeOf(value);\n  >     return false;\n  >   } catch (e if e instanceof TypeError) {\n  >     return true;\n  >   } catch (e) {\n  >     return false;\n  >   }\n  > });\ntrue\njs> [(function(){}), [], {}].every(function(obj) {\n  >   return Object.getPrototypeOf(obj) === obj.__proto__;\n  > });\ntrue\njs> function UserDefined() {}\njs> [Date, UserDefined].every(function(type) {\n  >   var instance;\n  >   eval('instance = new '+type.name);\n  >   return Object.getPrototypeOf(instance) === type.prototype;\n  > });\ntrue",
    "hasPatch": true,
    "hasScreenshot": false,
    "id": "489329",
    "issuetypeClassified": "RFE",
    "issuetypeTracker": "BUG",
    "priority": "-- normal",
    "product": "Rhino",
    "project": "RHINO",
    "summary": "implement new Object constructor methods from ecmascript 5 spec",
    "systemSpecification": true,
    "version": "other"
}