{
    "comments": [
        {
            "author": "Earwin Burrfoot",
            "body": "Sudden thought. Leave it in contribs, you won't be bound by any other back-compat policies besides common sense. :)",
            "date": "2009-06-01T16:30:35.934+0000",
            "id": 0
        },
        {
            "author": "Paul Elschot",
            "body": "From a bit of a distance:\n\nYou could consider putting everything in o.a.l.trie .\n\nI'd prefer to have explicit class names containing Long, Int etc, and also containing Trie.\n\nI don't know the details of the tokenizing, but AbstractTrieField sounds just right.\n\n",
            "date": "2009-06-01T19:38:46.239+0000",
            "id": 1
        },
        {
            "author": "Michael McCandless",
            "body": "bq. I want to move it to core before release of 2.9\n\n+1!\n\nbq. There are now classes called LongTrieRangeQuery, IntTrieRangeQuery, how should they be called in core?\n\nI prefer to not use \"trie\" in the names (package and classes)... that\nterm very much describes what's under-the-hood in these classes (how\nthey are implemented), whereas I think [generally] names should\ndescribe how the class is intended to be used.  So I prefer\n\"Long[Numeric]RangeQuery\" over \"LongTrieRangeQuery\".\n\nI'd also like to rename RangeQuery to something else, with this\nchange.  EG TermRangeQuery... to emphasize that you use it for\nnon-numbers.  The javadocs of TermRangeQuery should point to\nInt/LongRangeQuery as strongly preferred for numeric ranges.\n\nbq. Maybe the pairs of classes for indexing and searching should be moved into one class\n\nI think separate classes for int, long, float, double is better.\n\nbq. TrieUtils move into o.a.l.util? or document or?\n\nMaybe document?\n\nbq. Move TokenStreams into o.a.l.analysis, ShiftAttribute into o.a.l.analysis.tokenattributes?\n\nThat sounds good?\n\nbq. If we rename the classes, should Solr stay with Trie (because there are different impls)?\n\nWell, Solr should decide ;)\n\nBut: why are there different impls for Solr?\n\nbq. Maybe add a subclass of AbstractField, that automatically creates these TokenStreams and omits norms/tf per default for easier addition to Document instances?\n\n+1\n\nFor a numeric field where one will sort or do range filtering, Trie*\nought to be the default.  But, unfortunately, the steps needed to make\nuse of Trie* are numerous:\n\n  * Add your field to your doc with the LongTrieTokenStream\n\n  * When you want to sort, pass the TrieUtils.FIELD_CACHE_LONG_PARSER\n    to your SortField\n\n  * When you want to filter by range, instantiate\n    LongTrieRangeFilter.  You'll have to subclass QueryParser to do\n    this for the right fields.\n\n  * When you want to display values, you must also pass the trie parser\n     when populating the FieldCache\n\nIdeally, one would simply use, say, LongNumericField (subclass of\nAbstractField) at indexing time, Lucene would \"remember\" this\nin the index (this is obviously missing today), and then when you\nsort, retrieve value, and create queries from QueryParser, all these\nplaces would \"know\" that this is a trie field and simply do the right\nthing, by default.\n\n(Aside: I just noticed the code fragment in the javadocs for\nLongTrieTokenStream won't compile, because the setValue method is not\navailable for TokenStream; the stream should be defined as\nLongTrieTokenStream, I think?; same with IntTrieTokenStream)\n",
            "date": "2009-06-02T12:59:13.370+0000",
            "id": 2
        },
        {
            "author": "Uwe Schindler",
            "body": "{quote}\n(Aside: I just noticed the code fragment in the javadocs for\nLongTrieTokenStream won't compile, because the setValue method is not\navailable for TokenStream; the stream should be defined as\nLongTrieTokenStream, I think?; same with IntTrieTokenStream)\n{quote}\n\nI fixed this :-) Thanks!\n\n{quote}\nbq. If we rename the classes, should Solr stay with Trie (because there are different impls)?\n\nWell, Solr should decide \n\nBut: why are there different impls for Solr?\n{quote}\n\nI only added this here, to know, that Solr already started to implement this. In Solr there are three different impls:\n- Trie (of course)\n- Text-only numbers (do not work with range queries, but can be used for sorting etc.)\n- A binary encoding (also used by LocalLucene at the moment), that is sortable. This can be used for RangeQueries, but sorting is slow (because they have no parser, and at the time it was implemented, SortField had no parser support)\n\nThe problem, because of backwards compatibility they need to be preserved (possibility to read old indexes).\n\nbq. I think separate classes for int, long, float, double is better.\n\nTwo more... The problem, all these classes have exact the same impl internally and this is code duplication and hard to maintain. Maybe we use a static factory instead of same Ctor. By this the name is different, but it just creates the correct instance of always the same class: NumericRangeQuery.newFloatRange(Float a, Float b, precisionStep) and so on. Same for the TokenStreams (and the Field?)\n\n{quote}\nIdeally, one would simply use, say, LongNumericField (subclass of\nAbstractField) at indexing time, Lucene would \"remember\" this\nin the index (this is obviously missing today), and then when you\nsort, retrieve value, and create queries from QueryParser, all these\nplaces would \"know\" that this is a trie field and simply do the right\nthing, by default.\n{quote}\n\nFor that we need the type information in the index and for that the new Field/Document classes. Hopefully Michael will get this working soonly.\n\n{quote}\nWhen you want to sort, pass the TrieUtils.FIELD_CACHE_LONG_PARSER\nto your SortField \n{quote}\n\nOr add new SortField types.\n\nThe problem with all this: For old indexes, we need some backwards compatibility. Ideally we would just create numeric fields in the new way and reuse e.g. SortField.INT for this. But this cannot be done. Or even, replace the FieldCache parsers by the trie ones. But this cannot be done at the moment.\n\n{quote}\nI'd also like to rename RangeQuery to something else, with this\nchange. EG TermRangeQuery... to emphasize that you use it for\nnon-numbers. The javadocs of TermRangeQuery should point to\nInt/LongRangeQuery as strongly preferred for numeric ranges.\n{quote}\n\nCool. For the others, too (FieldCacheRangeQuery).\n\nThere is a lot more to decide, I will keep this issue open a little bit before starting to work to collect ideas!",
            "date": "2009-06-02T13:39:27.443+0000",
            "id": 3
        },
        {
            "author": "Michael McCandless",
            "body": "{quote}\nIn Solr there are three different impls:\n\nTrie (of course)\nText-only numbers (do not work with range queries, but can be used for sorting etc.)\nA binary encoding (also used by LocalLucene at the moment), that is sortable. This can be used for RangeQueries, but sorting is slow (because they have no parser, and at the time it was implemented, SortField had no parser support)\n{quote}\n\nAhh OK, this is just Solr's pre-existing numeric field support.  (I\nhad thought you meant Solr had a different impl for Trie).\n\nbq. The problem, because of backwards compatibility they need to be preserved (possibility to read old indexes).\n\nThis is indeed quite a challenge.  Actually is there anything in Trie\nthat encodes which version of the format is indexed in a given\nsegment?  (So that if we do every change the indexed format, we can\nbump a version somewhere to keep back compat).\n\nbq. Maybe we use a static factory instead of same Ctor. By this the name is different, but it just creates the correct instance of always the same class: NumericRangeQuery.newFloatRange(Float a, Float b, precisionStep) and so on. Same for the TokenStreams (and the Field?)\n\nThat sounds like a good approach?\n\n{quote}\n> When you want to sort, pass the TrieUtils.FIELD_CACHE_LONG_PARSER\n> to your SortField\n\nOr add new SortField types.\n\nThe problem with all this: For old indexes, we need some backwards compatibility. Ideally we would just create numeric fields in the new way and reuse e.g. SortField.INT for this. But this cannot be done. Or even, replace the FieldCache parsers by the trie ones. But this cannot be done at the moment.\n{quote}\n\nI wonder if we could handle this by adding a setting in FieldInfo?\nIe, to record that \"this numeric field was indexed as a trie\".  Then,\nwhen we need to get the parser for SortField.INT, we'd check the\nFieldInfo to see which parser to use.  This could also handle\nback-compat, ie if we change the trie format being written we'd change\nthe setting and segment merging would gradually uprade previously\nindexed fields.\n\n{quote}\n> I'd also like to rename RangeQuery to something else, with this\n> change. EG TermRangeQuery... to emphasize that you use it for\n> non-numbers. The javadocs of TermRangeQuery should point to\n> Int/LongRangeQuery as strongly preferred for numeric ranges.\n\nCool. For the others, too (FieldCacheRangeQuery).\n{quote}\n\nYes.\n",
            "date": "2009-06-09T17:14:10.777+0000",
            "id": 4
        },
        {
            "author": "Michael McCandless",
            "body": "bq. NumericRangeQuery.newFloatRange(Float a, Float b, precisionStep) and so on.\n\nCould we also do this for a \"term range\"?  Then, we could have a single RangeQuery that rewrites to the right impl based on what kind of range you are doing?\n\n(And in fact it could fold in FieldCacheRangeFilter too).",
            "date": "2009-06-10T21:40:12.240+0000",
            "id": 5
        },
        {
            "author": "Uwe Schindler",
            "body": "I am currently preparing a first patch for NumericRangeQuery-to-core.\n\nThe class NumericUtils (former TrieUtils) should be in o.a.l.util or o.a.l.document? At the moment, the public part of this class is only interesting to retrieve Parsers or SortField instances. But the latter can be refactored, to SortField.TRIE_XXX (not good name, as TRIE no longer used) and the parser instances can be added to FieldCache.\n\nFor indexing or querying it is not required for end users, one can use NumericTokenStream and NumericRangeQuery for all his needs.\n\nSo NumberUtils is more internal than before.\n\nAny thoughts?",
            "date": "2009-06-14T10:22:27.216+0000",
            "id": 6
        },
        {
            "author": "Uwe Schindler",
            "body": "Here my own thoughts:\n\nbq. But the latter can be refactored, to SortField.TRIE_XXX (not good name, as TRIE no longer used) and the parser instances can be added to FieldCache.\n\nFrom the API of FieldCache and sorting, in my opinion, it was always not a good idea, to link the encoding in index, to the impl everywhere.\n\n- deprecate SortField.INT and use SortField.PLAIN_TEXT_INT instead and so on\n- use SortField.PREFIX_ENCODED_INT for the trie ones (better name, this is the internal encoding name from TrieUtils)\n- the default parsers (private) in FieldCache renaming to also PlainText* (but accessible)\n- add TrieUtils.XxxParser to FieldCache (but accessible)\n- re-use INT  (and so on) in Sort and cache code, where the data type is meant (we already have this in lots of code around), but where the encoding is meant use PLAIN_TEXT_* vs. PREFIX_ENCODED_*.\n\nI know these are hard changes, but we had a lot of productivity in the past here (thanks Shai, Jason, Michael), so there are a lot of new APIs that are very much decoupled from the underlying encoding. This would again rename a lot of internal parts. But because of deprecation, this could be done in-line with Shai's and Michael's and Jason's changes here.\n\n(sorry for lots of edits in the mailing list, this is much productive thoughts)",
            "date": "2009-06-14T10:42:01.878+0000",
            "id": 7
        },
        {
            "author": "Yonik Seeley",
            "body": "bq.  use SortField.PREFIX_ENCODED_INT for the trie ones\n\nThis needlessly couples the Trie stuff strongly to the SortField stuff.  Something along the lines of the current TrieUtils.getIntSortField(fname, reverse) seems preferable.\n\nbq. add TrieUtils.XxxParser to FieldCache (but accessible)\n\nThe Trie parsers belong in the Trie class.\n\nbq. re-use INT (and so on) in Sort and cache code, where the data type is meant (we already have this in lots of code around), but where the encoding is meant use PLAIN_TEXT_* vs. PREFIX_ENCODED_*.\n\nI didn't understand that sentence.\n\nAs far as what package it makes sense to go in... what about an analysis.numeric package?\n\nAs a general comment, moving TrieRange to core should be moving it to the core and perhaps renaming the classes if we can think of a better name.  Some of the other stuff belongs in a different issue.\n",
            "date": "2009-06-14T14:02:35.865+0000",
            "id": 8
        },
        {
            "author": "Uwe Schindler",
            "body": "{quote}\nbq. use SortField.PREFIX_ENCODED_INT for the trie ones\n\nThis needlessly couples the Trie stuff strongly to the SortField stuff. Something along the lines of the current TrieUtils.getIntSortField(fname, reverse) seems preferable.\n\nbq. add TrieUtils.XxxParser to FieldCache (but accessible)\n\nThe Trie parsers belong in the Trie class.\n\nbq. re-use INT (and so on) in Sort and cache code, where the data type is meant (we already have this in lots of code around), but where the encoding is meant use PLAIN_TEXT_* vs. PREFIX_ENCODED_*.\n\nI didn't understand that sentence.\n{quote}\n\nBut on the other hand SortField.INT is also strongly linked to the plain text encoding of these tokens. My proposal was to unlink the index encoding of numeric data types from the sorting/field cache code and its constants. So it should not make a difference if you encoded the long using Integer.toString() or TrieUtils, in both cases, sorting code is identical, only the parser is different.\n\nBecause of this, if we stay with SortField.INT and so on, I would tend to make the according Parser/FieldCache a required arg of SortField, defaulting to the current parsers for the deprecated backwards-compatibility.\n\nSo one using new code must always specify the parser when using SortField.INT (SortField.AUTO is already deprectaed so no problem). The same with FieldCache: always specify the parser when getting an instance. For that the current default parsers should be made public accessible.\n\nbq. As far as what package it makes sense to go in... what about an analysis.numeric package\n\nTrieUtils is used in analysis and searching, this is why I tend to util. The NumericTokenStream is in analysis (in my not-yet-realeased patch), ShiftAttribute in analysis.tokenattributes and TrieRangeQuery/Filter in search.\n\nbq. As a general comment, moving TrieRange to core should be moving it to the core and perhaps renaming the classes if we can think of a better name. Some of the other stuff belongs in a different issue.\n\nI think this is correct. I will post a patch soon, that leaves TrieUtils alive.",
            "date": "2009-06-14T14:17:51.481+0000",
            "id": 9
        },
        {
            "author": "Yonik Seeley",
            "body": "bq. But on the other hand SortField.INT is also strongly linked to the plain text encoding of these tokens. \n\nRight - I agree that's not good, and SortField.INT can be misleading.\n\nbq. Because of this, if we stay with SortField.INT and so on, I would tend to make the according Parser/FieldCache a required arg of SortField, defaulting to the current parsers for the deprecated backwards-compatibility.\n\nThat makes sense.  I think it also makes sense (in addition) to keep the factory-like method like TrieUtils.getSortField() that instantiates the right SortField for the user based on the trie params given (like precisionStep and friends).",
            "date": "2009-06-14T14:40:31.883+0000",
            "id": 10
        },
        {
            "author": "Uwe Schindler",
            "body": "Here is a first patch, just for initial review of the API.\n- Only 5 new classes in core (NumericRangeQuery, NumericRangeFilter [each with factory for data types], NumericTokenStream [with one ctor using precStep, various setValue() methods], ShiftAttribute, TrieUtils)\n- TrieUtils still by that name, because a new name is not yet thought about (and how to deprecate NumberUtils from solr in contrib/spatial, deprecate o.a.l.document.NumberTools)\n- All tests rewritten & pass\n- Javadocs still incomplete and need to be rewritten (add package.html from contrib to search's/analysis' package.html and so on)\n\nYou may ask, why I added these static factories to NumericRangeQuery/Filter, one could directly instantiate the class using any subclass of java.lang.Number? Because type safety to prevent people from doing things like new NumericRangeQuery(field,precStep,new Long(val1),new Float(val2)) which may lead to undefined behaviour. The second problem is missing type safety with auto-boxing in Java 5.",
            "date": "2009-06-14T16:13:34.649+0000",
            "id": 11
        },
        {
            "author": "Uwe Schindler",
            "body": "Updated patch:\n- now with extended JavaDocs\n- additional tests for float/doubles\n- additional tests for equals/hashcode\n- changes.txt\n- lot of reformatting\n\nThe only open point is the name of TrieUtils, any idea for package and/or name?\n\nChanges to FieldCache and SortField to always require a parser (see discussion with Yonik), which is a new case to be openend after this.",
            "date": "2009-06-15T18:12:19.214+0000",
            "id": 12
        },
        {
            "author": "Michael McCandless",
            "body": "bq. So one using new code must always specify the parser when using SortField.INT (SortField.AUTO is already deprectaed so no problem). \n\nThis will apply to int/long/float/double as well right?  How would you\ndo this (require a parser for only numeric sorts) back-compatibly?  EG,\nthe others (String, DOC, etc.) don't require a parser.\n\nWe could alternatively make NumericSortField (subclassing SortField),\nthat just uses the right parser?\n\nDid you think about / decide against making a NumericField (that'd set\nthe right tokenStream itself)?\n\nOther questions/comments:\n\n  * Could we change ShiftAttribute -> NumericShiftAttribute?\n\n  * How about oal.util.NumericUtils instead of TrieUtils?\n\n  * Can we rename RangeQuery -> TextRangeQuery (TermRangeQuery), to\n    make it clear that its range checking is by Term sort order.\n\n  * Should we support byte/short for trie indexed fields as well?\n    (Since SortField, FieldCache support these numeric types too...).\n",
            "date": "2009-06-15T18:30:26.263+0000",
            "id": 13
        },
        {
            "author": "Michael McCandless",
            "body": "bq. The only open point is the name of TrieUtils, any idea for package and/or name?\n\nI think NumericUtils?  (I'd like the naming to be consistent w/\nNumericRangeQuery, NumericTokenStream, since it's very much a public\nAPI, ie users must interact directly with it to get their SortField\n(maybe) and FieldCache parser).\n\nLeaving it util seems OK, since it's used by analysis & searching.\n",
            "date": "2009-06-15T18:35:43.377+0000",
            "id": 14
        },
        {
            "author": "Yonik Seeley",
            "body": "bq. This will apply to int/long/float/double as well right? How would you do this (require a parser for only numeric sorts) back-compatibly? EG, the others (String, DOC, etc.) don't require a parser.\n\nAllow passing parser==null to get the default?\n\nbq. We could alternatively make NumericSortField (subclassing SortField), that just uses the right parser?\n\nA factory method TrieUtils.getSortField() could also return the right SortField.\n\n",
            "date": "2009-06-15T18:42:58.247+0000",
            "id": 15
        },
        {
            "author": "Uwe Schindler",
            "body": "{quote}\nbq. This will apply to int/long/float/double as well right? How would you do this (require a parser for only numeric sorts) back-compatibly? EG, the others (String, DOC, etc.) don't require a parser.\n\nMike: This will apply to int/long/float/double as well right? How would you\ndo this (require a parser for only numeric sorts) back-compatibly? EG,\nthe others (String, DOC, etc.) don't require a parser.\n\nYonik: Allow passing parser==null to get the default?\n\nbq. We could alternatively make NumericSortField (subclassing SortField), that just uses the right parser?\n\nA factory method TrieUtils.getSortField() could also return the right SortField.\n{quote}\n\nI want to move this into a new issue after, I will open one.\n\nNevertheless, I would like to remove emphasis from NumericUtils (which is in realyity a helper class). So I want to make the current human-readable numeric parsers public and also add the trie parsers to FieldCache.\n\nThe SortField factory is then the only parts really needed in NumericUtils, but not really. The parser is a singleton, works for all trie fields and could also live somewhere else or nowhere at all, if the Parsers all stay in FieldCache.\n\nbq. Should we support byte/short for trie indexed fields as well? (Since SortField, FieldCache support these numeric types too...). \n\nFor bytes, TrieRange is not very interesting, for shorts, maybe, but I would subsume them during indexing as simple integers. You could not speedup searching, but limit index size a little bit.\n\nbq. Could we change ShiftAttribute -> NumericShiftAttribute?\n\nNo problem, I do this. There is also missing the link from the TokenStream in the javadocs to this, see also my reply in java-dev to Grants mail.\n\nbq. Can we rename RangeQuery -> TextRangeQuery (TermRangeQuery), to make it clear that its range checking is by Term sort order.\n\nWe can do this and deprecate the old one, but I added a note to Javadocs (see patch). I would do this outside of this issue.\n\nbq. How about oal.util.NumericUtils instead of TrieUtils?\n\nThat was my first idea, too. What to do with o.a.l.doc.NumberTools (deprecate?). And also update contrib/spatial to use NumericUtils instead of the copied and not really goo NumberUtils from Solr (Yonik said, it was written at a very early stage, and is not effective with UTF-8 encoding and the TermEnum posioning with the term prefixes). It would be a index-format change for spatial, but as the code was not yet released (in Lucene), the Lucene version should not use NumberUtils at all.",
            "date": "2009-06-15T19:22:52.807+0000",
            "id": 16
        },
        {
            "author": "Uwe Schindler",
            "body": "bq. Did you think about / decide against making a NumericField (that'd set the right tokenStream itself)?\n\nThe problem currently is:\n- Field is final and so I must extend AbstractField. But some methods of Document return Field and not AbstractField.\n- NumericField would only work for indexing, but when retrieving from index (stored fields), it would change to Field.\n\nMaybe we should move this after the index-specific schemas and so on. Or document, that it can be only used for indexing.\n\nBy the way: How do you like the factories in NumericRangeQuery and the setValue methods, working like StringBuffer.append() in NumericTokenStream? This makes it really easy to index.\n\nThe only good thing of NumericField would be the possibility to automatically disable TF and Norms per default when indexing.",
            "date": "2009-06-15T19:28:18.067+0000",
            "id": 17
        },
        {
            "author": "Uwe Schindler",
            "body": "I think, I remove the ShiftAttribute in complete, its really useless. Maybe, I add a getShift() method to NumericUtils, that returns the shift value of a Token/String. See java-dev mailing with Yonik.",
            "date": "2009-06-15T19:53:27.353+0000",
            "id": 18
        },
        {
            "author": "Michael McCandless",
            "body": "OK let's open a new issue for how to best integrate/default SortField\nand FieldCache.\n\nbq. Nevertheless, I would like to remove emphasis from NumericUtils (which is in realyity a helper class).\n\n+1\n\nbq. For bytes, TrieRange is not very interesting, for shorts, maybe, but I would subsume them during indexing as simple integers. You could not speedup searching, but limit index size a little bit.\n\nWell, a RangeQuery on a \"plain text\" byte or short field requires\nsneakiness (knowing that you must zero-pad; keeping\ndocument.NumberUtils around); I think it's best if NumericXXX in\nLucene handles all of java's native numeric types.  And you want a\nbyte[] or short[] out of FieldCache (to not waste RAM having to\nupgrade to an int[]).\n\nWe can do this under the (a?) new issue too...\n\nbq. The SortField factory is then the only parts really needed in NumericUtils, but not really. The parser is a singleton, works for all trie fields and could also live somewhere else or nowhere at all, if the Parsers all stay in FieldCache.\n\n(Under a new issue, but...) I'm not really a fan of leaving the parser\nin FieldCache and expecting a user to \"know\" to create the SortField\nwith that parser.  NumericSortField would make it much more consumable\nto \"direct\" Lucene users.\n\n{quote}\nbq. Can we rename RangeQuery -> TextRangeQuery (TermRangeQuery), to make it clear that its range checking is by Term sort order.\n\nWe can do this and deprecate the old one, but I added a note to Javadocs (see patch). I would do this outside of this issue.\n{quote}\n\nOK.\n\nOne benefit of a rename is it's a reminder to users on upgrading to\nconsider whether they should in fact switch to NumericRangeQuery.\n\n{quote}\nbq. How about oal.util.NumericUtils instead of TrieUtils?\n\nThat was my first idea, too. What to do with o.a.l.doc.NumberTools (deprecate?). And also update contrib/spatial to use NumericUtils instead of the copied and not really goo NumberUtils from Solr (Yonik said, it was written at a very early stage, and is not effective with UTF-8 encoding and the TermEnum posioning with the term prefixes). It would be a index-format change for spatial, but as the code was not yet released (in Lucene), the Lucene version should not use NumberUtils at all.\n{quote}\n\n+1 on both (if we can add byte/short to trie*); we should do this\nbefore 2.9 since we can still change locallucene's format.  Maybe open\na new issue for that, too?  We're forking off new 2.9 issues left and\nright here!!\n\nbq. I think, I remove the ShiftAttribute in complete, its really useless. Maybe, I add a getShift() method to NumericUtils, that returns the shift value of a Token/String. See java-dev mailing with Yonik.\n\nOK\n\n{quote}\nbq. Did you think about / decide against making a NumericField (that'd set the right tokenStream itself)?\n\nField is final and so I must extend AbstractField. But some methods of Document return Field and not AbstractField.\n{quote}\n\nCan we just un-final Field?\n\n{quote}\nNumericField would only work for indexing, but when retrieving from index (stored fields), it would change to Field.\n\nMaybe we should move this after the index-specific schemas and so on. Or document, that it can be only used for indexing.\n{quote}\n\nTrue, but we already have such \"challenges\" between index vs search\ntime Document; documenting it it seems fine.\n\nbq. By the way: How do you like the factories in NumericRangeQuery and the setValue methods, working like StringBuffer.append() in NumericTokenStream? This makes it really easy to index.\n\nI think this is great!  I like that you return NumericTokenStream :)\n\nbq. The only good thing of NumericField would be the possibility to automatically disable TF and Norms per default when indexing.\n\nConsumability (good defaults)!  (And also not having to know that you\nmust go and get a tokenStream from NumericUtils).\n",
            "date": "2009-06-15T20:37:35.940+0000",
            "id": 19
        },
        {
            "author": "Uwe Schindler",
            "body": "Updated patch:\n- Remove ShiftAttribute\n- Rename TrieUtils and corresponding test to NumericUtils\n- Deprecate NumberTools (and added TODO hint to NumberUtils in spatial)\n- I was so free to also deprecate DateTools. maybe we keep this, but add a hint to better index the date as a unix timestamp. Any ideas?\n\nStill missing:\n- NumericField, I sleep one night more about it\n- [unneeded SortField factory, parsers] -> extra issue, maybe after 3.0",
            "date": "2009-06-15T22:18:29.755+0000",
            "id": 20
        },
        {
            "author": "Yonik Seeley",
            "body": "re: NumericField - it wouldn't have back-compat issues, so it could be added any time - no need to link it to this issue or to rush it.\n",
            "date": "2009-06-16T01:19:30.298+0000",
            "id": 21
        },
        {
            "author": "Uwe Schindler",
            "body": "bq. re: NumericField - it wouldn't have back-compat issues, so it could be added any time - no need to link it to this issue or to rush it. \n\nI think the same, I should first resolve this and open some more issues :-)",
            "date": "2009-06-16T06:07:23.105+0000",
            "id": 22
        },
        {
            "author": "Michael McCandless",
            "body": "Patch looks good Uwe!  The only thing I think is missing is a single\njavadoc that shows the full usage of Numeric*, with code fragments.\nBut, I think that should wait until we resolve the followon issues,\nhere.\n\nbq. I think the same, I should first resolve this and open some more issues\n\nAgreed, though I think some of these (NumericField, NumericSortField)\nare important to do for 2.9.  Maybe others (adding support for the\nmissing numeric types (byte & short)) can wait.\n\nLet's wrap this one up and move onto the next ones ;)\n",
            "date": "2009-06-16T10:44:26.342+0000",
            "id": 23
        },
        {
            "author": "Uwe Schindler",
            "body": "What do you think about deprecating DateTools? I am not really sure. Maybe we should leave it (in contrast to NumberTools), but let the notice there, that it may be better to use NumericRangeQuery with the unix timestamp.\n\nThe Javadocs are almost central, the entry point (linked from everywhere) is NumericRangeQuery. I only wanted to add a short note to package.html in analysis and search.",
            "date": "2009-06-16T10:50:15.682+0000",
            "id": 24
        },
        {
            "author": "Michael McCandless",
            "body": "I think deprecating DateTools makes sense, though, we should add simple code fragments showing the migration.\n\nNumericRangeQuery's javadocs are great, but I'd like to crispen it up, by decoupling \"how you use it\" from \"how it's implemented\".  EG lead right off with a \"for the impatient, this is how it's used\", and then a separate section detailing how it works, what precisionStep means  (and tradeoffs of high/low values for it), the reference to the full paper, etc.\n\nBut we can iterate on the javadocs in the separate issue, too.",
            "date": "2009-06-16T11:55:44.981+0000",
            "id": 25
        },
        {
            "author": "Michael McCandless",
            "body": "bq. NumericField would only work for indexing, but when retrieving from index (stored fields), it would change to Field.\n\nActually, this need not be a limitation; FieldsWriter already writes bits recording details for each stored field (binary, tokenized, compressed (deprecated)).  We could easily add \"numeric\"; then FieldsReader would return a NumericField.",
            "date": "2009-06-16T11:59:50.970+0000",
            "id": 26
        },
        {
            "author": "Uwe Schindler",
            "body": "bq. Actually, this need not be a limitation; FieldsWriter already writes bits recording details for each stored field (binary, tokenized, compressed (deprecated)). We could easily add \"numeric\"; then FieldsReader would return a NumericField\n\nWith all problems in FieldsReader like need to have a LazyNumericField and so on... :( I cam around this two month ago when fixing this omitTf things there... But it may be an idea.\n\nI will do some changes to the current patch and fix javadocs and add these package.html parts. The SortField and FieldCache parts are done directly after this issue.\n\nI only wanted to hear one more voice about DateTools, because for index size and so on, it may still be good to only index dates in date-granularity. With this, you can use a simple TermQuery to retrieve all docs for that day, with NumericRangeQuery you must create a NumericRangeQuery.newLongRange() on the unix ts from 0:00 on the day to 0:00 on the following day exclusive.",
            "date": "2009-06-16T12:17:08.977+0000",
            "id": 27
        },
        {
            "author": "Michael McCandless",
            "body": "bq. I only wanted to hear one more voice about DateTools, because for index size and so on, it may still be good to only index dates in date-granularity. With this, you can use a simple TermQuery to retrieve all docs for that day, with NumericRangeQuery you must create a NumericRangeQuery.newLongRange() on the unix ts from 0:00 on the day to 0:00 on the following day exclusive.\n\nCouldn't we have a NumericTermQuery for such cases?  You have the full precision term in the index...",
            "date": "2009-06-16T14:15:34.865+0000",
            "id": 28
        },
        {
            "author": "Uwe Schindler",
            "body": "With a NumericTermQuery you would only hit the document exactly on the same millisecond.\n\nThe good thing behind DateTools is, that you can index the date value as a term with some fixed precision, like months. Because of this, you can simply find specific month using one TermQuery. For Ranges, NumericRangeQuery is in most cases better (not with month resolution).\n\nWith NumericRangeQuery it is hard to hit exactly one month using only one term, because the month boundaries in epoch milliseconds is not exactly a 2^n value. In my opinion:\n\n- DateTools is good to index very coarse dates, months, years out of a java.util.Date/Calendar. E.g. days where a room (document) is free in hotel. Users then can use term queries and ask is there any free room on a specific date, for a date range, it is not bad to use a conventional RangeQuery (only few terms affected).\n- Use NumericRangeQuery if you want to query any date range (even downto the millisecond). The important thing is: the lower precision terms are not at common date boundaries.\n\nBecause of this different use cases, in my opinion, DateTools has its usage.",
            "date": "2009-06-16T14:30:10.144+0000",
            "id": 29
        },
        {
            "author": "Yonik Seeley",
            "body": "bq.  We could easily add \"numeric\"; then FieldsReader would return a NumericField.\n\nThis is that baking in a specific implementation into the index format that I don't like.\nThere will be changes to Trie*, there will be other implementations of numerics by both us and other users.  We don't need to strongly couple core indexing and the types of fields... they aren't coupled now except when the generic format of the index changes (like omitNorms, omitTf, indexed, etc).",
            "date": "2009-06-16T14:49:21.122+0000",
            "id": 30
        },
        {
            "author": "Michael McCandless",
            "body": "bq. With a NumericTermQuery you would only hit the document exactly on the same millisecond.\n\nCouldn't I quantize my times (say, by day), then index using\nNumericField, then use NumericRangeQuery for certain cases and\nNumericTermQuery if I want to precisely match one day?\n\nOr for non-Date fields it might be apply too... maybe I'm searching\nfor a hard drive, so I drill down by range (size >= 1.0 TB) and then\nwhen there's only a few sizes in the set we offer up the exact choices\n(1.0, 1.5, 2.0 TB) and when user clicks on one of those we use a\nNumericTermQuery.\n\nbq. Because of this different use cases, in my opinion, DateTools has its usage.\n\nOK I agree, we should leave DateTools un-deprecated.  If/when we offer\neasier integration for Dates w/ Numeric*, we can reconsider\ndeprecation at that point.\n",
            "date": "2009-06-16T15:23:36.381+0000",
            "id": 31
        },
        {
            "author": "Michael McCandless",
            "body": "{quote}\nbq. We could easily add \"numeric\"; then FieldsReader would return a NumericField.\n\nThis is that baking in a specific implementation into the index format that I don't like.\n{quote}\n\nBut we are already \"baking in\" the trie indexing format?  That's what\n\"moving trie to core\" implies.  Lucene can now index numbers, well,\nand has committed to a certain approach (trie).\n\nThe term dict of a numeric field is trie encoded, each doc field is\nindexed under a series of trie encoded tokens (w/ different\nprecisions), etc.\n\nSure, in the future we may find improvements to how Lucene indexes\nnumbers, by why choose to be buggy today (\"hey how come I didn't get a\nNumericField back on my doc?\") for this possible future that may or\nmay not come?  If/when that future arrives, we can improve the index\nformat at that point rather than intentionally create buggy code\ntoday?\n\nI do agree that retrieving a doc is already \"buggy\", in that various\nthings are lost from your index time doc (a well known issue at this\npoint!), but I don't think we should intentionally make that behavior\neven more buggy, if we can help it...\n",
            "date": "2009-06-16T15:38:13.676+0000",
            "id": 32
        },
        {
            "author": "Yonik Seeley",
            "body": "bq. But we are already \"baking in\" the trie indexing format? That's what \"moving trie to core\" implies. \n\nNah - no more than the porter stemmer or any other type of analysis is \"baked in\".\nI thought \"move\" meant \"rename\" (package and class name).  Upgrading it's stability and how \"core\" it was.\n\nbq. \"hey how come I didn't get a NumericField back on my doc?\n\nPerhaps a good reason to not add a NumericField.  It doesn't currently exist and is not necessary for Trie.\nWant a convenience method for the user?  TrieUtils.createDocumentField(...) , same as the sortField currently works.\n\nThe current Trie behavior works the same way everything else does in Lucene... changing that and encoding types into the index deserves it's own issue and discussion (and something big like that doesn't seem to belong in 2.9 which is winding down).\n",
            "date": "2009-06-16T16:29:49.344+0000",
            "id": 33
        },
        {
            "author": "Earwin Burrfoot",
            "body": "bq. This is that baking in a specific implementation into the index format that I don't like.\n+many\n\nbq. I do agree that retrieving a doc is already \"buggy\", in that various things are lost from your index time doc (a well known issue at this point!)\nHow on earth is it buggy? You're working with an inverted index, you aren't supposed to get original document from it in the first place. It's like saying a hash function is buggy because it is not reversible.\n\nThe less coupling various lucene components have on each other - the better. If you'd like to have end-to-end experience for numeric fields, build something schema-like and put it in contribs. If it's hard to build - Lucene core is to blame, it's not extensible enough. From my experience, for that purporse it's okay as it is.",
            "date": "2009-06-16T16:40:42.228+0000",
            "id": 34
        },
        {
            "author": "Michael McCandless",
            "body": "Note that LUCENE-1505 is open for cutting over contrib/spacial to NumericUtils....",
            "date": "2009-06-17T09:06:33.271+0000",
            "id": 35
        },
        {
            "author": "Michael McCandless",
            "body": "bq. Want a convenience method for the user? TrieUtils.createDocumentField(...) , same as the sortField currently works.\n\nI don't think this is \"convenient\" enough.\n\nbq.  If you'd like to have end-to-end experience for numeric fields, build something schema-like and put it in contribs\n\n+1\n\nLong (medium?) term I'd love to get to this point; I think it'd make\nLucene quite a bit more consumable.  But we shouldn't sacrifice\nconsumability today on the hope for that future nirvana.\n\nYou already have a nice starting point here... is that something you\ncould donate?\n\n{quote}\nbq. I do agree that retrieving a doc is already \"buggy\", in that various things are lost from your index time doc (a well known issue at this point!)\n\nHow on earth is it buggy?  You're working with an inverted index, you aren't supposed to get original document from it in the first place. It's like saying a hash function is buggy because it is not reversible.\n{quote}\n\nI completely agree: you're not supposed to get the original doc back.\nAnd the fact that Lucene's API now \"pretends\" you do, is wrong.  We all\nagree to that, and that we need to fix Lucene.\n\nBut, as things now stand, it's not yet fixed, so until it's fixed, I\ndon't like intentionally making it worse.\n\nIt'd be great to simply stop returning Document from IndexReader.\nWanna make a patch?  I don't think the new sheriff'd hold 2.9 for this\nthough ;)\n\n{quote}\nbq. \"hey how come I didn't get a NumericField back on my doc?\n\nPerhaps a good reason to not add a NumericField.\n{quote}\n\nI think NumericField (when building your doc) is still valuable, even\nif we can't return NumericField when you retrieve the doc.\n\nOK... since adding the bit to the stored fields is controversial, I\nthink for 2.9, we should only add NumericField at indexing (document\ncreation) time.  So, we don't store a new bit in stored fields file\nand the index format is unchanged.\n",
            "date": "2009-06-17T09:51:17.653+0000",
            "id": 36
        },
        {
            "author": "Uwe Schindler",
            "body": "Here some intermediate update...",
            "date": "2009-06-17T14:16:32.888+0000",
            "id": 37
        },
        {
            "author": "Uwe Schindler",
            "body": "Final patch version with updated javadocs. I will commit in a day or two :-)\nWhen committing, I will also remove TrieRange from contrib/search (not included in patch).\n\nIf you want to make javadocs updates, feel free to post an updated patch or do it after I committed.\n\nAfter that I will do some work for NumericField and NumericSortField as well as moving the parsers to FieldCache and make the plain-text-number parsers public there, too.",
            "date": "2009-06-18T09:44:22.914+0000",
            "id": 38
        },
        {
            "author": "Michael McCandless",
            "body": "Latest patch looks good Uwe!  We can separately tweak the javadocs...",
            "date": "2009-06-18T16:13:59.449+0000",
            "id": 39
        },
        {
            "author": "Uwe Schindler",
            "body": "- Committed addition to core in revision 786470\n- Committed remove from contrib in revision 786474\n\nThanks for all your help! I will now open another issue for the remaining (optional) tasks",
            "date": "2009-06-19T12:17:38.886+0000",
            "id": 40
        }
    ],
    "component": "core/search",
    "description": "TrieRange was iterated many times and seems stable now (LUCENE-1470, LUCENE-1582, LUCENE-1602). There is lots of user interest, Solr added it to its default FieldTypes (SOLR-940) and if possible I want to move it to core before release of 2.9.\nBefore this can be done, there are some things to think about:\n# There are now classes called LongTrieRangeQuery, IntTrieRangeQuery, how should they be called in core? I would suggest to leave it as it is. On the other hand, if this keeps our only numeric query implementation, we could call it LongRangeQuery, IntRangeQuery or NumericRangeQuery (see below, here are problems). Same for the TokenStreams and Filters.\n# Maybe the pairs of classes for indexing and searching should be moved into one class: NumericTokenStream, NumericRangeQuery, NumericRangeFilter. The problem here: ctors must be able to pass int, long, double, float as range parameters. For the end user, mixing these 4 types in one class is hard to handle. If somebody forgets to add a L to a long, it suddenly instantiates a int version of range query, hitting no results and so on. Same with other types. Maybe accept java.lang.Number as parameter (because nullable for half-open bounds) and one enum for the type.\n# TrieUtils move into o.a.l.util? or document or?\n# Move TokenStreams into o.a.l.analysis, ShiftAttribute into o.a.l.analysis.tokenattributes? Somewhere else?\n# If we rename the classes, should Solr stay with Trie (because there are different impls)?\n# Maybe add a subclass of AbstractField, that automatically creates these TokenStreams and omits norms/tf per default for easier addition to Document instances?",
    "hasPatch": true,
    "hasScreenshot": false,
    "id": "LUCENE-1673",
    "issuetypeClassified": "RFE",
    "issuetypeTracker": "RFE",
    "priority": "Major",
    "product": "LUCENE",
    "project": "LUCENE",
    "summary": "Move TrieRange to core",
    "systemSpecification": true,
    "version": "2.9"
}