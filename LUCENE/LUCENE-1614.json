{
    "comments": [
        {
            "author": "Michael McCandless",
            "body": "Shai did you forget to attach patch here?  Or maybe you're just busy ;)",
            "date": "2009-04-27T17:34:05.366+0000",
            "id": 0
        },
        {
            "author": "Shai Erera",
            "body": "No I did not forget - I need to work on it (trying to juggle all the issues I opened :)) ... in general I don't like to work on overlapping issues and this overlaps with 1593 (it will touch some of the same files). But I can start working on the patch - it looks much simpler than 1593 ...\n\nOne thing I wanted to get feedback on is the proposal to use advance() and advance(target). Let's decide on that now, so that I don't need to \"refactor\" everything afterwards :)",
            "date": "2009-04-27T17:40:36.838+0000",
            "id": 1
        },
        {
            "author": "Marvin Humphrey",
            "body": "> advance() and advance(int)\n\nIn the interest of coherent email exchanges, I think it would be best to give\nthese methods distinct names, e.g. \"nudge\" and \"advance\".\n",
            "date": "2009-04-27T18:07:24.323+0000",
            "id": 2
        },
        {
            "author": "Shai Erera",
            "body": "nudge doesn't sound like it changes anything, but just \"touches\". So if distinct method names is what we're after, I prefer nextDoc() and skipToDoc() or advance() for the latter.",
            "date": "2009-04-27T18:53:02.706+0000",
            "id": 3
        },
        {
            "author": "Marvin Humphrey",
            "body": "> nudge doesn't sound like it changes anything, but just \"touches\".\n\nIf you say so.  In Lucy, I expect we'll use \"next\" and \"advance\".  \n\n> if distinct method names is what we're after\n\nYes, that's the idea.  These two methods are very different from each other.\nThe official definition of skipTo() has many subtle gotchas.  Just because\nthey both move the iterator forward doesn't mean they do the same thing, and\nit is cumbersome and taxing to have to differentiate between methods using\nlong-form signatures in the midst of standard prose.\n\nThere's no good reason to conflate these two methods, just as there's no \ngood reason why we should be forced to write \"search(Collector)\" instead\nof \"collect()\" or \"collectHits()\".\n\n> I prefer nextDoc() and skipToDoc() or advance() for the latter. \n\nIMO, \"advance\" more accurately describes what that method does than either\n\"skipTo\" or \"skipToDoc\".  The problem is that if you're on doc 10, then\nskipToDoc(10) doesn't, in fact, skip to doc 10 as the method name implies --\nit takes you to at least doc 11.  Furthermore, \"advance\" reinforces that you\ncan only seek forwards.\n",
            "date": "2009-04-28T14:42:33.505+0000",
            "id": 4
        },
        {
            "author": "Marvin Humphrey",
            "body": "Further illustration...\n\nGood method signature overloading, from IndexReader.java:\n\n{noformat}\n  public static boolean indexExists(String directory)\n\n  public static boolean indexExists(File directory)\n\n  public static boolean indexExists(Directory directory);\n{noformat}\n\nBad method signature overloading, from Searcher.java:\n\n{noformat}\n  public Hits search(Query query, Filter filter, Sort sort)\n\n  public TopFieldDocs search(Query query, Filter filter, int n, Sort sort)\n\n  public void search(Query query, HitCollector results)\n{noformat}\n\nIMO, those three methods on Searcher should be named hits(), topFieldDocs(),\nand collect(), rather than search(), search(), and search(), making code that\nuses those methods more self documenting, and making it easier to discuss them\nout of context.\n\nFor the same reasons, we should have different names for nextDoc() and\nadvance().\n",
            "date": "2009-04-28T15:29:54.830+0000",
            "id": 5
        },
        {
            "author": "Michael McCandless",
            "body": "Maybe nextDoc and advanceToDoc?\n\nRe: skipTo doing alot.... one thing that's missing from\nDISI is method \"advance to doc X then return a boolean\ntelling me if you accept that doc, but do not do a next()\".  In\nLUCENE-1536 in some cases we gain sizable performance by using such an\nAPI with a relatively sparse filter against a relatively expensive\n(BooleanScorer2) scorer.  Though \"filter as BooleanClause\" may undo\nthese performance gains.\n\n",
            "date": "2009-04-29T17:44:13.347+0000",
            "id": 6
        },
        {
            "author": "Shai Erera",
            "body": "Whoa ! so many emails on this list that I completely missed the last two posts by Marvin (sorry about that Marvin).\n\nbq. Maybe nextDoc and advanceToDoc? (or Matvin's nextDoc() and advance())\n\nI'm fine with nextDoc(). About advance, I think I prefer advance(int target) for the sake of not repeating the same information twice (i.e., advance*ToDoc*(int *target*)). So if I see a line like this: *disi.advance(15)* I think it's understood exactly as *disi.advanceToDoc(15)*, only the latter is longer.\n\nbq. advance to doc X then return a boolean telling me if you accept that doc, but do not do a next()\n\nWhat do you mean \"do not do a next()\"? Let's say I have a DISI that can return docs 1, 3, 7, 10 but it doesn't know so in advance. When you call skipTo(8), it must reach 7, then figure it's less than 8 and do a next() to land on 10. Do you mean that it should return false in that case, and not move from 7 to 10? Since it already moved, and let's assume it cannot go back (at least efficiently), that means it should remember the last skipTo called was 8 and it is on 10, so if it is requested to skip to 9, it should return false again ... is that what you meant?",
            "date": "2009-04-29T18:15:39.893+0000",
            "id": 7
        },
        {
            "author": "Michael McCandless",
            "body": "bq. I think I prefer advance(int target)\n\nOK +1.  Nice and succinct.\n\n{quote}\nWhat do you mean \"do not do a next()\"? Let's say I have a DISI that can return docs 1, 3, 7, 10 but it doesn't know so in advance. When you call skipTo(8), it must reach 7, then figure it's less than 8 and do a next() to land on 10. Do you mean that it should return false in that case, and not move from 7 to 10? Since it already moved, and let's assume it cannot go back (at least efficiently), that means it should remember the last skipTo called was 8 and it is on 10, so if it is requested to skip to 9, it should return false again ... is that what you meant?\n{quote}\n\nI mean the scorer should go straight to the doc I asked for and test whether it accepts that doc and do nothing else.  Call this api \"boolean check(int doc)\" for now.\n\nIt'd be useful for more interesting scorers.  EG ConjunctionScorer.check would simply call check on each sub-scorer, stopping early if any return false; this is less work than what it does today.\n\nYou're right, for the TermScorer case nothing is saved since it uses next internally to determine if a doc matches.",
            "date": "2009-04-29T20:04:58.954+0000",
            "id": 8
        },
        {
            "author": "Shai Erera",
            "body": "bq. I mean the scorer should go straight to the doc I asked for and test whether it accepts that doc and do nothing else.\n\nJust to clarify for myself, in the example I gave above, suppose thar the scorer is on \"3\" and you call check(8). Do you expect it to go to 10, realize that 8 is not supported and go back to 3? Can it be called with check(7) afterwards? If not, then why not use advance(8), get back 10 and realize 8 is not supported? You should be able to call advance(9) without it advancing beyond 10 (which it's currently on).\n\nYour comment on TermScorer just reinforces my confusion - what is this API good for, and what's missing in advance(target) today? Can't ConjunctionScorer call advance until it gets a response which is not what was asked for?",
            "date": "2009-04-30T03:35:21.088+0000",
            "id": 9
        },
        {
            "author": "Shai Erera",
            "body": "I think I understand what you mean, but please correct me if I'm wrong. You propose this check() so that in case a DISI can save any extra operations it does in next() (such as reading a payload for example) it will do so. Therefore in the example you give above with CS, next()'s contract forces it to advance all the sub-scorers, but with check() it could stop in the middle.\n\nThis warrants an explicit documentation and implementation by current DISIs ... I don't think that if you call a DISI today with next(10) and next(10) it will not move to 11 in the second call. But calling check(10) and next(10) MUST not advance the DISI further than 10. If the default impl in DISI just uses nextDoc() and returns true if the return value is the requested, we should be safe back-compat-wise, but this is still dangerous and we need clear documentation.\n\nBTW, perhaps a testAndSet-like version can save check(10) followed by a next(10), and will fit nicer?",
            "date": "2009-04-30T08:03:38.753+0000",
            "id": 10
        },
        {
            "author": "Michael McCandless",
            "body": "bq. Just to clarify for myself, in the example I gave above, suppose thar the scorer is on \"3\" and you call check(8).\n\nOn check(8), TermScorer would go to 10, stop there, and return false.  (It would not \"rewind\" to 3).  Check can only be called on increasing arguments, so it's not truly \"random access\".  It's \"forward only random access\".\n\nbq. You propose this check() so that in case a DISI can save any extra operations it does in next() (such as reading a payload for example) it will do so. Therefore in the example you give above with CS, next()'s contract forces it to advance all the sub-scorers, but with check() it could stop in the middle.\n\nPrecisely.\n\nThis is important when you have a super-cheap iterator (say a somewhat sparse (<=10%?) in-memory filter that's represented as list-of-docIDs).  It's very fast for such a filter to iterate over its docIDs.  But when that iterator is AND'd with a Scorer, as is done today by IndexSearcher, they effectively play \"leap frog\", where first it's the filter's turn to next(), then it's the Scorer's turn, etc.  But for the Scorer, next() can be extremely costly, only to find the filter doesn't accept it.  So for such situations it's better to let the filter drive the search, calling Scorer.check() on the docs.\n\nBut... once we switch to filter-as-BooleanClause, it's less clear whether check() is worthwhile, because I think the filter's constraint is more efficiently taken into account.\n\nFor filters that support random access (if they are less sparse, say >= 25% or so), we should push them all the way down to the TermScorers and factor them in just like deletedDocs.\n\nbq. . If the default impl in DISI just uses nextDoc() and returns true if the return value is the requested, we should be safe back-compat-wise, but this is still dangerous and we need clear documentation.\n\nYes it does have a good default impl, I think.\n\nbq. BTW, perhaps a testAndSet-like version can save check(10) followed by a next(10), and will fit nicer?\n\nNot sure what you mean by \"testAndSet-like version\"?",
            "date": "2009-04-30T10:03:03.080+0000",
            "id": 11
        },
        {
            "author": "Shai Erera",
            "body": "bq. Not sure what you mean by \"testAndSet-like version\"?\n\nI mean, instead of having the code call check(8), get true and then advance(8), just call checkAndAdvance(8) which returns true if 8 is supported and false otherwise, AND moves to 8. I don't propose to replace check() with it as sometimes you might want to check a couple of DISIs before making a decision to which doc to advance, but it could save calling advance() in case check() returns true.\n\nbq. Yes it does have a good default impl, I think.\n\nIt _will_ have a good default impl, I can guarantee to try :). What I meant is that we should have clear documentation about check() and nextDoc() and the possibility that check will be called for doc Id 'X' and later nextDoc or advance will be called with 'X', in that case the impl must ensure 'X' is not skipped, as is done today by TermScorer for example.\n\nSo should I add this check()?",
            "date": "2009-04-30T10:39:31.202+0000",
            "id": 12
        },
        {
            "author": "Michael McCandless",
            "body": "bq. I mean, instead of having the code call check(8), get true and then advance(8), just call checkAndAdvance(8) which returns true if 8 is supported and false otherwise, AND moves to 8.\n\nOh, sorry: that's in fact what I intended check to do.  But by \"moves to 8\" what it really means is \"you now cannot call check on anything < 8 (maybe 9)\"\n\nI think after check(N) is called, one cannot call doc() -- the results are not defined.  So check(N) logically puts the iterator at N, and you may at that point call next if you want, or call another check(M) but you cannot call doc() right after check.\n\nbq. So should I add this check()?\n\nI think so?  We can then do perf tests of that vs filter-as-BooleanClause?",
            "date": "2009-04-30T13:30:04.575+0000",
            "id": 13
        },
        {
            "author": "Michael McCandless",
            "body": "bq. So should I add this check()?\n\nThough, in order to run perf tests, we'd need the AND/OR scorers to efficiently implement check().",
            "date": "2009-04-30T13:30:41.766+0000",
            "id": 14
        },
        {
            "author": "Shai Erera",
            "body": "bq. I think after check(N) is called, one cannot call doc()\n\nI think one cannot even call next(). If check(8) returns true, then you know that doc() will return 8 (otherwise it's a bug?). But if it returns false, it might be in 10 already, so calling next() will move it to 11 or something. So to be on the safe side, we should document that doc()'s result is unspecified if check() returns false, and next() is not recommended in that case, but skipTo() or check(M).\n\nbq. Though, in order to run perf tests, we'd need the AND/OR scorers to efficiently implement check().\n\nI plan to, as much as I can, efficiently implement nextDoc() and advance() in all Scorers/DISIs. So I can include check() in the list as well. Or .. maybe you know something I don't and you think this should deserve its own issue?",
            "date": "2009-04-30T13:38:37.528+0000",
            "id": 15
        },
        {
            "author": "Michael McCandless",
            "body": "bq. I think one cannot even call next().\n\nHmm, yeah I think you're right.  We could perhaps make this an entirely different interface (abstract class).  Ie, one should not mix and match \"checking\" with \"next/advance\"ing.  In the case I can think of, at least, it's an up-front decision as to which scorer does next vs check.\n\nbq.  So I can include check() in the list as well.\n\nI think including it in this issue is fine.",
            "date": "2009-04-30T15:24:35.311+0000",
            "id": 16
        },
        {
            "author": "Shai Erera",
            "body": "Ok I'll start with just adding nextDoc and advance, deprecate the old ones, implement in all extending classes and modify current code which uses DISI. Then, we can see how to proceed with check() and whether it should be part of this issue or another one.\n\nI have a feeling my last couple of issues just grew larger the more we discussed them, so I hope to keep this one containable :)",
            "date": "2009-04-30T19:48:29.977+0000",
            "id": 17
        },
        {
            "author": "Michael McCandless",
            "body": "bq. Then, we can see how to proceed with check() and whether it should be part of this issue or another one.\n\nFair enough!\n\nbq. I have a feeling my last couple of issues just grew larger the more we discussed them, so I hope to keep this one containable \n\nAlas this is what happens when you tackle tricky issues... sort of like pulling out that innocent looking thread sticking out on the bottom of your shirt ;)",
            "date": "2009-05-01T14:33:50.573+0000",
            "id": 18
        },
        {
            "author": "Shai Erera",
            "body": "I started to work on that issue and noticed the javadoc of skipTo: \"Skips entries to the first *beyond* the current whose document number is greater than or equal to target\". That together with the code example implies that if a set has docs 9, 10, 11 and I call skipTo(10) and then doc() I'll get 10 the first time and 11 the second time (meaning two consecutive calls to skipTo with the same target return different results).\n\nI was wondering if we want to change it, i.e., have advance do something like that:\n{code}\nwhile (doc() < target) {\n  if (!next()) return -1;\n}\nreturn doc();\n{code}\n\nI think this behavior is more accurate, at least in terms of semantics.",
            "date": "2009-05-18T13:36:34.837+0000",
            "id": 19
        },
        {
            "author": "Michael McCandless",
            "body": "I would tentatively prefer that change in semantics.",
            "date": "2009-05-18T15:18:53.791+0000",
            "id": 20
        },
        {
            "author": "Yonik Seeley",
            "body": "An implementation certainly shouldn't be required to carry state such that skipTo(10) called twice will yield different results.\nA bigger question though, is if we should support skipTo(doc) where doc<=current at all. That's sort of how I read \"Skips entries to the first beyond the current\"... that you shouldn't be calling skipTo(doc) unless doc>current.\n\nIf we do want to define skipTo(doc) whendoc<=current, then I agree it should be as you describe.\n\n(edited to avoid JIRA markup (n) )",
            "date": "2009-05-18T15:38:26.334+0000",
            "id": 21
        },
        {
            "author": "Marvin Humphrey",
            "body": "> if a set has docs 9, 10, 11 and I call skipTo(10) and then doc() I'll get 10 \n> the first time and 11 the second time \n\n> I was wondering if we want to change it,\n\nI agree that your proposed definition is more intuitive.  I think it \nmight make TermScorer.advance() a tad less efficient, though,\nbecause it would be necessary to check the current doc first.\n\n{code}\n  public boolean skipTo(int target) throws IOException {\n    // first scan in cache\n    for (pointer++; pointer < pointerMax; pointer++) {\n       if (docs[pointer] >= target) {\n         doc = docs[pointer];\n         return true;\n       }\n    }\n{code}\n\nThere might be others, as well. I'd be concerned if something\nlow-level like TermDocs or TermPositions was affected \nnegatively.  It seems likely, because we'd be changing from\n\"advance, then check state\" to \"check state, then advance, \nthen check state\". \n\nFunny, but this is actually closer to \"skip to\" than \"advance\", since\nunder this proposal, the iterator would not always advance.  ",
            "date": "2009-05-18T15:38:57.057+0000",
            "id": 22
        },
        {
            "author": "Shai Erera",
            "body": "bq. A bigger question though, is if we should support skipTo(doc) where doc<=current at all\n\nI don't think we should support it and it wasn't the intention in the first place. If we do want to support it than a different name for the method is required, such as seek(target) or moveTo(target).\n\nbq. Funny, but this is actually closer to \"skip to\" than \"advance\", since under this proposal, the iterator would not always advance.\n\nI actually don't see it like that. skipTo and advance both imply that the iterator moves forward (as opposed to seek). However I don't think that when you say \"advance to X\" it means the iterator should move. The result of that command should put the iterator on X or beyond (if X does not exist). If the iterator is already on X, I don't think it should do anything.\n\nbq. An implementation certainly shouldn't be required to carry state such that skipTo(10) called twice will yield different results.\n\nI'm not sure if by that you agree with me or disagree (maybe I'm misreading it). From the iterators I've modified already, calling skipTo(10) multiple times always yields the same result. Those are the ones that operate on BitSet. They never check their state, but just skip to wherever they're requested.\n\nIn case you disagree, I'd like to ask why is it bad to request the implementation to remember its state? I think that all implementations already store the doc Id in case doc() will be called following skipTo, so in a sense they already remember their state. In addition, checking if the current doc Id is not the target is something I believe most will do - if they don't need to, like the bit-set variants, then they don't do it. If they cannot really skip to a target, but are forced to call next() until target is reached, they already check their state and so it does not add any overhead.\n\nTo me, calling skipTo or advance with the same target multiple times and get different result every time is weird. I'd like to change that semantic, but if you strongly disagree, then we should at least document it.",
            "date": "2009-05-19T07:07:56.861+0000",
            "id": 23
        },
        {
            "author": "Shai Erera",
            "body": "Patch introduces the two added methods, as well as changes to our tests and code to utilize the new versions. All tests pass.\n\nI did not add check() yet, since I'd like to have this patch reviewed first, and then decide whether check() should be handled in that issue or not, and to get a hint of which Scorers / DISIs it should actually affect.",
            "date": "2009-05-19T14:34:16.727+0000",
            "id": 24
        },
        {
            "author": "Shai Erera",
            "body": "BTW, as I prepared that patch, I noticed the same improvement can be applied to TermDocs. However it's an interface and so we're stuck with back-compat, and replacing it with an abstract class means spending too much energy, at least on finding a better name :). What do you think?",
            "date": "2009-05-19T18:31:28.381+0000",
            "id": 25
        },
        {
            "author": "Michael McCandless",
            "body": "I wonder if instead of returning -1 when the iteration is done, we should return Integer.MAX_VALUE?\n\nThis would save CPU for scorers that merge multiple sub-scorers (like BooleanScorer/2), because instead of having to check for -1 returned from each sub-scorer, they could simply proceed with their normal logic and check for Integer.MAX_VALUE just before collecting the doc.  It'd be one fewer if to check, per sub-scorer per nextDoc/advance call, which would be a nice savings.\n\nThis is what I'm doing on LUCENE-1594.",
            "date": "2009-05-19T18:31:49.854+0000",
            "id": 26
        },
        {
            "author": "Yonik Seeley",
            "body": "> > A bigger question though, is if we should support skipTo(doc) where doc<=current at all\n> I don't think we should support it and it wasn't the intention in the first place. \n\nOK... I had read your proposal as saying you wanted skipTo(10) twice in a row to return 10 both times (assuming it matched).\nMarvin seemed to believe the same thing.\n\n>  In case you disagree, I'd like to ask why is it bad to request the implementation to remember its state?\n\nI don't disagree, but requiring some implementations to keep and check state would mean less efficient implementations.\n\n> To me, calling skipTo or advance with the same target multiple times and get different result every time is weird. I'd like to change that semantic\n\nBut I thought we had just agreed that skipTo(doc) is well defined only for doc>current? (see \"bigger question\" point above).\nIf we all agree that , then we don't need to worry about skipTo(10) being called twice in a row.\n",
            "date": "2009-05-19T19:26:45.103+0000",
            "id": 27
        },
        {
            "author": "Shai Erera",
            "body": "bq. I wonder if instead of returning -1 when the iteration is done, we should return Integer.MAX_VALUE?\n\nThe idea was to return a negative value and then compare the returned value to >= 0 for better performance. If we return MAX_VAL we'll need to compare to MAX_VAL, which is less efficient, CPU wise.\n\nbq. But I thought we had just agreed that skipTo(doc) is well defined only for doc>current?\n\nNot sure - didn't we agree for >= current? An example are two iterators, one over 1, 3, 8, 11 and another on 2, 5, 9, 11. Let's say that you ask both for advance(9). The first one lands on 11 and the second on 9. Then you ask both to advance to 11 again - the first one returns \"no more results\" and the second one lands on 11.\n\nI have to be honest though that I'm not sure to which scenario that matches, I just had a feeling that calling advance(X) while the iterator is on X is something we may run in to and therefore we should make sure to return X. BTW, none of the existing iterators in the code needed to perform any extra check to ensure that behavior. Even TermScorer.\n\nbq. I had read your proposal as saying you wanted skipTo(10) twice in a row to return 10 both times (assuming it matched)\n\nThat's exactly what I meant :)",
            "date": "2009-05-19T19:37:19.761+0000",
            "id": 28
        },
        {
            "author": "Yonik Seeley",
            "body": "bq. This would save CPU for scorers that merge multiple sub-scorers (like BooleanScorer/2), because instead of having to check for -1 returned from each sub-scorer, they could simply proceed with their normal logic and check for Integer.MAX_VALUE just before collecting the doc.\n\nBut for scorers that use a priority queue, does checking and immediately removing from the queue (hence making the heap smaller) offer any advantages?  I had assumed so since this is what current scorers do.  Immediately removing scorers also causes early termination for minimumNrMatchers>1 in DisjunctionSumScorer.",
            "date": "2009-05-19T19:39:47.015+0000",
            "id": 29
        },
        {
            "author": "Michael McCandless",
            "body": "bq. BTW, none of the existing iterators in the code needed to perform any extra check to ensure that behavior. Even TermScorer.\n\nActually, TermScorer is now effectively doing an additional check, because you removed the pointer++ from the for loop init.  Ie, you now first check if (docs[pointer] >= target) *before* doing the pointer++.",
            "date": "2009-05-19T19:42:20.776+0000",
            "id": 30
        },
        {
            "author": "Yonik Seeley",
            "body": "bq. Not sure - didn't we agree for >= current?\n\n\"A bigger question though, is if we should support skipTo(doc) where doc<=current at all\"\nimplies well defined behavior only when doc>current, as all of our scorers adhere to.\n\nbq. BTW, none of the existing iterators in the code needed to perform any extra check to ensure that behavior. Even TermScorer.\n\nHmmm... TermScorer.skipTo() does first advance the pointer before checking any state.  If we wanted to support calling skipTo(10) twice in a row, it would require extra code.",
            "date": "2009-05-19T19:48:50.564+0000",
            "id": 31
        },
        {
            "author": "Michael McCandless",
            "body": "{quote}\n> This would save CPU for scorers that merge multiple sub-scorers (like BooleanScorer/2), because instead of having to check for -1 returned from each sub-scorer, they could simply proceed with their normal logic and check for Integer.MAX_VALUE just before collecting the doc.\n\nBut for scorers that use a priority queue, does checking and immediately removing from the queue (hence making the heap smaller) offer any advantages? I had assumed so since this is what current scorers do. Immediately removing scorers also causes early termination for minimumNrMatchers>1 in DisjunctionSumScorer.\n{quote}\n\nBut that only helps at the tail end of the iteration, vs saving an if\ncheck per-sub-scorer X per-next?\n\nIe presumably much more CPU is spent iterating while the PQ is full,\nthan while it's winding down, so saving the if per-sub-scorer-next is\nbetter?\n\nAlso, I think over time we should migrate away from the PQ (ie, use\nBooleanScorer's batch approach, not Disjunction*Scorer's PQ) since the\nbatch scoring approach gives better performance.  EG I think we should\nextend BooleanScorer to handle MUST clauses.  BooleanScorer handles\ndoc=Integer.MAX_VALUE for a sub-scorer quite efficiently (the chunk is\nalways skipped for that sub-scorer, after one if check).\n",
            "date": "2009-05-19T19:57:31.683+0000",
            "id": 32
        },
        {
            "author": "Michael McCandless",
            "body": "{quote}\n> I wonder if instead of returning -1 when the iteration is done, we should return Integer.MAX_VALUE?\n\nThe idea was to return a negative value and then compare the returned value to >= 0 for better performance. If we return MAX_VAL we'll need to compare to MAX_VAL, which is less efficient, CPU wise.\n{quote}\n\nIf you always check the returned result, right.\n\nBut with BooleanScorer/2, and likely any scorer that invokes multiple\nsub-scorers, switching to Integer.MAX_INT as the sentinel would allow\nus to *not* test every sub-scorer's returned result from\nnextDoc/advance.  Ie, because the docID moved forward (vs -1, which\nmoved backwards), it's a \"natural\" fit for the main scorer's normal docID\nprocessing.  So, far fewer if's (one per subscorer) are in the\ninnermost loop.\n\nMarvin, what's your plan for Lucy's sentinel value for DISI/Scorer?\n",
            "date": "2009-05-19T20:05:42.324+0000",
            "id": 33
        },
        {
            "author": "Shai Erera",
            "body": "Ok I'll look into it tomorrow morning when I'll be near the code again. If it makes sense, then it makes sense :)\n\nYou're also right about TermScorer. I missed the fact that checking the pointer occurs for the _next_ pointer, and indeed now the code does one extra check than before.\n\nIf you don't feel advance() should have this contract, then I can change TermScorer's implementation back and document that calling advance() with the same value several times in a row does not guarantee to return the same value every time ... \n\nI still think it's more logical to state that it should return the same value, however since I don't have a good scenario where that will happen (and perhaps the fact that nobody complained about it until now means it never happens?) and since it may pose a performance hit over some iterators, I'm willing to let go :)",
            "date": "2009-05-19T20:18:11.021+0000",
            "id": 34
        },
        {
            "author": "Michael McCandless",
            "body": "bq. I still think it's more logical to state that it should return the same value\n\nI agree (hence my original tentative liking of this change), but I agree that this can only hurt performance.\n\nIe the caller *knows* on calling advance() that the state of the sub-scorer must change.  And so by altering advance to first check, that check is redundant.  So maybe we should switch it back to \"advance then check\"?",
            "date": "2009-05-19T20:27:36.003+0000",
            "id": 35
        },
        {
            "author": "Yonik Seeley",
            "body": "Scorers previously only had to worry about skipTo(doc) being called for doc>current.  I don't currently see a use case for changing that.",
            "date": "2009-05-19T20:33:23.805+0000",
            "id": 36
        },
        {
            "author": "Paul Elschot",
            "body": "About using Integer.MAX_VALUE as sentinel, did anyone consider what happens when the first index actually reaches that number of documents?\n\nOn moving from the priority queue (DisjunctionSumScorer/BooleanScorer2) to the batch approach (BooleanScorer): I did not find a way to do that while scoring docs in docId order. Basically it's a priority queue versus a distribution \"sort\" on the low docId bits into a linked list.\nThe priority queue can be made faster by inlining (there is a patch for that, I can't get to the issue number now), but that's about the limit as far as I can see.",
            "date": "2009-05-19T20:33:58.246+0000",
            "id": 37
        },
        {
            "author": "Michael McCandless",
            "body": "bq. About using Integer.MAX_VALUE as sentinel, did anyone consider what happens when the first index actually reaches that number of documents?\n\nLucene already uses Integer.MAX_VALUE as a sentinel (eg the score(Collector) methods in Term/BooleanScorer/2), so a Lucene index can already only contain Integer.MAX_VALUE docs.\n\nbq. On moving from the priority queue (DisjunctionSumScorer/BooleanScorer2) to the batch approach (BooleanScorer): I did not find a way to do that while scoring docs in docId order. \n\nWhat breaks if we allow docs to be collected out-of-order (besides external Hit/Collector)?  As of LUCENE-1575, the core collectors can gain performance if they know the docs will be collected in order, but they can also handle out-or-order collection just fine.\n\nbq. The priority queue can be made faster by inlining (there is a patch for that, I can't get to the issue number now), but that's about the limit as far as I can see.\n\nI think PQ is fundamentally not very friendly to modern CPUs, because of the hard-to-predict ifs; I think that's part of why the batch collection shows such gains.\n\nThis doesn't hurt us so much during hit collection, which also uses PQ, since the queue typically quickly converges, but for OR scoring the PQ is intensely used the whole time.\n",
            "date": "2009-05-19T20:51:10.720+0000",
            "id": 38
        },
        {
            "author": "Marvin Humphrey",
            "body": "> Marvin, what's your plan for Lucy's sentinel value for DISI/Scorer?\n\nDoc numbers start at 1, and 0 is the sentinel.\n\nAlso, DISI will be named \"Matcher\".  Features above and beyond what's \ncurrently in Lucene DISI to be determined.",
            "date": "2009-05-19T21:24:51.558+0000",
            "id": 39
        },
        {
            "author": "Shai Erera",
            "body": "So Mike - I've checked BS and BS2, and I don't see where does the return value can come into play the way you describe. Perhaps I'm missing it, but here's what I found:\n\n* BS - advance is not supported. In nextDoc the return value is checked only to verify if the sub scorer is done or not, therefore comparing to >= 0 seems the better option here.\n\n* BS2 - delegates advance and nextDoc to its counting scorer, which could have two variants that may be affected:\n** DisjunctionSumScorer - I don't see where the return value of the scorers is even considered.\n** ConjunctionScorer - both nextDoc and advance delegate the call to doNext() which iterates over the scorers. But it only checks the return value of advance to decide whether to continue with the iteration or not. The only thing I changed is using advance() >= 0 instead of skipTo which returned boolean. Is that the one you're talking about? Maybe you mean that in that scorer (only?) I could drop the 'more' member and stop iterating when the first scorer hits MAX_VAL, in which case it will not be less than the last doc, even if the last one is on MAX_VAL also?\n\nIf I didn't miss anything, than that is just one scorer, which is not always instantiated. The rest do compare the return value of nextDoc and advance to determine what to do, exactly as they did before when the equivalent deprecated methods returned a boolean. It seems like this change will hurt the performance of most Scorers/DISIs more than improve the performance of BS2 in some cases where it instantiates a ConjunctionScorer. But like I said, maybe I'm missing a Scorer, so I'd appreciate if you can refer me to the one you had in mind.\n\nAlso, given Marvin's response above, using 0 as sentinel is no different than using -1 in terms of \"suddenly moving backwards\".\n\nI fixed the documentation of advance and reinstated the implementation of TermScorer, so I'm ready to post an updated patch. I'd like us to resolve the return value issue before I do that though.",
            "date": "2009-05-20T06:19:03.876+0000",
            "id": 40
        },
        {
            "author": "Michael McCandless",
            "body": "I'm not referring to BS/2's exposure of advance/nextDoc to their\ncallers; I'm talking about how BS/2 invoke advance/nextDoc on their\nsub-scorers.\n\nSo, in BooleanScorer, starting on line 239 (w/ your patch), is this:\n{code}\nint doc = sub.done ? -1 : scorer.doc();\nwhile (!sub.done && doc < end) {\n  sub.collector.collect(doc);\n  doc = scorer.nextDoc();\n  sub.done = doc < 0;\n}\n{code}\nthis is the hotspot for BooleanScorer: it's advancing through a chunk\n(of 2048 docs) at once, for that one sub-scorer.  Note the checks &\nassignments to sub.done that are required....\n\nIf instead we switch to Integer.MAX_VALUE as the sentinel, that loop\nis simplified to this, instead:\n\n{code}\nint doc = scorer.doc();\nwhile (doc < end) {\n  sub.collector.collect(doc);\n  doc = scorer.nextDoc();\n}\n{code}\n\nscorer.done is no longer computed nor checked.  What makes this\npossible is the existing \"doc < end\" check can be \"reused\" since the\nsentinel moves \"forwards\", not backwards.\n\nWith this, we'd also need to change the toplevel collection (starting\non line 150) to stop processing once all sub-scorers have advanced to\nthe sentinel, but this is 1 added if per 2048 docs so the added cost\n(vs savings of not computing/checking scorer.done) is tiny.\n\nIn ConjunctionScorer's doNext method (its hotspot), it currently does this:\n{code}\nwhile (more && (firstScorer=scorers[first]).doc() < (lastDoc=lastScorer.doc())) {\n  more = firstScorer.advance(lastDoc) >= 0;\n  lastScorer = firstScorer;\n  first = (first == (scorers.length-1)) ? 0 : first+1;\n}\nreturn more;\n{code}\n\nwith the sentinel change, it would do this:\n\n{code}\nwhile ((firstScorer=scorers[first]).doc() < (lastDoc=lastScorer.doc())) {\n  firstScorer.advance(lastDoc);\n  lastScorer = firstScorer;\n  first = (first == (scorers.length-1)) ? 0 : first+1;\n}\nreturn lastDoc != DOC_SENTINEL;\n{code}\n\nie, we no longer assign to, nor check, the more boolean.  What makes\nthis possible is we know all sub-scorers will advance to the sentinel,\nso we know that sentinel doc will pass the existing checks in the\nwhile loop.\n\nbq. Also, given Marvin's response above, using 0 as sentinel is no different than using -1 in terms of \"suddenly moving backwards\".\n\nI agree that Marvin's choice of 0 is also \"suddenly moving backwards\",\nbut it still seems to me to be a poor choice since it costs our\nBooleanScorers more CPU in their hotspots.\n",
            "date": "2009-05-20T10:06:29.193+0000",
            "id": 41
        },
        {
            "author": "Shai Erera",
            "body": "Thanks Mike for the clarification. One thing though is the comment I added to BS about not being able to call scorer.doc() since we may hit NPE. I hit it when it used ReqExclScorer. According to the latter, doc will hit NPE if next() or skipTo() returned false (or in our case nextDoc or advance return MAX_VAL).\n\n{code}\n  public int doc() {\n    return reqScorer.doc(); // reqScorer may be null when next() or skipTo() already return false\n  }\n{code}\n\nIf we drop sub.done in BS and more in ConjScorer, calling doc() will hit NPE. I.e. in BS the first line cannot exist, however I'm not sure I can start with nextDoc() before checking the current doc() < end, which may hit NPE. \n\n{code}\nint doc = scorer.doc();\nwhile (doc < end) {\n  sub.collector.collect(doc);\n  doc = scorer.nextDoc();\n}\n{code}\n\nAnd similarly in ConjunctionScorer dropping 'more' may hit NPE if that Scorer is used.\n\nThere are a couple of ways to handle it:\n\n* In ReqExclScorer.doc() check for reqScorer == null and return MAX_VAL if it is. I count here on doc() not being called very frequently after this patch, since nextDoc() and advance() return the document. However that may not be the case (see ConjunctionScorer which uses doc() in doNext).\n\n* In ReqExclScorer make sure that reqScorer is never nullified, but then we'll need to figure out a different way to mark that there are no more docs (perhaps change the comparison of reqScorer to null to a boolean moreDocs?)\n",
            "date": "2009-05-20T11:06:54.072+0000",
            "id": 42
        },
        {
            "author": "Shai Erera",
            "body": "Actually, as I read the \"back-compat discussion\", I think that doing what you propose may break back-comapt? I mean, what if someone else's Scorer's doc() may throw an exception after its next() or skipTo() return false? So far our code made sure we don't call doc(), next() or skipTo() after the Scorer 'told' us it has no more documents. Now we're saying we will call doc() even if the scorer told us it has no more documents.\n\nEven though I believe it's very unlikely there is a Scorer which behaves that way, there is one for sure in Lucene (ReqExclScorer). So I don't know ... this whole back-compat is really a pain :).\n\nWhat do you think?",
            "date": "2009-05-20T12:37:24.998+0000",
            "id": 43
        },
        {
            "author": "Michael McCandless",
            "body": "I think I'd favor not nulling reqScorer, though that's a bigger change, so perhaps instead just add the null test in ReqExclScorer.doc() and we can later optimize away the nulling?\n\nAlso, in general, we can decouple the optimizations that become possible with Integer.MAX_VALUE as sentinel, from this issue...",
            "date": "2009-05-20T12:37:33.707+0000",
            "id": 44
        },
        {
            "author": "Shai Erera",
            "body": "Regarding my previous post on back-compat, maybe we can get away with it by documenting it in CHANGES? If we think it's not very likely there are many Scorers out there that will be affected by this change?",
            "date": "2009-05-20T12:50:22.668+0000",
            "id": 45
        },
        {
            "author": "Michael McCandless",
            "body": "bq. I think that doing what you propose may break back-comapt?\n\nHmm.. this is a challenge... as DISI now stands, it's undefined what doc() will do once next/skipTo has returned false.\n\nEven if it doesn't throw an exception,  it won't return our new sentinel value.\n\nI fear our only choice is to make a new method to return the doc, whose semantics are defined to reflect this change?  We'd provide a default impl that returns doc() if the iteration hasn't ended, else the sentinel?  Or.... some sort of wrapper to wrap an old DISI as the new one, but then we'd need a new DISI class to tell the difference.  Hmm.",
            "date": "2009-05-20T15:27:08.570+0000",
            "id": 46
        },
        {
            "author": "Shai Erera",
            "body": "Maybe there's a way out of this. In 2.9 we're already changing the contract of DISI with the new nextDoc and advance. As opposed to before (boolean), we're now stating what these methods should return when there are no more documents. So what if we do this:\n\n# In 2.9 we document that these methods should return MAX_VAL when there are no more documents.\n# Document doc() that in 3.0 it should return MAX_VAL when there are no more docs. Also put that in CHANGES.\n# I change the patch to return MAX_VAL for all current DISIs/Scorers, but don't take advantage of that yet in BS and ConjunctionScorer.\n# I open another issue for 3.0 which will take advantage of that, and ensure all current DISIs/Scorers' doc() return MAX_VAL when there are no more docs?\n\nI think that should work. We'll need to delay with that optimization beyond 2.9, but I don't think there's a nice and clean way around it otherwise. If 3.0 should quickly follow 2.9, we won't wait for long :).",
            "date": "2009-05-20T19:33:14.972+0000",
            "id": 47
        },
        {
            "author": "Michael McCandless",
            "body": "bq. Maybe there's a way out of this.\n\nOK that sounds like a good plan.  (Though it's yet another example of how we hurt our new users, by delaying these optimizations, in favor of our back-compat users...)",
            "date": "2009-05-20T20:11:37.502+0000",
            "id": 48
        },
        {
            "author": "Shai Erera",
            "body": "bq. Though it's yet another example of how we hurt our new users, by delaying these optimizations, in favor of our back-compat users..\n\nMaybe the thread on back-compat will go our way and we'll be free to introduce this change in 2.9? Although I doubt it, since for the sake of back-compat, even if the last one, we'll probably decide to start that after 3.0 is out.\n\nOh well ... like I said - hopefully our users will not have to wait long between 2.9 and 3.0.",
            "date": "2009-05-20T20:19:56.709+0000",
            "id": 49
        },
        {
            "author": "Shai Erera",
            "body": "Hmmm ... there is a problem with MAX_VAL as sentinel:\n\n# OpenBitSetIterator already has a nextDoc() method which returns -1 when exhausted. The current patch used -1 as sentinel, and therefore it was ok. But when I changed it to MAX_VAL, test-tag fail on TestOpenBitSet. We can document this change in \"changes to back-compat policy\" and fix the test on trunk and tag.\n# SortedVIntList returns an iterator which is a DISI. MAX_VAL is considered a valid value for SortedVIntList (TestSortedVIntList.test03() validates that). So if we use it as sentinel, we declare that MAX_VAL is invalid for SortedVIntList. Not sure if we can do that.\n\nI think the second is the problematic one - how do we handle iterators for which MAX_VAL is a valid value? I tend to say MAX_VAL should not be a valid value since by the name, *DocId*SetIterator, we should return doc Ids, and MAX_VAL is used as sentinel elsewhere and is not even considered a valid doc Id. Therefore those iterators should change their logic, if they rely on MAX_VAL being a valid value.\n\nBTW, besides the convenience, why should SortedVIntList expose a DocIdSetIterator? Nothing implies the list will hold doc Ids, therefore why commit to an iterator which returns doc Ids? If it's for convenience only, then maybe wrap that iterator with a true DISI where the Lucene code will need a true DISI?\n\nWhat do you think?",
            "date": "2009-05-21T09:24:37.207+0000",
            "id": 50
        },
        {
            "author": "Michael McCandless",
            "body": "bq. OpenBitSetIterator already has a nextDoc() method which returns -1 when exhausted. \n\nHmm -- maybe we need to choose a different name than nextDoc()?  Or... we make a new class (DISI2 or something) so we can strongly differentiate old from new semantics?\n\nbq. I tend to say MAX_VAL should not be a valid value\n\nRight, we are saying (have already said, elsewhere in Lucene's core code) that MAX_VAL is not a valid docID.\n\nbq. MAX_VAL is considered a valid value for SortedVIntList (TestSortedVIntList.test03() validates that). So if we use it as sentinel, we declare that MAX_VAL is invalid for SortedVIntList. Not sure if we can do that.\n\nI think we should remove that test, and decide MAX_VAL is not valid value in the list, because SortedVIntList is a DocIdSet.\n\nbq. BTW, besides the convenience, why should SortedVIntList expose a DocIdSetIterator? \n\nI don't follow -- SortedVIntList subclasses DocIdSet, which necessarily provides DISI iterator() method.  Why is this not a \"true DISI\"?",
            "date": "2009-05-21T09:54:22.010+0000",
            "id": 51
        },
        {
            "author": "Shai Erera",
            "body": "bq. SortedVIntList subclasses DocIdSet\n\nSorry, did not notice that. It's just that the test confused me, since I though it just stores VInts with no direct relation to doc Ids.\n\nbq. maybe we need to choose a different name than nextDoc()\n\nWhy? just because OBSI declared a method which we wanted anyway? You know .. it's something we don't give much thought to when we add methods to abstract classes, but what if someone extended DISI and added his own advance(int) or nextDoc() which don't behave like we expect them to. When he'll pass his DISI to the search flow somehow, not knowing these have become the primary methods, something will break.\n\nI'm not saying we should protect these cases too, because otherwise we won't be able to make any changes. But just because OBSI had nextDoc() declared doesn't mean we should go and find a different name. That's slightly unrelated to this issue, but our back-compat policy forces us to replace good names with moderate ones, just because we cannot change methods.\n\nCan't we just document in CHANGES that nextDoc() now returns MAX_VAL when no more docs exist, and we fix the test in tag? I mean, how many users do we think use OBSI directly?\n\nbq. MAX_VAL is not a valid docID\n\nI'll remove the test then (from trunk and tag) and document on DISI this assumption.",
            "date": "2009-05-21T10:21:40.861+0000",
            "id": 52
        },
        {
            "author": "Shai Erera",
            "body": "BTW, regarding SortedVIntList - even though it extends DocIdSet, its javadocs start with \"Store and iterate sorted integers in compressed form in RAM.\" - doc Ids are not mentioned. Also, the class is public, so nothing prevents someone from using it for integers that are not Doc Ids.\n\nI think I'll emphasize that in the javadocs, documenting the limitation of MAX_VAL so that people won't assume the wrong things.",
            "date": "2009-05-21T10:24:29.284+0000",
            "id": 53
        },
        {
            "author": "Michael McCandless",
            "body": "bq. I think I'll emphasize that in the javadocs, documenting the limitation of MAX_VAL so that people won't assume the wrong things.\n\n+1\n\nA docID is different from an \"int\", because docIDs must be 0 .. MAX_VAL-1.\n\n{quote}\nWhy? just because OBSI declared a method which we wanted anyway? You know .. it's something we don't give much thought to when we add methods to abstract classes, but what if someone extended DISI and added his own advance(int) or nextDoc() which don't behave like we expect them to. When he'll pass his DISI to the search flow somehow, not knowing these have become the primary methods, something will break.\n\nI'm not saying we should protect these cases too, because otherwise we won't be able to make any changes. But just because OBSI had nextDoc() declared doesn't mean we should go and find a different name. That's slightly unrelated to this issue, but our back-compat policy forces us to replace good names with moderate ones, just because we cannot change methods.\n{quote}\n\nYou're right, a random subclass of an abstract class could very well choose the name we are wanting to add, and then their class fails to compile, or (if the sigs turn out to be identical) runs bug possibly causes problems.\n\nBut in this case we know we have just such a class that has done so (OBSI).  And of course it did so for exactly the reasons that we are now wanting to add nextDoc to DISI.  My guess is eg Solr probably relies heavily on OBSI.nextDoc returning -1 when it's done and we're gonna cause AIOOB exceptions if we up and change to returning MAX_VAL.\n\nbq.  That's slightly unrelated to this issue, but our back-compat policy forces us to replace good names with moderate ones, just because we cannot change methods.\n\nAs much as it bothers me having to accept inferior names (so they don't conflict with the existing names), I think it's very much the lesser-of-evils here.",
            "date": "2009-05-21T11:39:49.926+0000",
            "id": 54
        },
        {
            "author": "Shai Erera",
            "body": "bq. My guess is eg Solr probably relies heavily on OBSI.nextDoc returning -1\n\nPerhaps the Solr guys can state then if and how much they mind this change? Before we start the journey of finding a different name for DISI.nextDoc(), just to deprecated OBSI.nextDoc() ...",
            "date": "2009-05-21T11:52:12.493+0000",
            "id": 55
        },
        {
            "author": "Shalin Shekhar Mangar",
            "body": "bq. Perhaps the Solr guys can state then if and how much they mind this change? Before we start the journey of finding a different name for DISI.nextDoc(), just to deprecated OBSI.nextDoc()\n\nI don't see any calls to OpenBitSetIterator.nextDoc in solr's source code.",
            "date": "2009-05-21T12:01:42.699+0000",
            "id": 56
        },
        {
            "author": "Shai Erera",
            "body": "bq. I don't see any calls to OpenBitSetIterator.nextDoc in solr's source code.\n\nSo Mike - does that mean I can change nextDoc() behavior in OBSI and document it?",
            "date": "2009-05-21T12:26:59.634+0000",
            "id": 57
        },
        {
            "author": "Michael McCandless",
            "body": "bq. So Mike - does that mean I can change nextDoc() behavior in OBSI and document it?\n\nOK let's tentatively go forward with that?",
            "date": "2009-05-21T12:51:27.233+0000",
            "id": 58
        },
        {
            "author": "Yonik Seeley",
            "body": "I'm warming to some of the simplifications that a MAX_VAL sentinel can bring.\n\nOn the other end of the scale... getting rid of \"if (firstTime)\" is another check I've long wanted to eliminate.\nif doc() produced -1 the first time, before any calls to next() or skipTo(), we could get rid of the if (firstTime) code in ConjunctionScorer and others I think.  The question is, would this be a burden to any scorers or DISI implementations?\n",
            "date": "2009-05-21T13:00:40.688+0000",
            "id": 59
        },
        {
            "author": "Shai Erera",
            "body": "I plan to open another issue for 3.0 to take advantage of MAX_VAL being returned from doc() also (we cannot rely on doc() returning MAX_VAL today when there are no more docs, hence why we need to wait with these changes until 3.0).\n\nYou're proposing to add another contract to doc() - to return -1 before nextDoc() and advance(int) were called. I can do that, but we can use this contract only in 3.0.\n\nUnless the community decides to change back-compat policy starting with 2.9, which will give us the opportunity to take advantage of \"latest & greatest\" right away.",
            "date": "2009-05-21T13:09:10.606+0000",
            "id": 60
        },
        {
            "author": "Shai Erera",
            "body": "MAX_VAL as sentinel + the documentation changes + a new entry to CHANGES \"back-compat change\" on OBSI.nextDoc() and next(int) + tag fixes.\n\nAll tests pass",
            "date": "2009-05-21T14:08:56.919+0000",
            "id": 61
        },
        {
            "author": "Michael McCandless",
            "body": "{quote}\nOn the other end of the scale... getting rid of \"if (firstTime)\" is another check I've long wanted to eliminate.\nif doc() produced -1 the first time, before any calls to next() or skipTo(), we could get rid of the if (firstTime) code in ConjunctionScorer and others I think. The question is, would this be a burden to any scorers or DISI implementations?\n{quote}\n\n+1\n\nSince we're changing DISI's semantics, now seems like a great time to make this change to.  Eliminating the \"if (firstTime)\" from next() would be great.\n\nBut: wouldn't ConjunctionScorer still need an init() to sort its sub-scorers?  (Though, really, we ought to do that sort based on more accurate criteria, eg add a DIS.approxCount() (the first docID of each sub-scorer is an approximation that could easily be very wrong).  If we had that, then in the ConjunctionScorer's ctor we would do the ordering).",
            "date": "2009-05-21T15:32:46.158+0000",
            "id": 62
        },
        {
            "author": "Michael McCandless",
            "body": "We could also consider adding DISI.start (we discussed this under another issue).\n\nAnd maybe likewise DISI.finish -- there's a question on the user's list now \"Do TermDocs and TermEnum need to be closed?\" that notes that DISI never gives one a chance to close.",
            "date": "2009-05-21T16:11:56.141+0000",
            "id": 63
        },
        {
            "author": "Yonik Seeley",
            "body": "bq. But: wouldn't ConjunctionScorer still need an init() to sort its sub-scorers?\n\nIf they are all on -1 to start with, they are already all sorted.\n\nWe could do some smart sorting in the constructor so that we skip in cheap and fast scorers first (TermScorers first, ordered by df, followed by simple conjunctions of terms, followed by other more expensive stuff like sloppy phrase queries and complex boolean queries.  Perhaps in the future, even a method on Scorer that estimates it's cost?\n\n",
            "date": "2009-05-21T16:27:59.126+0000",
            "id": 64
        },
        {
            "author": "Michael McCandless",
            "body": "bq. If they are all on -1 to start with, they are already all sorted.\n\nRight but that defeats the optimization.  I'm talking about this code in ConjunctionScorer:\n{code}\nArrays.sort(scorers, new Comparator() {         // sort the array\n    public int compare(Object o1, Object o2) {\n      return ((Scorer)o1).doc() - ((Scorer)o2).doc();\n    }\n  });\n\ndoNext();\n\n// If first-time skip distance is any predictor of\n// scorer sparseness, then we should always try to skip first on\n// those scorers.\n// Keep last scorer in it's last place (it will be the first\n// to be skipped on), but reverse all of the others so that\n// they will be skipped on in order of original high skip.\nint end=(scorers.length-1);\nfor (int i=0; i<(end>>1); i++) {\n  Scorer tmp = scorers[i];\n  scorers[i] = scorers[end-i-1];\n  scorers[end-i-1] = tmp;\n}\n{code}\n\nIe it sets things up so that \"typically\" the rarest sub-scorer drives the intersection.  If they are all on -1 then this heuristic won't work.\n\n{quote}\nWe could do some smart sorting in the constructor so that we skip in cheap and fast scorers first (TermScorers first, ordered by df, followed by simple conjunctions of terms, followed by other more expensive stuff like sloppy phrase queries and complex boolean queries. Perhaps in the future, even a method on Scorer that estimates it's cost?\n{quote}\n\nRight, we'd need to do something along these lines if we switch DISI to start with doc() = -1.",
            "date": "2009-05-21T16:39:11.192+0000",
            "id": 65
        },
        {
            "author": "Michael McCandless",
            "body": "Oh, it turns out OBSI.nextDoc is new in 2.9!  So we are free to change it...",
            "date": "2009-05-21T17:08:23.366+0000",
            "id": 66
        },
        {
            "author": "Earwin Burrfoot",
            "body": "bq. Oh, it turns out OBSI.nextDoc is new in 2.9!\nThe phrase sounds all too familiar :)\nThere's one absolutely cool javadoc tag, which I suggest we start using for all user-visible classes and their members. It's called - @Since. Suddenly, everything that's not yet released (and that's a big bunch), is clearly marked as free for changes and amendments.",
            "date": "2009-05-21T19:52:00.746+0000",
            "id": 67
        },
        {
            "author": "Shai Erera",
            "body": "bq. Oh, it turns out OBSI.nextDoc is new in 2.9!\n\nAre you sure about it? If so, then why test-tag failed on it? Notice that there are two methods nextDoc() and next(int). Are both new in 2.9? If so, it means somebody added them to the tag, for some reason ...\n\nBTW, I'm going to open the follow-up issue to that, so we can discuss whatever improvements we want to make to the Scorers following the MAX_VAL sentinel there. Otherwise, they will get lost in this issue, and when we'll handle the follow-up one, we might not remember everything.\n\nbq. It's called - @Since\n\nThat's absolutely a great idea !",
            "date": "2009-05-21T20:18:42.823+0000",
            "id": 68
        },
        {
            "author": "Michael McCandless",
            "body": "bq. Are you sure about it? \n\nYes.\n\nbq. If so, then why test-tag failed on it?\n\nUnfortunately, we came up with the idea of the back-compat branch after 2.4 was released, so we cut the branch at that point (in 2.9), so the back-compat branch does contain tests for early 2.9-only features. \n\nbq. Are both new in 2.9?\n\nYes.\n\n{quote}\nBTW, I'm going to open the follow-up issue to that, so we can discuss whatever improvements we want to make to the Scorers following the MAX_VAL sentinel there. Otherwise, they will get lost in this issue, and when we'll handle the follow-up one, we might not remember everything.\n{quote}\n\nAgreed!",
            "date": "2009-05-21T20:28:29.629+0000",
            "id": 69
        },
        {
            "author": "Shai Erera",
            "body": "{quote}\nAre both new in 2.9?\n\nYes.\n{quote}\n\nOh that's great - and here I was deprecating next(int) in favor of the new advance. I'll just delete it then.\n\nbq. I'm going to open the follow-up issue to that\n\nOpened LUCENE-1652 and copied what's relevant from this issue to there. If I missed something, please add it.",
            "date": "2009-05-21T20:47:55.401+0000",
            "id": 70
        },
        {
            "author": "Shai Erera",
            "body": "Removed next(int) from OBSI and put @since 2.9 on the new methods in DISI.\n\nI think the patch is ready to be committed. We can add check() as appropriate in LUCENE-1652, when we utilize MAX_VAL.",
            "date": "2009-05-24T07:30:32.460+0000",
            "id": 71
        },
        {
            "author": "Shai Erera",
            "body": "A question regarding BS.nextDoc(). I paste the current code (that I'm working on, for reference).\n\n{code}\n  public int nextDoc() throws IOException {\n    // TODO: can remove more?\n//    boolean more;\n    do {\n      while (bucketTable.first != null) {         // more queued\n        current = bucketTable.first;\n        bucketTable.first = current.next;         // pop the queue\n\n        // check prohibited & required, and minNrShouldMatch\n        if ((current.bits & prohibitedMask) == 0 &&\n            (current.bits & requiredMask) == requiredMask &&\n            current.coord >= minNrShouldMatch) {\n          return doc = current.doc;\n        }\n      }\n\n      // refill the queue\n//      more = false;\n      end += BucketTable.SIZE;\n      for (SubScorer sub = scorers; sub != null; sub = sub.next) {\n        Scorer scorer = sub.scorer;\n        sub.collector.setScorer(scorer);\n        int doc = scorer.docID();\n        if (doc == -1) {\n          doc = scorer.nextDoc();\n        }\n        while (doc < end) {\n          sub.collector.collect(doc);\n          doc = scorer.nextDoc();\n        }\n//        if (doc != NO_MORE_DOCS) {\n//          more = true;\n//        }\n      }\n    } while (bucketTable.first != null/* || more*/);\n\n    return doc = NO_MORE_DOCS;\n  }\n{code}\n\nI wanted to get rid of 'more', following all the changes I'm doing to DISI. I did it and all tests pass, but I want to double-check my understanding, since I don't know for sure if there is a test that tests my change.\n\nAs far as I see it, there are two code sections: (1) iterates on bucketTable until it is exhausted (i.e., calls to nextDoc() will first consume bucketTable) and (2) iterate on all sub scorers. The second iteration populates the bucket table from all sub-scorers and reiterates, consuming bucket table again, in calls to nextDoc(). Then, at some point, all sub scorers don't have anything more to collect, and bucketTable.first is null for the last time, at which point nextDoc() returns NO_MORE_DOCS.\n\nSo it looks like I can indeed get rid of 'more'. But what puzzles me is why it was there in the first place. Leaving the code as-is means that someone thought of a case where a sub-scorer will have more documents to collect, but still after the 2nd code segment the bucketTable was empty. That's why I'm not sure I can remove 'more' safely - i.e., is it possible that a sub-scorer will have more documents, however all the docs that were collected by sub.collector will not affect the bucketTable? It doesn't look like in the code.\n\nSame question for BS.score(Collector collector, int max).",
            "date": "2009-05-26T14:41:58.866+0000",
            "id": 72
        },
        {
            "author": "Shai Erera",
            "body": "About ConjunctionScorer.doNext() (this also applies to FilteredQuery.advanceToCommon()). I've changed it, following Mike's proposal to this:\n\n{code}\n  private boolean doNext() throws IOException {\n    int first = 0;\n    lastDoc = scorers[scorers.length - 1].docID();\n    Scorer firstScorer;\n    while ((firstScorer = scorers[first]).docID() < lastDoc) {\n      lastDoc = firstScorer.advance(lastDoc);\n      first = first == scorers.length - 1 ? 0 : first + 1;\n    }\n    return lastDoc != NO_MORE_DOCS;\n  }\n{code}\n\nThis indeed gets rid of 'more', the check for 'more' in the while condition and also the assignment to more. But now I think it may introduce a different inefficiency. Let's say that firstScorer.advance() returns NO_MORE_DOCS. The next scorer's docID is obviously smaller, and therefore the following call will be (first line in the 'while' body): *lastDoc = firstScorer.advance(Integer.MAX_VALUE);*. There are Scorers which cannot implement that efficiently.\n\nWith 'more' this would not have happened, since the while condition would terminate before that.\n\nAre we sure that that's a worthwhile enhancement.\n\nBTW, the code for FilteredQuery looks like this:\n\n{code}\n            while (scorerDoc != disiDoc) {\n              if (scorerDoc < disiDoc) {\n                if ((scorerDoc = scorer.advance(disiDoc)) == NO_MORE_DOCS) {\n                  return NO_MORE_DOCS;\n                }\n              } else {\n                if ((disiDoc = docIdSetIterator.advance(scorerDoc)) == NO_MORE_DOCS) {\n                  return NO_MORE_DOCS;\n                }\n              }\n            }\n            return scorerDoc;\n{code}\n\nAnd I thought to change it to this:\n\n{code}\nwhile (scorerDoc != disiDoc) {\n  if (scorerDoc < disiDoc) {\n    scorerDoc = scorer.advance(disiDoc);\n  } else {\n  disiDoc = docIdSetIterator.advance(scorerDoc);\n  }\n}\nreturn scorerDoc;\n{code}\n\nWhat do you think?",
            "date": "2009-05-26T15:17:11.953+0000",
            "id": 73
        },
        {
            "author": "Paul Elschot",
            "body": "Well, since you asked: could you try and put all conjunctions on doc ids in a single place?\nThat would also prepare for things like LUCENE-1252 .\n\nThe tests for boolean queries are quite comprehensive nowadays. So when all tests pass, don't worry too much.\nIn case there is a bug left, it will be so much of corner case that it can be fixed at another issue.",
            "date": "2009-05-26T15:34:58.879+0000",
            "id": 74
        },
        {
            "author": "Michael McCandless",
            "body": "bq. Leaving the code as-is means that someone thought of a case where a sub-scorer will have more documents to collect, but still after the 2nd code segment the bucketTable was empty.\n\nThis would happen when none of the sub-scorers had docIDs in the\ncurrent bucket range.\n\nEG say the first docID of all sub-scorers is 3000,\nand BucketTable.SIZE is 2048.  On the first time through part (2), no\nsub-scorer will add to the bucket, so on finishing part (2),\nbucketTable.first will still be null but more will be true, and so the\nwhole loop would (and, should) keep repeating.\n\nI think?\n\nSo in fact your change should break that case.... can you add a\nbreaking unit test showing this?\n\nAlso, I wonder if this can be removed, by init'ing the sub-scorers up\nfront:\n{code}\nif (doc == -1) {\n  doc = scorer.nextDoc();\n}\n{code}\n",
            "date": "2009-05-26T15:58:00.124+0000",
            "id": 75
        },
        {
            "author": "Michael McCandless",
            "body": "bq. There are Scorers which cannot implement that efficiently.\n\nWhich Scorers do this slowly?",
            "date": "2009-05-26T16:01:00.163+0000",
            "id": 76
        },
        {
            "author": "Michael McCandless",
            "body": "The changes to FilteredQuery look good!",
            "date": "2009-05-26T16:03:44.760+0000",
            "id": 77
        },
        {
            "author": "Shai Erera",
            "body": "bq. Which Scorers do this slowly?\n\nTermScorer, ValueSourceQuery which uses TermDocs.skipTo ... just two examples. I'm not sure how efficient TermDocs is.\n\nWe could state in the javadocs that Integer.MAX_VALUE may be passed and if you think you cannot impl advance(MAX_VAL) efficiently, always check if that's what was passed?\n\nbq. The changes to FilteredQuery look good! \n\nIf we agree that calling advance(MAX_VAL) is ok, I'll enable both fixes.",
            "date": "2009-05-26T16:24:44.713+0000",
            "id": 78
        },
        {
            "author": "Michael McCandless",
            "body": "bq. I'm not sure how efficient TermDocs is.\n\nTermDocs.skipTo(Integer.MAX_VALUE) should be quite fast (it's using multi-level skipping)?\n\nbq. We could state in the javadocs that Integer.MAX_VALUE may be passed and if you think you cannot impl advance(MAX_VAL) efficiently, always check if that's what was passed?\n\nLet's do that, but I don't think the scorers that use TermDocs.skipTo need the extra check.",
            "date": "2009-05-26T17:34:03.113+0000",
            "id": 79
        },
        {
            "author": "Shai Erera",
            "body": "bq. Let's do that, but I don't think the scorers that use TermDocs.skipTo need the extra check.\n\nOk will do. So it means that none of the current DISIs/Scorers should do this check? I'll double-check to make sure and post back if I find something suspicious.\n\nbq. So in fact your change should break that case.... can you add a breaking unit test showing this?\n\nI will look into it. \n\nbq. Also, I wonder if this can be removed, by init'ing the sub-scorers up front\n\nWill check this too.",
            "date": "2009-05-26T17:39:40.950+0000",
            "id": 80
        },
        {
            "author": "Shai Erera",
            "body": "I added testEmptyBucketWithMoreDocs in TestBooleanScorer which creates a BooleanScorer that returns 3000 the first time nextDoc is called (or advance with target <= 3000) and then NO_MORE_DOCS. It asserts that calling nextDoc() once returns 3000 and the second time returns NO_MORE_DOCS.\n\nIndeed, with the change I've made above it fails. So it's good that this test is there now. It makes BS/BS2 one more testcase-proof. That means I cannot remove 'more' ...\n\nbq. The tests for boolean queries are quite comprehensive nowadays. So when all tests pass, don't worry too much.\n\nPaul, I guess we should always worry :). Anyway, now we can say that sentence with a bit more confidence :).\n\nbq. Also, I wonder if this can be removed, by init'ing the sub-scorers up front.\n\nHow about if I call nextDoc() when addScorer is called? I tried it and all tests pass, which at least means there is no test case that fails (see above comment). If I do this, I can also check if the result is NO_MORE_DOCS and don't add it to the sub scorers list in the first place.\n\nWhat do you think?\n\nBTW, funny thing just happened - turns out we deprecated all of DISIs methods, but not DISI itself. This is actually good since it allows us to keep DISI and not deprecate Scorer and all the public DISIs that extend DISI. And it saves us the effort of finding alternative names ... Just a thought.\n\nAnother thought of an optimization. Somewhere up this issue, we discussed adding start() to DISI, just to get rid of firstTime in DisjunctionMaxScorer and ConjunctionScorer. At least for DMS, I think I can remove add(Scorer) and add to its ctor an array of Scorer[]. DMS is used by DMQ, and the number of scorers is knows in advance.\nAlso, DMS can be changed quite a bit, not using ArrayList but an array. ArrayList get/set methods do range checks every time you call them, and we're calling them quite a lot.",
            "date": "2009-05-26T20:59:12.232+0000",
            "id": 81
        },
        {
            "author": "Shai Erera",
            "body": "Also, since BS.add() is called by BS2 only, and BS is package-private and instantiated by BS2 only, I can remove add, and pass to BS ctor two iterators (for prohibited and optional). That will allow us to compute coordFactor up front and remove the check from score() and score(Collector, int).\n\nWhat do you think?",
            "date": "2009-05-26T21:08:27.353+0000",
            "id": 82
        },
        {
            "author": "Paul Elschot",
            "body": "I'd also prefer to have constructors with for example a List argument for the subscorers, and use an array internally. This is easily done when the parser allows postorder query construction, and all reasonable parsers can do that.\nWhen all subscorers are given in the constructor, most (or even all) of the checks on firstTime private booleans in the various scorers can be removed.\n\nOne minor disadvantage of removing such firstTime booleans is that during scorer construction the index may have to be accessed because some constructors will use the next() method on their subscorers.\nSo, when BooleanScorer2 was added, I did not like the really the add() method and firstTime booleans either, but I left them in because in that way the next() method would not be called on subscorers at construction time.\nIirc I used constructor List arguments in the surround package, and that's still my preference.",
            "date": "2009-05-26T21:46:19.083+0000",
            "id": 83
        },
        {
            "author": "Shai Erera",
            "body": "bq. One minor disadvantage of removing such firstTime booleans is that during scorer construction the index may have to be accessed because some constructors will use the next() method on their subscorers.\n\nI don't see any difference between instantiating BS and immediately after that calling add several times to instantiating BS with the scorers. Accessing the index, to me, seems to be identical.\n\nIn fact, by removing add() and passing the scorers in the ctor we can also get rid of redundant code in add(). Currently, it checks if the scorer is required/prohibited/both, but both does not happen in reality and in each add only required or prohibited is set.\n\nIn general I think we should review such scorers and make a decision on a case-by-case basis. For BS, I'd like to change it since I don't see any back-compat issue, and it should clear the code a bit. I'll go ahead and do it, and if I run into any obstacles I'll post back.",
            "date": "2009-05-27T04:40:57.866+0000",
            "id": 84
        },
        {
            "author": "Michael McCandless",
            "body": "bq. I added testEmptyBucketWithMoreDocs in TestBooleanScorer which creates a BooleanScorer that returns 3000 the first time nextDoc is called\n\nExcellent!\n\nbq. How about if I call nextDoc() when addScorer is called? I tried it and all tests pass, which at least means there is no test case that fails (see above comment). If I do this, I can also check if the result is NO_MORE_DOCS and don't add it to the sub scorers list in the first place.\n\nThat sounds reasonable.\n\nbq. Another thought of an optimization. Somewhere up this issue, we discussed adding start() to DISI, just to get rid of firstTime in DisjunctionMaxScorer and ConjunctionScorer.\n\nI think having doc() return -1 before next/advance have been called\nwas also needed (or maybe just helpful?) for this.\n\nAlso, thinking more on this, isn't DISI.start() redundant?  (Since\nsuch init'ing could be done in Weight.scorer(), when the Scorer is\ncreated)?  We're not allowed to reuse a DISI, so...\n\nOh, I see: it's not redundant for scorers that do incremental\nconstruction (BS, BS2).  But I think we should fix such cases to\naccept all sub-queries up front, then DISI.start() is redundant?\n\nbq. Also, DMS can be changed quite a bit, not using ArrayList but an array.\n\nThese sound like good optimizations too.\n\nbq. Also, since BS.add() is called by BS2 only, and BS is package-private and instantiated by BS2 only, I can remove add, and pass to BS ctor two iterators (for prohibited and optional). That will allow us to compute coordFactor up front and remove the check from score() and score(Collector, int).\n\nThis sounds good, as well as switching BS2 to take all its sub-queries\nup front.\n",
            "date": "2009-05-27T09:37:13.154+0000",
            "id": 85
        },
        {
            "author": "Shai Erera",
            "body": "I prefer to defer DISI.start/finish until it's actually needed. Maybe even not part of this issue. For now, I'll finish the optimizations we've discussed and post a patch.\n\nBTW Mike, docID()'s contract states that is should return -1 if nextDoc()/advance() weren't called.\n\nAlso, I've done the changes to BS and the code looks much more simpler. Working on DMS now.",
            "date": "2009-05-27T10:43:52.245+0000",
            "id": 86
        },
        {
            "author": "Michael McCandless",
            "body": "bq. I prefer to defer DISI.start/finish until it's actually needed.\n\nI agree.  I'm thinking at this point that neither should be needed.  start() should be done on creating the Scorer, and finish() should not be needed because Scorers ought to be lightweight enough to not need closeable resources.  If one makes a custom Scorer one can always close it outside of Lucene.\n\nbq. BTW Mike, docID()'s contract states that is should return -1 if nextDoc()/advance() weren't called.\n\nRight, so this should mean the \"firstTime\" logic should be removable from all core Scorers.\n\nbq. Also, I've done the changes to BS and the code looks much more simpler. Working on DMS now.\n\nFabulous :)  Can't wait to see it!",
            "date": "2009-05-27T11:57:41.488+0000",
            "id": 87
        },
        {
            "author": "Shai Erera",
            "body": "Patch includes the new docID on DISI as well as a bunch of improvements to scorers, such as BooleanScorer, DisjunctionMaxScorer and ConjunctionScorer.\n\nAll tests pass.\n\nBTW, I wasn't able to completely get rid of firstTime in ConjunctionScorer, even though I moved everything to the ctor. Maybe I'm missing something ...",
            "date": "2009-05-27T13:53:08.080+0000",
            "id": 88
        },
        {
            "author": "Michael McCandless",
            "body": "I'm seeing some patch hunks failing -- can you svn up to current trunk & repost the patch?  Thanks.",
            "date": "2009-05-27T14:30:44.646+0000",
            "id": 89
        },
        {
            "author": "Shai Erera",
            "body": "Can you try now?",
            "date": "2009-05-27T14:55:28.216+0000",
            "id": 90
        },
        {
            "author": "Michael McCandless",
            "body": "Much better -- I'll look at the patch.  Thanks.",
            "date": "2009-05-27T15:22:56.795+0000",
            "id": 91
        },
        {
            "author": "Michael McCandless",
            "body": "Shai can I make some small tweaks to the patch & post another iteration?",
            "date": "2009-05-27T15:45:09.747+0000",
            "id": 92
        },
        {
            "author": "Shai Erera",
            "body": "Did you seriously ask that? :)\n\nOf course !",
            "date": "2009-05-27T16:07:11.768+0000",
            "id": 93
        },
        {
            "author": "Michael McCandless",
            "body": "Well I don't want to have both of us working on it and then have to merge.... we need a better fast switching/assigned to mechanism...",
            "date": "2009-05-27T16:43:06.869+0000",
            "id": 94
        },
        {
            "author": "Shai Erera",
            "body": "It's ok. I've been staring at this code for so long, it definitely could use fresh eyes.\n\nBesides, I've finished all what I planned to do. So I'll just wait for your updated patch, review it, and if I'll want to add anything I'll let you know.\n\nOne thing I noticed from the other issue we've both posted patches to, is that the order of the classes in the patch don't match between us, so it's harder to compare your patch with mine. But if those are really _tweaks_, it should show up more easily.",
            "date": "2009-05-27T17:01:24.081+0000",
            "id": 95
        },
        {
            "author": "Michael McCandless",
            "body": "\nPatch is looking good!\n\nOK I attached new patch... note that patch applies to latest\nback-compat tag, so you need to run \"ant download-tag\" before applying\nit.  Comments/questions:\n\n  * Init'd doc = -1 in BooleanScorer\n\n  * Can you add an \"assert scorer.docID() == -1\" in IndexSearcher\n    right when it gets the scorer?  Then we can tease out where we\n    failed to init to -1.\n\n  * Hmm... maybe we permit DISI.docID() to also return NO_MORE_DOCS\n    after the DISI is created?  EG we do this in ConjunctionScorer.\n    (Or, maybe, any docID that's < the first real docID...hmmm.)\n\n  * Made DocsWriter.applyDeletes a bit more efficient -- no need to\n    check for the sentinel (it's \"congruent\" w/ the existing check).\n    Though it did require an upcast to long, so if we do any add\n    arithmetic w/ doc where doc could be NO_MORE_DOCS we must be\n    careful to upcast.\n\n  * I think we can remove the firstTime from ReqExclScorer, since\n    docID() is defined to return -1 at start?\n\n  * Made BS.coordFactors final\n\n  * Fixed \"Shai Erera vs. Mike McCandless\" -> \"Shai Erera\n    via Mike McCandless\"\n\n  * The addition of this:\n{code}\n    if (docNr == -1) { // should be if nextDoc() was not called yet\n      docNr = nextDoc();\n    }\n{code}\n    in BooleanScorer2.score(Collector, int) makes me a bit nervous --\n    I think one is supposed to have called nextDoc prior to calling\n    this?  Also, this was added to the same method in Scorer.\n\n  * BS2.nextDoc is still needing to check if it's supposed to call\n    initCountingSumScorer?  Can we do this in ctor?\n\n  * Actually, you did get rid of firstTime from ConjunctionScorer?\n    Maybe you meant BS2?  (Oh, or maybe you meant the addition of\n    \"} else if (lastDoc == -1) {\" in ConjunctionScorer?  So... if we\n    had a way to do that sorting (in the ctor) without invoking\n    nextDoc on each sub-scorer, then you could eliminate that extra\n    check right?\n\n  * Put some \"nocommit\" questions in the patch\n",
            "date": "2009-05-27T17:35:14.596+0000",
            "id": 96
        },
        {
            "author": "Shai Erera",
            "body": "bq. Fixed \"Shai Erera vs. Mike McCandless\" -> \"Shai Erera via Mike McCandless\"\n\nha ha ha :). Sorry ...\n\nI'll take a look at the comments a bit later. Regarding ConjunctionScorer, you're right. If we had a way to sort on the scorers w/o invoking nextDoc(), we could remove that check from nextDoc().",
            "date": "2009-05-27T18:08:22.153+0000",
            "id": 97
        },
        {
            "author": "Michael McCandless",
            "body": ";)  It's OK.\n\nbq. Regarding ConjunctionScorer, you're right. If we had a way to sort on the scorers w/o invoking nextDoc(), we could remove that check from nextDoc()\n\nOK we may need to hold off on that until we add something like approxCount() to Scorer, or something the measures approximate cost.",
            "date": "2009-05-27T18:21:44.679+0000",
            "id": 98
        },
        {
            "author": "Shai Erera",
            "body": "Regarding the nocommit in ConjunctionScorer's ctor - I think the problem with moving doNext() to the end of the ctor is the order of the scorers that will be iterated on. I.e., currently the scorers are first advanced to their first doc, then sorted based on their docID, then advanced to the doc ID that all agree on, in the order of the sort.\n\nIf you move doNext() to the end of the method, then the scorers are sorted based on their docID, and then immediately re-sorted (based on their sparseness, which is a heuristic applied based on their first docID).\n\nIf I understand correctly, the problem with calling doNext() after the re-sort is this: assume you have 5 scorers, whose first docs are 1, 2, 3, 5, 5 respectively. Sorting leaves the array as is (or changes it to be in that order). If you call doNext() after array.sort, then you advance all the first scorers to 5 (or a larger doc ID they all agree on). However, if you do the re-sort, the order will be 5, 3, 2, 1, 5 and then if you call doNext(), it will stop immediately, since the first scorer's docs equals the last one. So you break an invariant, that after calling doNext() all scorers are on the same doc ID.\n\nThat's at least how I understand it. I hope I didn't write too much to explain the obvious (to others).\n\nSo I'll delete the nocommit tag.\n\nRegarding nocommit in ReqExclScorer, you're right. I'll remove firstTime entirely.\n\nbq. Can you add an \"assert scorer.docID() == -1\" in IndexSearcher right when it gets the scorer?\n\nDone.\n\nbq. BS2.nextDoc is still needing to check if it's supposed to call initCountingSumScorer? Can we do this in ctor?\n\nIt can, if I delete add() and do all the work in the ctor. I'll need to pass 3 arrays (Scorer[], boolean[] /*required*/, boolean[] /*prohibited*/) though, or pass the list of Weights, Clauses and IndexReader. I'm not too fan of either. I check which is the lesser evil.\n\nbq. BooleanScorer2.score(Collector, int) makes me a bit nervous\n\nI didn't think it's such a big deal since it's one 'if' before scoring starts. It's not like it's called for every score(). Do you think we should resolve it?\n\nbq. Hmm... maybe we permit DISI.docID() to also return NO_MORE_DOCS after the DISI is created? EG we do this in ConjunctionScorer. (Or, maybe, any docID that's < the first real docID...hmmm.)\n\nI do not fully follow you. By allowing to return -1, we already allow any DISI to return a doc ID that's < the first real doc ID. And allowing to return NO_MORE_DOCS looks strange to me .. I mean imagine a code which creates a DISI and calls doc() and gets back NO_MORE_DOCS .. that'd be strange, won't it?",
            "date": "2009-05-27T20:40:54.562+0000",
            "id": 99
        },
        {
            "author": "Michael McCandless",
            "body": "{quote}\nRegarding the nocommit in ConjunctionScorer's ctor - I think the problem with moving doNext() to the end of the ctor is the order of the scorers that will be iterated on. I.e., currently the scorers are first advanced to their first doc, then sorted based on their docID, then advanced to the doc ID that all agree on, in the order of the sort.\nIf you move doNext() to the end of the method, then the scorers are sorted based on their docID, and then immediately re-sorted (based on their sparseness, which is a heuristic applied based on their first docID).\n\nIf I understand correctly, the problem with calling doNext() after the re-sort is this: assume you have 5 scorers, whose first docs are 1, 2, 3, 5, 5 respectively. Sorting leaves the array as is (or changes it to be in that order). If you call doNext() after array.sort, then you advance all the first scorers to 5 (or a larger doc ID they all agree on). However, if you do the re-sort, the order will be 5, 3, 2, 1, 5 and then if you call doNext(), it will stop immediately, since the first scorer's docs equals the last one. So you break an invariant, that after calling doNext() all scorers are on the same doc ID.\n\nThat's at least how I understand it. I hope I didn't write too much to explain the obvious (to others).\n\nSo I'll delete the nocommit tag.\n{quote}\n\nAhh -- good explanation!  Phew.  This must be what leads to the two\ntest failures.  So leave it where it is (maybe add a comment\nexplaining it cannot be moved down, lest anyone else gets tempted).\n\n{quote}\n> Can you add an \"assert scorer.docID() == -1\" in IndexSearcher right when it gets the scorer?\n\nDone.\n{quote}\n\nOK, except we may delete it depending on the relaxing (below)...\n\n{quote}\n> BS2.nextDoc is still needing to check if it's supposed to call initCountingSumScorer? Can we do this in ctor?\n\nIt can, if I delete add() and do all the work in the ctor.\n{quote}\n\nI think we should (lacking a DISI.start).\n\nbq. I'll need to pass 3 arrays (Scorer[], boolean[] /required/, boolean[] /prohibited/) though, or pass the list of Weights, Clauses and IndexReader. I'm not too fan of either. I check which is the lesser evil.\n\nHmm -- I don't have a stronger lesser-of-evils preference.  I suppose,\ninstead, we could add a \"start\" only to BS2, which BQ would call once\nit's done adding?  Or, simply call initCountingSumScorer from BQ and\ndon't do the check per nextDoc/advance.\n\n{quote}\n> BooleanScorer2.score(Collector, int) makes me a bit nervous\n\nI didn't think it's such a big deal since it's one 'if' before scoring starts. It's not like it's called for every score(). Do you think we should resolve it?\n{quote}\n\nWhat specifically made me nervous that it was even necessary to add\nthis (having to conditionally next wasn't needed before) in the first\nplace.  If you remove it, does something actually break?  Like what\ncaused it to be added?  (Because I want to go explore/understand\n*that* cause).\n\n{quote}\n> Hmm... maybe we permit DISI.docID() to also return NO_MORE_DOCS after the DISI is created? EG we do this in ConjunctionScorer. (Or, maybe, any docID that's < the first real docID...hmmm.)\n\nI do not fully follow you. By allowing to return -1, we already allow any DISI to return a doc ID that's < the first real doc ID. And allowing to return NO_MORE_DOCS looks strange to me .. I mean imagine a code which creates a DISI and calls doc() and gets back NO_MORE_DOCS .. that'd be strange, won't it?\n{quote}\n\nI'm thinking it's OK to call docID before next, and that all we\nrequire is that call return a docID less than its first real docID.\n\nAnd, if you know up-front you have no docs, returning NO_MORE_DOCS up\nfront is also OK.\n\nIe this is a relaxation over \"you must return -1 before nextDoc has\nbeen called\".\n\n(EG I think the last patch would return NO_MORE_DOCS from docID() in\nConjunctionScorer if it determines in ctor that no docs match).\n",
            "date": "2009-05-27T20:59:41.555+0000",
            "id": 100
        },
        {
            "author": "Shai Erera",
            "body": "bq. BS2.nextDoc is still needing to check if it's supposed to call initCountingSumScorer? Can we do this in ctor?\n\nAfter I made add() private, created a ScorerClauseWrapper (in BQ) and passed to BS2 a list of SCW (to pass in one call Scorer, req, prohib), I couldn't still call initCountingSumScorer in the ctor. Then it reminded me that we've had this discussion before - it's related to being able to ask for topScorer() or not. Reason is, if I call initCount...() in the ctor, it advances the sub scorers. If the scorer is then used as a topScorer, they may be advanced again, if BS is used.\n\nSo I thought, let's not call nextDoc() in BS's ctor, but that leads to other problems, since the scorers passed may have called nextDoc() themselves (DisjunctionSumScorer) or may not (ReqExclScorer).\n\nThe decision back then was to leave it as-is, and handle it in LUCENE-1630, when we'll be able to ask for topScorer. What do you think?\n\nbq. Like what caused it to be added?\n\nTwo lines below it, where it will be sent to Collector for collection, since it's < max. This hits AIOOBE for some Collectors.\n\nbq. I think the last patch would return NO_MORE_DOCS from docID() in ConjunctionScorer if it determines in ctor that no docs match\n\nActually, now that you write it I do notice I broke that invariant in CS. If there is even one scorer that doesn't have any docs, lastDoc is already set to NO_MORE_DOCS and calling docID before nextDoc will return NO_MORE_DOCS and not -1.\n\nSo I think it's a fair relaxation. Just to be clear - this is just a relaxation you're talking about right? This shouldn't affect any of the existing scorers.\n\nSo if we're on the same page, I'll document that relaxation and remove the assert call I've added to IndexSearcher. But I don't think this should actually change scorers.",
            "date": "2009-05-27T21:22:14.700+0000",
            "id": 101
        },
        {
            "author": "Shai Erera",
            "body": "Deprecated SpanScorer.firstTime and removed the use of it. (in general, I think that SpanScorer should be reviewed, since it's a public class that's documented that it's for inheritance), but I'm not sure all methods should be open for inheritance.\nAlso, we may want to add nextDoc and advance() to Spans. But that's a different issue.\n\nI noticed I accidentally changed the signature of setFreqCurrentDoc, which is protected. So I reverted the change and added JustCompileSpanScorer which overrides that method, so we'll discover that safely in the future (test-tag still passes).\n\nI also changed the documentation of docID, stating the relaxed policy (in DISI and CHANGES).\n\nBesides, I've fixed all of your other comments, except for BS2 initCountingSumScorer which I don't think we can do yet.\n\nIn general, can we do any other optimization in a different issue? This one already contains a lot of changes, and was opened primarily for introducing the new methods. We have LUCENE-1652 for further optimizations, even though we've covered most (or all) of them here, so perhaps we should cancel it?",
            "date": "2009-05-28T08:41:04.148+0000",
            "id": 102
        },
        {
            "author": "Michael McCandless",
            "body": "{quote}\nAfter I made add() private, created a ScorerClauseWrapper (in BQ) and passed to BS2 a list of SCW (to pass in one call Scorer, req, prohib), I couldn't still call initCountingSumScorer in the ctor. Then it reminded me that we've had this discussion before - it's related to being able to ask for topScorer() or not. Reason is, if I call initCount...() in the ctor, it advances the sub scorers. If the scorer is then used as a topScorer, they may be advanced again, if BS is used.\n\nSo I thought, let's not call nextDoc() in BS's ctor, but that leads to other problems, since the scorers passed may have called nextDoc() themselves (DisjunctionSumScorer) or may not (ReqExclScorer).\n\nThe decision back then was to leave it as-is, and handle it in LUCENE-1630, when we'll be able to ask for topScorer. What do you think?\n{quote}\nSigh.  I wonder if you could record that next had been called, in the ScorerClauseWrapper, and then BS wouldn't re-do the next in its ctor?  That added if would only be in the ctor.\n\nBut, yeah I agree: let's wind down this issue and push this (and other) optimizations into LUCENE-1652.\n\nbq. I noticed I accidentally changed the signature of setFreqCurrentDoc, which is protected. So I reverted the change and added JustCompileSpanScorer which overrides that method, so we'll discover that safely in the future (test-tag still passes).\n\nWoops, OK good.\n\nI'll have a look through the current patch.  I think we are close!",
            "date": "2009-05-28T09:59:53.430+0000",
            "id": 103
        },
        {
            "author": "Shai Erera",
            "body": "Mike, I think we may have relaxed the policy of docID() a bit too much. IMO, it should be clear what this method returns, and saying that it should return any doc ID which is smaller than the first available, or NO_MORE_DOCS if it knows there are not docs in the set, is problematic.\n\nConsider the code in BS2 which checks if it should call nextDoc() before the while loop (the score(Collector, int) method). If a DISI decided to return '2' simply because the first doc available is '3', then we may incorrectly collect '2'.\n\nSo I say we relax the policy in this way: \"an implementation can return -1 if it knows the iterator is not exhausted, or NO_MORE_DOCS otherwise\".",
            "date": "2009-05-29T04:47:49.848+0000",
            "id": 104
        },
        {
            "author": "Michael McCandless",
            "body": "bq. Consider the code in BS2 which checks if it should call nextDoc() before the while loop (the score(Collector, int) method). If a DISI decided to return '2' simply because the first doc available is '3', then we may incorrectly collect '2'.\n\nActually, I'm not liking that particular added code anyway ;)\n\nIe the contract of that method (I believe) is that nextDoc must already have been called.  I don't like adding ambiguity into the API, and so instead of the check I'd rather switch it to an \"assert docID != -1\", ie, assert that nextDoc was in fact called.  And then if that assert trips up, we need to go understand the root cause for that.\n\nbq. So I say we relax the policy in this way: \"an implementation can return -1 if it knows the iterator is not exhausted, or NO_MORE_DOCS otherwise\".\n\nOK, let's do that.  Though: it need not return NO_MORE_DOCS up front, right?  Ie, if it is able to determine up front it has no docs to iterate, great, else, it can return -1 until nextDoc() is called at which point it returns NO_MORE_DOCS?",
            "date": "2009-05-29T08:42:57.066+0000",
            "id": 105
        },
        {
            "author": "Shai Erera",
            "body": "I don't like that code also. But if we allow to return any value, except -1 or NO_MORE_DOCS before the iteration started, someone will have very hard time trying to write such code (to determine if the iterator has started).\n\nThe current contract already specifies what this method should return when nextDoc or advance were not called. We just need to make it more explicit:\n* Return -1 if the iteration did not start, and there are documents to return\n* Return NO_MORE_DOCS if there are no more docs to return (whether the iteration started or not).\n* Return the doc ID on any other case..\n\nNote that I also wrote that this method should not throw any exception, but I think of relaxing that either, and say \"it is better if the implementation does not throw any exception in case there are no more documents to return\". The reason is, we cannot force \"don't throw exception\" in the code ... What do you think?\n\nI will update the patch if you agree to these changes.",
            "date": "2009-05-29T10:48:39.403+0000",
            "id": 106
        },
        {
            "author": "Michael McCandless",
            "body": "Let's decouple the two things we are talking about...\n\nFirst off, Scorer.score(Collector, int) (and also BooleanScorer2)\nrequire that nextDoc has already been called.  So we should not add\nthe \"if\" into those methods; if anything, we should do the opposite\n(add an assert).\n\nSecond, the semantics of calling docID() before nextDoc/advance have\nbeen called... on this I think your proposal is good, except: in the\nevent that the Scorer will not match any docs, it's also fine if it\nreturns -1.  Ie we do not require all Scorers to up-front determine\nwhether they will match docs or not.  Said another way, if a Scorer\nwill not match any docs, docID() may return either -1 or NO_MORE_DOCS\nbefore nextDoc/advance have been called.\n\nbq. Note that I also wrote that this method should not throw any exception, but I think of relaxing that either, and say \"it is better if the implementation does not throw any exception in case there are no more documents to return\". The reason is, we cannot force \"don't throw exception\" in the code ... What do you think?\n\nI don't think we need to allow for docID() to throw an exception?\n(doc() doesn't today and I haven't heard complaints, I think).\n\nIf there are no more documents to return, docID() should return\nNO_MORE_DOCS.\n",
            "date": "2009-05-29T14:14:29.271+0000",
            "id": 107
        },
        {
            "author": "Shai Erera",
            "body": "bq. First off, Scorer.score(Collector, int) (and also BooleanScorer2) require that nextDoc has already been called. \n\nAgreed. I'll take a look at the code and check if that's possible. I thought to do it, but since Scorer is public, and score(Collector, int) is protected, I didn't feel that making this assumption is a good thing and might break back-compat (i.e., if someone overrode Scorer and call this method w/o calling nextDoc() first).\n\nI'll change the semantics as you propose, saying that an impl is free to return -1 or NO_MORE_DOCS in case it knows up front there are no more docs, before nextDoc or advance were called.\n\nRegarding the exceptions, I meant runtime exceptions. The method does not declare to throw anything. But I've seen cases, like ReqExclScorer where NPE may be thrown, or AIOOBE. That's what I would like to document - that impl should try to avoid it. Since I don't have a way in Java to restrict that, I'd like that to appear in the javadocs.",
            "date": "2009-05-29T14:32:45.518+0000",
            "id": 108
        },
        {
            "author": "Michael McCandless",
            "body": "bq. Agreed. I'll take a look at the code and check if that's possible. I thought to do it, but since Scorer is public, and score(Collector, int) is protected, I didn't feel that making this assumption is a good thing and might break back-compat (i.e., if someone overrode Scorer and call this method w/o calling nextDoc() first).\n\nWell the javadoc clearly states the requirement (\"next must be called\").  And if external Scorers are violating this, it'll cause problems if their used as sub-scorers by BooleanScorer.\n\nbq.  But I've seen cases, like ReqExclScorer where NPE may be thrown, or AIOOBE. That's what I would like to document - that impl should try to avoid it. Since I don't have a way in Java to restrict that, I'd like that to appear in the javadocs.\n\nUnder what cases are NPE & AIOOBE thrown by ReqExclScorer?  (That doesn't seem right).\n\nI don't think we need to document that you shouldn't throw RuntimeExceptions -- that's pretty much par for the course, right?  Or maybe I'm missing something... does something go horribly wrong in particular if an exception is thrown by docID()?",
            "date": "2009-05-29T16:32:35.230+0000",
            "id": 109
        },
        {
            "author": "Shai Erera",
            "body": "bq. Under what cases are NPE & AIOOBE thrown by ReqExclScorer?\n\nPreviously, ReqExclScorer had this code:\n\n{code}\npublic int doc() {\n  return reqScorer.doc(); // reqScorer may be null when next() or skipTo() already return false\n}\n{code}\n\nThe current patch already fixes it to not rely on reqScorer to be or not be null (we've also discussed this issue somewhere up this thread).\n\nbq. I don't think we need to document that you shouldn't throw RuntimeExceptions\n\nYeah ... I guess you're right. When I read the documentation it does sound kind of silly (as if we're begging \"please don't throw RuntimeException\"). I'll remove that. I just wanted to encourage implementers to not rely on an object which may or may not be null (or index going out of range).\n\nbq. Well the javadoc clearly states the requirement (\"next must be called\")\n\nYou're right Mike, I didn't read the javadocs (shame on me :) ). I'll fix the code then.",
            "date": "2009-05-29T19:52:15.434+0000",
            "id": 110
        },
        {
            "author": "Shai Erera",
            "body": "DISI.docID documentation (and CHANGES) changed. Also the code in Scorer and BS2 score(Collector, int) does not check for -1.",
            "date": "2009-05-29T20:45:59.647+0000",
            "id": 111
        },
        {
            "author": "Shai Erera",
            "body": "I was wondering if instead of adding an assert to score(Collector, int) on the doc ID not being -1, we create another method score(Collector, int, int /* firstDocID */) and deprecate the current one.\nIt will behave exactly as score(Collector, int), only I think it makes it more explicit that we require nextDoc() to be called before. The documentation can state that the method expects the first doc ID and not a negative number.\n\nBesides, the code today does: (1) nextDoc() and (2) score(Collector, int) which then calls docID(). If we allow to pass the first doc ID, we can use the value that's returned from nextDoc() (e.g., score(Collector, int, nextDoc())).\n\nWhat do you think?",
            "date": "2009-05-30T20:24:08.802+0000",
            "id": 112
        },
        {
            "author": "Michael McCandless",
            "body": "bq. we create another method score(Collector, int, int /* firstDocID */) and deprecate the current one.\n\nI think that makes sense!",
            "date": "2009-05-31T10:33:37.881+0000",
            "id": 113
        },
        {
            "author": "Michael McCandless",
            "body": "It seems like we lost this at some point (I couldn't find it in the latest patch)?\n\n{quote}\n> Can you add an \"assert scorer.docID() == -1\" in IndexSearcher right when it gets the scorer?\n\nDone.\n{quote}\n\nWhen I add {{assert scorer.docID() == -1 || scorer.docID() == Scorer.NO_MORE_DOCS;}}  in doSearch, after we get the scorer, all tests pass.  Was there something that went wrong when you added it?",
            "date": "2009-05-31T11:08:47.455+0000",
            "id": 114
        },
        {
            "author": "Shai Erera",
            "body": "Ok I'll add this method.\n\nRegarding that assert, you wrote the following somewhere up this thread:\n\n{quote}\n    > Can you add an \"assert scorer.docID() == -1\" in IndexSearcher right when it gets the scorer?\n\n    Done.\n\nOK, except we may delete it depending on the relaxing (below)...\n{quote}\n\nSo I removed it :). Anyway I'll add it back.",
            "date": "2009-05-31T11:28:48.983+0000",
            "id": 115
        },
        {
            "author": "Michael McCandless",
            "body": "bq. So I removed it . Anyway I'll add it back.\n\nAhh, OK :)  But we didn't end up relaxing the semantics, ie we are back to \"docID() must return -1 or NO_MORE_DOCS before nextDoc/advance have been called\"... so let's just add it back.",
            "date": "2009-05-31T11:38:51.712+0000",
            "id": 116
        },
        {
            "author": "Shai Erera",
            "body": "Added Scorer.score(Collector, int, int) and deprecated the other one, with an impl:\n{code}\nreturn score(collector, int, docID());\n{code}\n\nI also added the assert to IndexSearcher.doSearch.\n\nDo you think we should add 'assert firstDocID >= 0' to the new score(Collector, int, int) implementations? It seems redundant to me ... ",
            "date": "2009-05-31T12:24:01.105+0000",
            "id": 117
        },
        {
            "author": "Michael McCandless",
            "body": "bq. Do you think we should add 'assert firstDocID >= 0' to the new score(Collector, int, int) implementations? It seems redundant to me ...\n\nAgreed, I think it's redundant.  Let's skip it.",
            "date": "2009-05-31T16:40:50.318+0000",
            "id": 118
        },
        {
            "author": "Shai Erera",
            "body": "Ok then I guess we're ready for the final (hopefully :)) iteration.",
            "date": "2009-05-31T16:54:09.057+0000",
            "id": 119
        },
        {
            "author": "Michael McCandless",
            "body": "Yes... I'm reviewing & I'll post any changes...",
            "date": "2009-05-31T17:40:08.082+0000",
            "id": 120
        },
        {
            "author": "Michael McCandless",
            "body": "OK I think we're getting close... I attached patch w/ these\nchanges/questions:\n\n  * I think we should require that nextDoc/advance not be called again\n    once NO_MORE_DOCS has already been returned?  This would save\n    checks, eg in ConjunctionScorer & DisjunctionMaxScorer &\n    ReqExclScorer at least, for \"did I already return NO_MORE_DOCS\" on\n    every nextDoc call.  Some things already seem to require this (eg\n    DocIdBitSet's DISI).\n\n  * I think the new code for applying a filter during searching (~line\n    282 of IndexSearcher) can be made more efficient in the \"if\n    (scorerDoc == filterDoc)\" case.  Inside there, we ask\n    filterDocIter to do nextDoc(), at which point we know scorerDoc is\n    < filterDoc, and so it'd be better to call scorer.advance, there,\n    instead of wrapping around the loop and having to do the if at the\n    top?\n\n  * Fixed bug in how \"more\" is computed in BooleanScorer (we were\n    directly assigning to more instead of or'ing in the new value)\n\n  * Various cosmetic changes -- removed unused vars, imports; made\n    some attrs final.\n\n  * [As a separate issue, it seems like NonMatchingScorer should be\n    removed, and we should fix BooleanQuery.scorer to instead return\n    null in such cases]\n",
            "date": "2009-06-01T11:16:12.519+0000",
            "id": 121
        },
        {
            "author": "Shai Erera",
            "body": "bq. I think we should require that nextDoc/advance not be called again once NO_MORE_DOCS has already been returned?\n\nSo you mean add something like this to the javadocs \"after NO_MORE_DOCS was returned, you should not call this method again, or it may result in unpredicted behavior\"?\n\nbq. Some things already seem to require this (eg DocIdBitSet's DISI).\n\nYou mean that this will remove the d == -1 check?\n\nbq. I think the new code for applying a filter during searching (~line 282 of IndexSearcher) ...\n\nSo you mean to change the last line here:\n\n{code}\nif (scorerDoc == filterDoc) { // permitted by filter\n        collector.collect(scorerDoc);\n        if ((filterDoc = filterDocIdIterator.nextDoc()) == DocIdSetIterator.NO_MORE_DOCS) break;\n{code}\n\nto\n\n{code}\nif ((filterDoc = filterDocIdIterator.nextDoc()) == DocIdSetIterator.NO_MORE_DOCS) {\n  break;\n} else if ((scorerDoc = scorer.advance(filterDoc)) == DocIdSetIterator.NO_MORE_DOCS) {\n  break;\n}\n{code}\n\nI don't see what it will give us since after the loop wraps around, we check anyway if filterDoc > scoreDoc.\n\nBut .. I think the while loop can be changed to:\n\n{code}\nint filterDoc = filterDocIdIterator.nextDoc();\nint scorerDoc = scorer.advance(filterDoc);\nif (filterDoc == DocIdSetIterator.NO_MORE_DOCS\n    || scorerDoc == DocIdSetIterator.NO_MORE_DOCS) {\n  return;\n}\n\ncollector.setScorer(scorer);\nwhile (true) {\n  // scorerDoc >= filterDoc\n  if (scorerDoc == filterDoc) { // permitted by filter\n    collector.collect(scorerDoc);\n    if ((filterDoc = filterDocIdIterator.nextDoc()) == DocIdSetIterator.NO_MORE_DOCS) break;\n  } else if ((filterDoc = filterDocIdIterator.advance(scorerDoc)) == DocIdSetIterator.NO_MORE_DOCS) break;\n\n  // The above code may have moved filterDoc beyond scorerDoc, so advance scorerDoc\n  if ((scorerDoc = scorer.advance(filterDoc)) == DocIdSetIterator.NO_MORE_DOCS) break;\n}\n{code}\n\nWhat do you think?\n\nAlso Mike - the patch you posted is 152KB, while my last patch is 201KB. It's hard to compare our patches since the order of the classes is different, so until I apply the patch and check it, I wanted to make sure you included all the changes in the patch. (comparing our previous 2 patches from May 27 - they were of same size, so the last one is a bit fishy).",
            "date": "2009-06-01T11:58:33.532+0000",
            "id": 122
        },
        {
            "author": "Michael McCandless",
            "body": "bq. So you mean add something like this to the javadocs \"after NO_MORE_DOCS was returned, you should not call this method again, or it may result in unpredicted behavior\"?\n\nRight.  And, optimizing the core Scorers based on this (ie, to stop\nchecking if they had already returned NO_MORE_DOCS, in\nnextDoc/advance).\n\nbq. You mean that this will remove the d == -1 check?\n\nNo, I think that check must remain, even once we switch to the new\nsemantics.  What I meant was, currently, if I call nextDoc() on\nDocIdBitSet's DISI after nextDoc had already returned NO_MORE_DOCS, it\nlooks like I'll get into trouble because that will then call\nBitSet.nextSetBit(NO_MORE_DOCS+1), ie,\nBitSet.nextSetBit(Integer.MIN_VALUE), which'll throw an exception.\nIe, this DISI already requires that you don't call nextDoc() again\nafter it's returned NO_MORE_DOCS.\n\nbq. So you mean to change the last line here:\n\nActually, I meant in the case where filterDoc == scorerDoc, you ought\nto advance both filter & scorer, not just filter (you know at that\npoint that both must advance).\n\nI think the new while loop is buggy: if scorerDoc is not == filterDoc,\nand you ask filterDocIdIter to advance to scorerDoc, it may advance to\nbecome ==, yet you then illegally advance scorerDoc to filterDoc?\n\nbq. Also Mike - the patch you posted is 152KB, while my last patch is 201KB. It's hard to compare our patches since the order of the classes is different, so until I apply the patch and check it, I wanted to make sure you included all the changes in the patch. \n\nI'm pretty sure this is OK: it's because I changed the eol-style to\nnative (in my local checkout), which then caused \"svn diff\" to produce\nmore reasonable diffs.  In your patch, there are several files where\nthe entire file is deleted, and then the entire new file is added,\nbecause the eol-style wasn't set.  If you \"grep Index: patch.txt | wc\"\nof yours & mine, they should the same.\n",
            "date": "2009-06-01T12:19:52.568+0000",
            "id": 123
        },
        {
            "author": "Shai Erera",
            "body": "bq. I think the new while loop is buggy:\n\nYou're right. But then, I don't see the benefit of adding that advance() call, since in the while loop you'd still need to check whether filterDoc > scorerDoc. So why do it? Is it just a matter of 'not relying on the above instruction, since at that point I know both should be advanced'?\n\nbq. I changed the eol-style to native\n\nCan you explain me what that means? Maybe I should also change it in my eclipse?",
            "date": "2009-06-01T13:20:12.483+0000",
            "id": 124
        },
        {
            "author": "Shai Erera",
            "body": "Actually, Mike, removing those check from ConjunctionScorer is a bit problematic. After I changed CS to initialize in the ctor, it may realize one of the Scorers does not have any more documents, and so set lastDoc to be NO_MORE_DOCS.\nThen, nextDoc() is called by BS2.score(Collector), which yields down the stack to TermScorer attempting to score Integer.MAX_VALUE and AIOOBE is thrown, or for some other query to ReqExclScorer to throw NPE.\n\nSo I think the solution is to make sure Scorers which do not have a nextDoc() should not be passed to CS in the first place. And remove this check from CS ctor.",
            "date": "2009-06-01T14:06:20.251+0000",
            "id": 125
        },
        {
            "author": "Shai Erera",
            "body": "bq. So I think the solution is to make sure Scorers which do not have a nextDoc() should not be passed to CS in the first place. And remove this check from CS ctor.\n\nI'm afraid that's impossible too, since CS advances all Scorers in its ctor to the first agreed-upon doc ID, which may result in NO_MORE_DOCS right upfront.\n\nWhat if we document that you shouldn't call nextDoc() after it return NO_MORE_DOCS for now, and then maybe we do proceed (in another issue) with the DISI.start() method. Then CS can implement start() and return false if there are no more docs?\n\nI also tried changing BS2.score(Collector) to first check the docID of countingSumScorer, but that is not good either, since a Scorer is allowed to return -1 or NO_MORE_DOCS before nextDoc() was called ...\n\nWhat do you think?",
            "date": "2009-06-01T14:54:12.542+0000",
            "id": 126
        },
        {
            "author": "Michael McCandless",
            "body": "\nbq. But then, I don't see the benefit of adding that advance() call, since in the while loop you'd still need to check whether filterDoc > scorerDoc. So why do it? Is it just a matter of 'not relying on the above instruction, since at that point I know both should be advanced'?\n\nSince you know both should be advanced, why loop back and do an\nunecessary if check?  Ie, I the CPU will do more work (computing a\nredundant if) if we don't advance both.\n\nHowever, my solution (also advancing the scorer) is still not right,\nbecause on cycling back you know scorerDoc >= filterDoc, so we've also\nwasted an if check there... hmmm.\n\nSo actually let's just stick w/ your current approach, since it's a\nstraight conversion of what trunk currently does, except can we stop\nchecking NO_MORE_DOCS on each advance/nextDoc, and only check it when\nwe're about to collect a doc?\n\nAnd, anyway, maybe we shouldn't fret so much about it; we know this\nfilter loop needs to change for 2.9 anyway.  I think we want something\nlike this:\n\n  * If filter is random access, it should be pushed all the way down\n    and applied just like deleted docs\n\n  * If filter is \"relatively\" sparse compared to query, then we should\n    to use the (to-be-added) DISI.check() method\n\n  * Else, add filter as clause on BQ.  If incoming Query is already a\n    BQ, clone that and tack filter on as clause; else, make a BQ and\n    add both.\n\nbq. Can you explain me what that means? Maybe I should also change it in my eclipse?\n\nWe're supposed to do this (tell svn to use native EOL -- \"svn propset\nsvn:eol-style native\") for all our sources, to avoid issues like\nthis.\n\nbq. What if we document that you shouldn't call nextDoc() after it return NO_MORE_DOCS for now\n\nOK, let's do that.  We can leave \"taking advantage of this\" (start\nmethod) to another issue.  But let's be crystal clear on the semantics\nof DISI for this issue.\n",
            "date": "2009-06-01T15:20:05.266+0000",
            "id": 127
        },
        {
            "author": "Shai Erera",
            "body": "bq. But let's be crystal clear on the semantics of DISI for this issue.\n\nI'll change the Javadocs. Actually nextDoc() was already documented that way, I'll add it to advance also.\n\nbq. Since you know both should be advanced, why loop back and do an unecessary if check?\n\nYou do the 'if' check anyway because of scorer.advance() before the loop starts. If we remove scorer.advance() before the loop starts, we can remove the 'if' check also.\nAnyway, I'll try to optimize that code segment.",
            "date": "2009-06-01T15:39:09.034+0000",
            "id": 128
        },
        {
            "author": "Shai Erera",
            "body": "Changed IndexSearcher.doSearch a bit. I think it's more efficient now, since it does not check for filterDoc > scorerDoc at the beginning of the iteration, but rather is handled at the 'else' part. (since when we enter the loop scorerDoc >= filterDoc, that check should not have happened right at the beginning).\n\nI also changed DISI's nextDoc and advance javadocs, to advise against calling them after the iterator has exhausted.",
            "date": "2009-06-01T20:12:38.968+0000",
            "id": 129
        },
        {
            "author": "Michael McCandless",
            "body": "Patch looks good!  I plan to commit in a day or two...",
            "date": "2009-06-01T21:43:25.881+0000",
            "id": 130
        },
        {
            "author": "Uwe Schindler",
            "body": "Quickly looking over the code:\n\nJavadocs for DocIdSetIterator still sometimes contain -1 instead of NO_MORE_DOCS\n\n{code}\n+    Scorer.score(Collector, int) was deprecated in favor of \n+    Scorer.score(Collector, int, int) which take an extra 'firstDocID' \n+    parameter. This is meant to ensure nextDoc() is called before this method.\n{code}\nCollector is a new class in 2.9, so no need to deprecate (in the code it seems correct).\n\nWill look into it more detailed tomorrow.",
            "date": "2009-06-01T22:04:08.340+0000",
            "id": 131
        },
        {
            "author": "Shai Erera",
            "body": "Updated to 20090601a tag.\nI also removed the comment on Scorer from CHANGES. Thanks Uwe - this deprecation stuff really got over me :). I deleted the method from Scorer as well.\n\nUwe, regarding the -1 in DISI - -1 is a valid value for docID() in case nextDoc/advance were not called yet. That's why you see it in the javadocs. I did however fix advance's sample code in the javadocs to return NO_MORE_DOCS instead of -1. If that's what you meant, then thanks for spotting that.\n",
            "date": "2009-06-02T07:01:57.256+0000",
            "id": 132
        },
        {
            "author": "Uwe Schindler",
            "body": "bq. Uwe, regarding the -1 in DISI - -1 is a valid value for docID() in case nextDoc/advance were not called yet. That's why you see it in the javadocs. I did however fix advance's sample code in the javadocs to return NO_MORE_DOCS instead of -1. If that's what you meant, then thanks for spotting that.\n\nI meant the sample code that explains how it is internally implemented for backwards compatibility (if not overwritten). So you fixed the right one, I think.\n\nThere is one other thing with the deprecation: When we deprectated the Filters getBits() method we un-abstracted this method and added the new one with the note, that it will be made abstract and the old bits() removed.\n\nYou kept the old methods skipTo() and next() abstract, but deprecated. One must now always implement next() and skipTo() but gets a deprecated warning because of that. So I would do it in the same way like bits() for filters. Un-abstract it and implement it with throwing an UnsupportedOperationException(). The new advance() and others are calling this method (as it is now). If somebody overwrites this abstract class, he can leave out the deprecated one, will get no warning. As the method is not called anymore by Lucene he will never see a UOE. In 3.0 it can easily removed without problems for any users.",
            "date": "2009-06-02T07:42:08.196+0000",
            "id": 133
        },
        {
            "author": "Shai Erera",
            "body": "Thanks Uwe - that's a good idea. I've implemented all 3 to throw UOE as well as document that in their javadocs. I kept nextDoc() as is, i.e., calling doc() instead of docID(), since that's required for back-compat. Since all DISIs should have their doc() implemented, that shouldn't be a problem.",
            "date": "2009-06-02T08:46:55.779+0000",
            "id": 134
        },
        {
            "author": "Uwe Schindler",
            "body": "bq. I kept nextDoc() as is, i.e., calling doc() instead of docID(), since that's required for back-compat.\n\nBut doc() is also deprecated, why should they have implemented it? This makes no sense for me. Non-deprecated-code should always call non-deprectaed methods, so docID().\n\nEDIT: Ah sorry, you are right. new iterators would override this method and not call doc() and next().\n\nbq.  Since all DISIs should have their doc() implemented, that shouldn't be a problem.\nThis should be \"Since all DISIs should have their docID() implemented, that shouldn't be a problem.\", then it makes sense to me.",
            "date": "2009-06-02T08:53:08.344+0000",
            "id": 135
        },
        {
            "author": "Shai Erera",
            "body": "This is all to support jar drop-in ability. So say you wrote your own DISI with doc(), next() and skipTo() and now pass it to 2.9. The code in 2.9 will call nextDoc(), but you have implemented docID(), just doc(). Therefore nextDoc() cannot call docID(), same as it calls next() which is also deprecated.\n\nWe cannot implement docID() by calling doc() either, since docID() defines new semantics, which existing doc() implementations may not adhere to.\n\nOf course, if someone chooses to change his/her code, he/she should override all 3 and provide his/her own implementation, especially since all 3 of them will become abstract in 3.0.\n\nI actually meant to say \"Since all DISIs should have their *doc()* implemented ...\" - that's the jar drop-in ability side of the story. Not all DISIs will have their docID() implemented. In fact none of them will, unless someone upgrades his code.\n\nRight?",
            "date": "2009-06-02T09:00:50.028+0000",
            "id": 136
        },
        {
            "author": "Uwe Schindler",
            "body": "Yes! Sorry for the false alarm, I did not think to the end.\n\nFor completely new impls of DISI, one can leave the deprecated methods as they are and is also fine (and will get no deprecations), because current code will not call the old methods anymore. If he would drop this new class into an old Lucene it will throw UOE, but this is not what he should do.",
            "date": "2009-06-02T09:08:26.431+0000",
            "id": 137
        },
        {
            "author": "Michael McCandless",
            "body": "Latest patch looks good.  I plan to commit in a day or two.  Phew!  Thank Shai.",
            "date": "2009-06-03T18:11:03.940+0000",
            "id": 138
        },
        {
            "author": "Michael McCandless",
            "body": "Thanks Shai!",
            "date": "2009-06-07T16:59:16.805+0000",
            "id": 139
        },
        {
            "author": "Uwe Schindler",
            "body": "As Yonik noted on java-user, the backwards pattern is wrongly implemented for DocIdSetIterator.advance(). It should simply call skipTo, so that iterators only implementing skipTo() work correct when updated to Lucene 2.9.\n\nThe method advance should look similar to nextDoc(), only next() replaced by skipTo()\n\nUwe",
            "date": "2009-07-15T19:41:32.306+0000",
            "id": 140
        },
        {
            "author": "Uwe Schindler",
            "body": "This patch fixes this. All tests, especially test-tag pass.",
            "date": "2009-07-15T19:45:32.657+0000",
            "id": 141
        },
        {
            "author": "Uwe Schindler",
            "body": "Here is a second possibility, maybe better. The javadocs of advance note, that it may be called with NO_MORE_DOCS as parameter. skipTo may not be able to handle this. So I added an extra check to the BW-compatiility method. Is this better, or is the first patch ok?\n\nI see no difference. Maybe yonik could try this out with Solr?",
            "date": "2009-07-15T20:06:59.119+0000",
            "id": 142
        },
        {
            "author": "Michael McCandless",
            "body": "Whoa I agree: advance should fallback to skipTo.  What a doozie.  Crazy we didn't catch this the first time around.\n\nI think the 2nd patch is safest.  There may be DISIs out there for which skipTo(Integer.MAX_VALUE) is costly and/or throws an errant exception.  I'll commit soon.",
            "date": "2009-07-15T20:15:01.813+0000",
            "id": 143
        }
    ],
    "component": "core/search",
    "description": "See http://www.nabble.com/Another-possible-optimization---now-in-DocIdSetIterator-p23223319.html for the full discussion. The basic idea is to add variants to those two methods that return the current doc they are at, to save successive calls to doc(). If there are no more docs, return -1. A summary of what was discussed so far:\n# Deprecate those two methods.\n# Add nextDoc() and skipToDoc(int) that return doc, with default impl in DISI (calls next() and skipTo() respectively, and will be changed to abstract in 3.0).\n#* I actually would like to propose an alternative to the names: advance() and advance(int) - the first advances by one, the second advances to target.\n# Wherever these are used, do something like '(doc = advance()) >= 0' instead of comparing to -1 for improved performance.\n\nI will post a patch shortly",
    "hasPatch": true,
    "hasScreenshot": false,
    "id": "LUCENE-1614",
    "issuetypeClassified": "RFE",
    "issuetypeTracker": "IMPROVEMENT",
    "priority": "Major",
    "product": "LUCENE",
    "project": "LUCENE",
    "summary": "Add next() and skipTo() variants to DocIdSetIterator that return the current doc, instead of boolean",
    "systemSpecification": true,
    "version": ""
}