{
    "comments": [
        {
            "author": "Chandan Raj Rupakheti",
            "body": "Updated the advantage of the proposed solution to make it more clear.",
            "date": "2008-02-25T14:26:01.905+0000",
            "id": 0
        },
        {
            "author": "Uwe Schindler",
            "body": "The equals and hashCode implementations in Query subclasses were already fixed to use getClass() and not instanceof in 2.9 by various other issues. Also the boost comparison was mostly removed by calling super.",
            "date": "2011-01-25T16:31:41.040+0000",
            "id": 1
        }
    ],
    "component": "core/search",
    "description": "I would like to talk about the implementation of equals and hashCode method  in org.apache.lucene.search.* package. \n\nExample One:\n\norg.apache.lucene.search.spans.SpanTermQuery (Super Class)\n\t<- org.apache.lucene.search.payloads.BoostingTermQuery (Sub Class)\n\nObservation:\n\n* BoostingTermQuery defines equals but inherits hashCode from SpanTermQuery. Definition of equals is a code clone of SpanTermQuery with a change in class name. \n\nIntention:\n\nI believe the intention of equals redefinition in BoostingTermQuery is not to make the objects of SpanTermQuery and BoostingTermQuery comparable. ie. spanTermQuery.equals(boostingTermQuery) == false && boostingTermQuery.equals(spanTermQuery) == false.\n\n\nProblem:\n\nWith current implementation, the intention might not be respected as a result of symmetric property violation of equals contract i.e.\nspanTermQuery.equals(boostingTermQuery) == true (can be) && boostingTermQuery.equals(spanTermQuery) == false. (always)\n(Note: Provided their state variables are equal)\n\nSolution:\n\nChange implementation of equals in SpanTermQuery from:\n\n{code:title=SpanTermQuery.java|borderStyle=solid}\n  public boolean equals(Object o) {\n    if (!(o instanceof SpanTermQuery))\n      return false;\n    SpanTermQuery other = (SpanTermQuery)o;\n    return (this.getBoost() == other.getBoost())\n      && this.term.equals(other.term);\n  }\n{code}\n\nTo:\n{code:title=SpanTermQuery.java|borderStyle=solid}\n  public boolean equals(Object o) {\n  \tif(o == this) return true;\n  \tif(o == null || o.getClass() != this.getClass()) return false;\n//    if (!(o instanceof SpanTermQuery))\n//      return false;\n    SpanTermQuery other = (SpanTermQuery)o;\n    return (this.getBoost() == other.getBoost())\n      && this.term.equals(other.term);\n  }\n{code}\n\nAdvantage:\n\n* BoostingTermQuery.equals and BoostingTermQuery.hashCode is not needed while still preserving the same intention as before.\n \n* Any further subclassing that does not add new state variables in the extended classes of SpanTermQuery, does not have to redefine equals and hashCode. \n\n* Even if a new state variable is added in a subclass, the symmetric property of equals contract will still be respected irrespective of implementation (i.e. instanceof / getClass) of equals and hashCode in the subclasses.\n\n\nExample Two:\n\n\norg.apache.lucene.search.CachingWrapperFilter (Super Class)\n\t<- org.apache.lucene.search.CachingWrapperFilterHelper (Sub Class)\n\nObservation:\nSame as Example One.\n\nProblem:\nSame as Example one.\n\nSolution:\nChange equals in CachingWrapperFilter from:\n{code:title=CachingWrapperFilter.java|borderStyle=solid}\n  public boolean equals(Object o) {\n    if (!(o instanceof CachingWrapperFilter)) return false;\n    return this.filter.equals(((CachingWrapperFilter)o).filter);\n  }\n{code}\n\nTo:\n{code:title=CachingWrapperFilter.java|borderStyle=solid}\n  public boolean equals(Object o) {\n//    if (!(o instanceof CachingWrapperFilter)) return false;\n    if(o == this) return true;\n    if(o == null || o.getClass() != this.getClass()) return false;\n    return this.filter.equals(((CachingWrapperFilter)o).filter);\n  }\n{code}\n\nAdvantage:\nSame as Example One. Here, CachingWrapperFilterHelper.equals and CachingWrapperFilterHelper.hashCode is not needed.\n\n\nExample Three:\n\norg.apache.lucene.search.MultiTermQuery (Abstract Parent)\n\t<- org.apache.lucene.search.FuzzyQuery (Concrete Sub)\n\t<- org.apache.lucene.search.WildcardQuery (Concrete Sub)\n\nObservation (Not a problem):\n\n* WildcardQuery defines equals but inherits hashCode from MultiTermQuery.\nDefinition of equals contains just super.equals invocation. \n\n* FuzzyQuery has few state variables added that are referenced in its equals and hashCode.\nIntention:\n\nI believe the intention here is not to make objects of FuzzyQuery and WildcardQuery comparable. ie. fuzzyQuery.equals(wildCardQuery) == false && wildCardQuery.equals(fuzzyQuery) == false.\n\nProposed Implementation:\nHow about changing the implementation of equals in MultiTermQuery from:\n\n{code:title=MultiTermQuery.java|borderStyle=solid}\n    public boolean equals(Object o) {\n      if (this == o) return true;\n      if (!(o instanceof MultiTermQuery)) return false;\n\n      final MultiTermQuery multiTermQuery = (MultiTermQuery) o;\n\n      if (!term.equals(multiTermQuery.term)) return false;\n\n      return getBoost() == multiTermQuery.getBoost();\n    }\n{code}\n\nTo:\n{code:title=MultiTermQuery.java|borderStyle=solid}\n    public boolean equals(Object o) {\n      if (this == o) return true;\n//      if (!(o instanceof MultiTermQuery)) return false;\n      if(o == null || o.getClass() != this.getClass()) return false;\n\n      final MultiTermQuery multiTermQuery = (MultiTermQuery) o;\n\n      if (!term.equals(multiTermQuery.term)) return false;\n\n      return getBoost() == multiTermQuery.getBoost();\n    }\n{code}\n\nAdvantage:\n\nSame as above. Here, WildcardQuery.equals is not needed as it does not define any new state. (FuzzyQuery.equals is still needed because FuzzyQuery defines new state.) \n",
    "hasPatch": false,
    "hasScreenshot": false,
    "id": "LUCENE-1188",
    "issuetypeClassified": "IMPROVEMENT",
    "issuetypeTracker": "IMPROVEMENT",
    "priority": "Major",
    "product": "LUCENE",
    "project": "LUCENE",
    "summary": "equals and hashCode implementation in org.apache.lucene.search.* package",
    "systemSpecification": false,
    "version": "2.2, 2.3, 2.3.1"
}