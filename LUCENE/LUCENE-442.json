{
    "comments": [
        {
            "author": "Daniel Naber",
            "body": "Hoss,\n\nhow exactly did the test fail, what was the real number and what was the expected number?\n\nI must admit I don't understand your scenario. The test happens only at the end, on an optimized index. We start two threads on an empty index. Both threads randomly add and delete documents and remember the number of documents added and deleted. At the end, when both threads are finished, the index should contain this many documents:\n\n# added by thread 1 + # added by thread 2 - # deleted by thread 1 - # deleted by thread 2\n\nThis is how I understand it. Maybe you could rephrase your scenario?\n\nRegards\n Daniel\n",
            "date": "2005-10-24T07:10:44.000+0000",
            "id": 0
        },
        {
            "author": "Daniel Naber",
            "body": "Okay, I see now that there are problems with the test. I will try to fix them, maybe that way it becomes clear (to me) if that test case makes sense at all.\n",
            "date": "2005-10-24T07:40:01.000+0000",
            "id": 1
        },
        {
            "author": "Yonik Seeley",
            "body": "I see a few issues:\n\n1) A constant seed is used for reproducability:\n  private Random random = new Random(101);\t\t// constant seed for reproducability\nBut, it won't have that effect since the same random number generator is used across threads.\n\n2) race condition between checking idStack.size() and calling pop()\n\n3) non-atomic increment of the document id could lead to duplicates\n\nIMO, the ideal multithreaded test would be designed to not use any synchronization at all, making it easier to test if IndexModifier actually does all the synchronization it needs to.",
            "date": "2005-10-24T11:46:28.000+0000",
            "id": 2
        },
        {
            "author": "Daniel Naber",
            "body": "I just committed some updates, could you please check whether it's okay now?",
            "date": "2005-10-25T05:56:49.000+0000",
            "id": 3
        },
        {
            "author": "Hoss Man",
            "body": "Daniel: I used the following script to run through 50 iterations of the test...\n\n#!/bin/sh\nfor ((i=0; i < 50; i++)); do {\n  ant test -Dtestcase=TestIndexModifier;\n  mv build/test/TEST-org.apache.lucene.index.TestIndexModifier.xml build/test/TEST-org.apache.lucene.index.TestIndexModifier.xml.$i;\n};\ndone\ngrep -l \"failure message\" build/test/TEST-org.apache.lucene.index.TestIndexModifier.xml.*\n\n...prior to upgrading to the changes you made, 30 of the 50 test runs failed (with the values being off by one or two in each case).  After upgrading to TestIndexModifier.java v328151, 0 of the 50 runs failed.  \n\nIt's not a proof of correctness, but it certainly bodes well.\n\nI also want to clarify the scenerio I described earlier: I'm an idiot.  I completely missed that each call to testIndexInternal(int) blocks waiting for the threads to finish -- for some reason I thought all three calls were happening concurrently.  So the types of scenerios I was initially thinking could cause problems were completely non-existent -- and it looks like you fixed all the ones Yonik noticed.\n\n(I do think Yonik has a good point however regarding a test with no synchronization at all -- this should be possible if each instant of IndexThread maintaining it's own id and idStack variables, using  'threadNumber + \"-\" id++' to generate new doc identifiers, and only ever deleted documents it added).",
            "date": "2005-10-26T10:56:15.000+0000",
            "id": 4
        },
        {
            "author": "Yonik Seeley",
            "body": "Yep, it looks good.  I'd go ahead and close this issue (if I knew how...)\n\nThe multithreaded tests w/o any synchronization is just a good general guideline.  I briefly browsed the TestIndexModifier, and there shouldn't be any issues in that regard since  the synchronization is trivial (all public methods synchronized on the same object)",
            "date": "2005-10-27T01:30:02.000+0000",
            "id": 5
        },
        {
            "author": "Daniel Naber",
            "body": "Yonik, thanks for your review. I'm closing this issue now. You'll need to ask Erik to give you committer's permissions in Jira, then you'll be able to close issues with the \"Workflow actions\" on the left.\n",
            "date": "2005-10-27T02:21:09.000+0000",
            "id": 6
        }
    ],
    "component": "core/search",
    "description": "I recently started playing with the trunk of SVN, and noticed that intermitently, TestIndexModifier.testIndexWithThreads (revision 292010) would fail.\n\nThe basic premise of the test seems to be that 3 pairs of IndexThread instances can be started in parallel, each pair using the same instance of IndexModifier to concurrently and randomly add/delete/optimize a single FSDirectory index.  \nThe test is considered a success if the sum of additions-deletions recorded by each pair of threads equals the final docCount() for the IndexModifier instance used by that pair of threads.\n\nNow I freely admit that I'm not 100% familiar with the code for IndexModifier, but at a glance, the basic premise seems to be: \n   a) If method for IndexWriter is called, open it if needed, close the IndexReader first if needed.\n   b) if method for IndexReader is called, open it if needed, close the IndexWriter first if needed.\n\nIf I'm understnading that correctly, I see no reason to assume this test will pass.  \nIt seems like there could be plenty of scenerios in which the number of additions-deletions != docCount(). The most trivial example I can think of is:\n   1) the first IndexThread instance which has a chance to run adds a document, and optimizes before any other IndexThreads ever open the Directory.\n   2) a subsequent pair of IndexThread instances open their IndexModifier instance before any documents are deleted.\n   3) the IndexThread instances from #2 do nothing but add documents\n...that pair of IndexThreads is now garunteed to have recorded a differnet number of additions then the docCount returned by their IndexModifier.\n\nAm I missing something, or should this test be removed?\n\n",
    "hasPatch": false,
    "hasScreenshot": false,
    "id": "LUCENE-442",
    "issuetypeClassified": "OTHER",
    "issuetypeTracker": "BUG",
    "priority": "Major",
    "product": "LUCENE",
    "project": "LUCENE",
    "summary": "TestIndexModifier.testIndexWithThreads is not valid?",
    "systemSpecification": false,
    "version": "1.9"
}