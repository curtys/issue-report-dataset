{
    "comments": [
        {
            "author": "Yonik Seeley",
            "body": "Thanks Karl, it's interesting stuff...\n\n> You might notice that norms are float[] and not byte[]. That is me who refactored it to see if it would do\n> any good. Bit shifting don't take many ticks, so I might just revert that. \n\nSince there are only 256 byte values, many scorers use a simple lookup table Similarity.getNormDecoder()\nAfter I sped up norm decoding, a lookup table was only marginally faster anyway (see comments in SmallFloat class).  So I wouldn't expect float[] norms to be mesurably faster than byte[] norms in the context of a complete search.\n",
            "date": "2006-04-20T22:04:29.000+0000",
            "id": 0
        },
        {
            "author": "Karl Wettin",
            "body": "> > You might notice that norms are float[] and not byte[]. That is me who refactored it to see if it would do\n> > any good. Bit shifting don't take many ticks, so I might just revert that.\n\n> Since there are only 256 byte values, many scorers use a simple lookup table Similarity.getNormDecoder()\n> After I sped up norm decoding, a lookup table was only marginally faster anyway (see comments in SmallFloat \n> class). So I wouldn't expect float[] norms to be mesurably faster than byte[] norms in the context of a complete\n> search.\n\nThe hypthesis is that instanciation and unnecessary data parsing is the bad guy. Converting bytes to floats fit that profile, so I moved it to the IO-classes (readFloat -> readByte). I relize that for the the norms alone, it is a marginal win, but if I find enough of these things it might show in the end.  Don't know if I'll find enough things to work with though. Been looking at getting ridth of things in the IndexReader as the information it returns in many situations already available in the information passed IndexReader, but I'm afraid it might be a Pyrrhus victory as the Jit usually automatically \"caches\" things like that. There are more obvious places to save ticks, e.g. replacing collections with arrays.",
            "date": "2006-04-20T23:30:22.000+0000",
            "id": 1
        },
        {
            "author": "Karl Wettin",
            "body": "The whole Lucene core branch.\n\nI think I've messed something up, queries with Directory-implementations are much slower than normal. :-)\n\nSee the class diagram to understand what I did.",
            "date": "2006-04-21T07:36:14.000+0000",
            "id": 2
        },
        {
            "author": "Karl Wettin",
            "body": "Class diagram over InstanciatedIndex",
            "date": "2006-04-21T07:37:41.000+0000",
            "id": 3
        },
        {
            "author": "Karl Wettin",
            "body": "Due to read and write locks, this is how one must use the extention:\n\nInstanciatedIndex ii = new InstanciatedIndex();\n\nIndexWriter iw = ii.new InstanciatedIndexWriter(analyzer, clear); // locks\niw.close(); // commits\n\nIndexReader ir = ii.new InstanciatedIndexReader();\n\nSearcher = ii.getSearcher();",
            "date": "2006-04-21T07:50:25.000+0000",
            "id": 4
        },
        {
            "author": "Karl Wettin",
            "body": "This is a class diagram that explains what it will look like when I'm done.\n\nIt is pretty much only the IndexReader that needs to be refactored.",
            "date": "2006-04-22T04:11:50.000+0000",
            "id": 5
        },
        {
            "author": "Karl Wettin",
            "body": "Some new statistics.\n\n* A corpus of 500 documents, 1-5K text per document.\n* Placed 150 000 term and boolean queries.\n* Retrieved the top <100 hits from each result.\n\nQuery alone is about 5x faster,\nbut 9x if you include the hits collection.\n\nI belive that span queries will be about 10x-20x faster as the skipTo() is really really optimized. There is a bug in my term position code, so I have not been able to messure it for real yet.\n\nHope to have that working and an updated class diagram for you soon.\n",
            "date": "2006-05-10T04:46:57.000+0000",
            "id": 6
        },
        {
            "author": "Karl Wettin",
            "body": "Oups\n\nInstanciatedIndex:\nCorpus creation took 14011 ms.\nTerm queries took 33608 ms.\n\nRAMDirectory:\nCorpus creation took 9144 ms.\nTerm queries took 1123565 ms.\n\nThat it 35x the speed. \n\nSomething might be wrong. But my initial tests tells me that it is right. Will look in to this tomorrow. Need to sleep now.",
            "date": "2006-05-10T06:25:11.000+0000",
            "id": 7
        },
        {
            "author": "Karl Wettin",
            "body": "There is a minor norms bug. The value differst +-3 from the Directory norms. Other than that it seems to work great.\n\nNow about 40x faster than RAMDirectory.\n\nStats for test: 500 documents. 1-5K text content.\n10 000 * 5 spans\n10 000 * 13 term and boolean term queries.\ncollected top 100 documents for each search results.\n\nInstanciatedIndex is 40x faster than the RAMDirectory.\n\nInstanciatedIndex running on Lucene 1.9-karl1\nCorpus creation took 14903 ms.\nSpan queries took 12884 ms.\nTerm queries took 30221 ms.\n\nRAMDirectory run on Licene 1.9\nCorpus creation took 9337 ms.\nSpan queries took 253412 ms.\nTerm queries took 1188492 ms.\n\n",
            "date": "2006-05-11T22:32:09.000+0000",
            "id": 8
        },
        {
            "author": "Doug Cutting",
            "body": "This looks very promising.  Unfortunately the code you provide makes many incompatible API changes (e.g., turning Term into an interface that has far fewer methods) removes lots of useful javadoc, etc.  So please don't expect it to be committed soon!\n\nA back-compatible way to add an interface is to add it above the old class.  So you might add a TermInteface, AbstractTerm, and TermImpl, then change term to extend TermImpl and deprecate it.\n\nThen there's also the question of whether you really must convert Term to an interface.  I would not undertake that change for aesthetic reasons.  Is it really required to achieve your goals?  You should generally try hard to minimize the size of your diffs and maximize the back-compatiblity.\n",
            "date": "2006-05-12T01:29:11.000+0000",
            "id": 9
        },
        {
            "author": "Karl Wettin",
            "body": "Doug Cutting commented on LUCENE-550:\n\n> This looks very promising.  Unfortunately the code you provide makes many incompatible API \n> changes (e.g., turning Term into an interface that has far fewer methods) removes lots of \n> useful javadoc, etc.  So please don't expect it to be committed soon!\n\nI agree, there is lots of work to be done on it. It was eaiser for me to think clear when everything was seperated. Basically there are only a few changes to the API that is needed:\n\n1. Document nor Term may be final.\n2. Something other minor that I forgot about.\n\nIt can all be fixed, but is nothing that I prioritize right now. If you feel it would be a nice thing for 2.0, tolk me what changes you are OK with and gave me at least two weeks notice I /might/ find time to back-factor the code.\n",
            "date": "2006-05-12T01:45:40.000+0000",
            "id": 10
        },
        {
            "author": "Karl Wettin",
            "body": "This is the diagram of InstanciatedIndex as of 1.9-karl1",
            "date": "2006-05-12T04:21:10.000+0000",
            "id": 11
        },
        {
            "author": "Karl Wettin",
            "body": "This update makes InstanciatedIndex compatible with Lucene, given that issue 580 and 581 is adopted.\n\nIt depends on generics and concurrent locks from J2SE 5.0.\n\nContains one update in Field:\n\npublic setFieldData(Object fieldData)\n\nAnd one in Document:\n\npublic List<Field> getFields() {\n  return fields;\n}",
            "date": "2006-05-27T18:42:01.000+0000",
            "id": 12
        },
        {
            "author": "Karl Wettin",
            "body": "ArrayBoundsOutOfIndex-bugfix.\n\nIf eveything works as it should (I think so) then I'm happy to report that a FuzzyQuery seems to be about 1500 (one thousand five hundred) times faster on this memory implementation than on a RAMDirectory. The speed is gained by not creating a new instance of each Term in a TermEnum.\n",
            "date": "2006-06-14T14:35:40.000+0000",
            "id": 13
        },
        {
            "author": "Karl Wettin",
            "body": "> If eveything works as it should \n\nI doesn't. I keep taking out the victories in advance. I'll try not to in the future. So forget about the 1500. I'll come with a new number soon enough.",
            "date": "2006-06-15T05:08:33.000+0000",
            "id": 14
        },
        {
            "author": "Karl Wettin",
            "body": "> I'll come with a new number soon enough.\n\nRight, it was 25% faster. So forget everthing I said about anything.",
            "date": "2006-06-15T06:23:39.000+0000",
            "id": 15
        },
        {
            "author": "Karl Wettin",
            "body": "There is a bug with phrase queries. Possible term positions. Low priority for me.",
            "date": "2006-06-17T03:21:37.000+0000",
            "id": 16
        },
        {
            "author": "Karl Wettin",
            "body": "To make this index work flawless (I hope), remove the if-statement around the following row in InstatiatedIndexWriter (row 477 or so):\n\ntermDocumentInformation.termPositions.add(fieldSettings.position);\n\nThis will fix the termposition bug noted in an earlier comment.\n\nI'll keep posting bugfixes as comments here, but when I work on it it's really in my branch of lucene 2.0.0, available here: http://www.ginandtonique.org/trac/snigel/wiki/Lucene2-karl\n\nIf someone feels that this layer is an interesting thing to add to Lucene, let me know what is required for commit and I'll make those changes. It still seems to be about 40 times (mean value on a \"nomal\" index with \"normal\" amount of terms. have seen 20x-200x) than RAMDirectory when comparing search and to retrieve documents time combined.",
            "date": "2006-07-20T08:04:48.000+0000",
            "id": 17
        },
        {
            "author": "Karl Wettin",
            "body": "A comment on memory usage: about 2x a RAMDirectory (900MB and 1800MB) on a 150,000 document corpus (when the corpus term count have been reached?) ",
            "date": "2006-07-20T08:58:08.000+0000",
            "id": 18
        },
        {
            "author": "Karl Wettin",
            "body": "In order to find the norm-error I ported all test cases. I'm sorry to report that 70 of them fails.\n\nSo if anyone use this code, don't. :-) \n\nHopefully most of the problems share the same problem. I'll be at the code this weekend, and perhaps a few days next week if needed.",
            "date": "2006-07-21T23:40:29.000+0000",
            "id": 19
        },
        {
            "author": "Karl Wettin",
            "body": "New code. More backwards compatible. Just a very few changes required to the Lucene core. \n\nNow with test cases from distribution, but only search/* has been ported. Fails some (11 of 172) score and RMI related tests that I can not explain. Could really need some help with that\n\nExcept for that this seems to work really great now. I've been running this in a live environment for a few hours (some hundred thousand user queries) and it is *really* fast.\n\n\nOutput from failing tests:\n\n\njunit.framework.AssertionFailedError: expected:<3> but was:<0>\n\tat org.apache.lucene.search.TestPhraseQuery.testSlopScoring(TestPhraseQuery.java:298)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat com.intellij.rt.execution.junit2.JUnitStarter.main(JUnitStarter.java:32)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat com.intellij.rt.execution.application.AppMain.main(AppMain.java:90)\n\n\njunit.framework.AssertionFailedError: Using 10 documents per index:\n\tat org.apache.lucene.search.TestMultiSearcher.testNormalization(TestMultiSearcher.java:247)\n\tat org.apache.lucene.search.TestMultiSearcher.testNormalization10(TestMultiSearcher.java:220)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat com.intellij.rt.execution.junit2.JUnitStarter.main(JUnitStarter.java:32)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat com.intellij.rt.execution.application.AppMain.main(AppMain.java:90)\n\n------- testSimpleEqualScores1 -------\n#0: 1.000000000 - d3\n#1: 1.000000000 - d4\n#2: 0.500000000 - d1\n#3: 0.500000000 - d2\n\njunit.framework.AssertionFailedError: score #2 is not the same expected:<1.0> but was:<0.5>\n\tat org.apache.lucene.search.TestDisjunctionMaxQuery.testSimpleEqualScores1(TestDisjunctionMaxQuery.java:142)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat com.intellij.rt.execution.junit2.JUnitStarter.main(JUnitStarter.java:32)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat com.intellij.rt.execution.application.AppMain.main(AppMain.java:90)\n\n------- testSimpleEqualScores2 -------\n#0: 1.000000000 - d2\n#1: 0.500000000 - d1\n#2: 0.500000000 - d4\n\njunit.framework.AssertionFailedError: score #1 is not the same expected:<1.0> but was:<0.5>\n\tat org.apache.lucene.search.TestDisjunctionMaxQuery.testSimpleEqualScores2(TestDisjunctionMaxQuery.java:166)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat com.intellij.rt.execution.junit2.JUnitStarter.main(JUnitStarter.java:32)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat com.intellij.rt.execution.application.AppMain.main(AppMain.java:90)\n\n------- testSimpleEqualScores3 -------\n#0: 1.000000000 - d2\n#1: 1.000000000 - d3\n#2: 1.000000000 - d4\n#3: 0.500000000 - d1\n\njunit.framework.AssertionFailedError: score #3 is not the same expected:<1.0> but was:<0.5>\n\tat org.apache.lucene.search.TestDisjunctionMaxQuery.testSimpleEqualScores3(TestDisjunctionMaxQuery.java:191)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat com.intellij.rt.execution.junit2.JUnitStarter.main(JUnitStarter.java:32)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat com.intellij.rt.execution.application.AppMain.main(AppMain.java:90)\n\n\njunit.framework.AssertionFailedError: A,B,D, only B in range expected:<1> but was:<2>\n\tat org.apache.lucene.search.TestRangeQuery.testExclusive(TestRangeQuery.java:39)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat com.intellij.rt.execution.junit2.JUnitStarter.main(JUnitStarter.java:32)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat com.intellij.rt.execution.application.AppMain.main(AppMain.java:90)\n\n\njunit.framework.AssertionFailedError: A,B,D - A and B in range expected:<2> but was:<5>\n\tat org.apache.lucene.search.TestRangeQuery.testInclusive(TestRangeQuery.java:63)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat com.intellij.rt.execution.junit2.JUnitStarter.main(JUnitStarter.java:32)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat com.intellij.rt.execution.application.AppMain.main(AppMain.java:90)\n\n\njunit.framework.AssertionFailedError: Using 10 documents per index:\n\tat org.apache.lucene.search.TestMultiSearcher.testNormalization(TestMultiSearcher.java:247)\n\tat org.apache.lucene.search.TestMultiSearcher.testNormalization10(TestMultiSearcher.java:220)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat com.intellij.rt.execution.junit2.JUnitStarter.main(JUnitStarter.java:32)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat com.intellij.rt.execution.application.AppMain.main(AppMain.java:90)\n\n\njava.rmi.server.ExportException: internal error: ObjID already in use\n\tat sun.rmi.transport.ObjectTable.putTarget(ObjectTable.java:197)\n\tat sun.rmi.transport.Transport.exportObject(Transport.java:90)\n\tat sun.rmi.transport.tcp.TCPTransport.exportObject(TCPTransport.java:231)\n\tat sun.rmi.transport.tcp.TCPEndpoint.exportObject(TCPEndpoint.java:398)\n\tat sun.rmi.transport.LiveRef.exportObject(LiveRef.java:131)\n\tat sun.rmi.server.UnicastServerRef.exportObject(UnicastServerRef.java:195)\n\tat sun.rmi.registry.RegistryImpl.setup(RegistryImpl.java:107)\n\tat sun.rmi.registry.RegistryImpl.<init>(RegistryImpl.java:93)\n\tat java.rmi.registry.LocateRegistry.createRegistry(LocateRegistry.java:198)\n\tat org.apache.lucene.search.TestSort.startServer(TestSort.java:704)\n\tat org.apache.lucene.search.TestSort.getRemote(TestSort.java:689)\n\tat org.apache.lucene.search.TestSort.testRemoteSort(TestSort.java:410)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat com.intellij.rt.execution.junit2.JUnitStarter.main(JUnitStarter.java:32)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat com.intellij.rt.execution.application.AppMain.main(AppMain.java:90)\n\n\njava.rmi.server.ExportException: internal error: ObjID already in use\n\tat sun.rmi.transport.ObjectTable.putTarget(ObjectTable.java:197)\n\tat sun.rmi.transport.Transport.exportObject(Transport.java:90)\n\tat sun.rmi.transport.tcp.TCPTransport.exportObject(TCPTransport.java:231)\n\tat sun.rmi.transport.tcp.TCPEndpoint.exportObject(TCPEndpoint.java:398)\n\tat sun.rmi.transport.LiveRef.exportObject(LiveRef.java:131)\n\tat sun.rmi.server.UnicastServerRef.exportObject(UnicastServerRef.java:195)\n\tat sun.rmi.registry.RegistryImpl.setup(RegistryImpl.java:107)\n\tat sun.rmi.registry.RegistryImpl.<init>(RegistryImpl.java:93)\n\tat java.rmi.registry.LocateRegistry.createRegistry(LocateRegistry.java:198)\n\tat org.apache.lucene.search.TestSort.startServer(TestSort.java:704)\n\tat org.apache.lucene.search.TestSort.getRemote(TestSort.java:689)\n\tat org.apache.lucene.search.TestSort.testRemoteCustomSort(TestSort.java:417)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat com.intellij.rt.execution.junit2.JUnitStarter.main(JUnitStarter.java:32)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat com.intellij.rt.execution.application.AppMain.main(AppMain.java:90)\n\n\njava.rmi.server.ExportException: internal error: ObjID already in use\n\tat sun.rmi.transport.ObjectTable.putTarget(ObjectTable.java:197)\n\tat sun.rmi.transport.Transport.exportObject(Transport.java:90)\n\tat sun.rmi.transport.tcp.TCPTransport.exportObject(TCPTransport.java:231)\n\tat sun.rmi.transport.tcp.TCPEndpoint.exportObject(TCPEndpoint.java:398)\n\tat sun.rmi.transport.LiveRef.exportObject(LiveRef.java:131)\n\tat sun.rmi.server.UnicastServerRef.exportObject(UnicastServerRef.java:195)\n\tat sun.rmi.registry.RegistryImpl.setup(RegistryImpl.java:107)\n\tat sun.rmi.registry.RegistryImpl.<init>(RegistryImpl.java:93)\n\tat java.rmi.registry.LocateRegistry.createRegistry(LocateRegistry.java:198)\n\tat org.apache.lucene.search.TestSort.startServer(TestSort.java:704)\n\tat org.apache.lucene.search.TestSort.getRemote(TestSort.java:689)\n\tat org.apache.lucene.search.TestSort.testNormalizedScores(TestSort.java:440)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat com.intellij.rt.execution.junit2.JUnitStarter.main(JUnitStarter.java:32)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat com.intellij.rt.execution.application.AppMain.main(AppMain.java:90)\n",
            "date": "2006-07-22T19:50:10.000+0000",
            "id": 20
        },
        {
            "author": "Karl Wettin",
            "body": "Updated to match the current svn with Fieldable, et.c.\n\nAll changes to Lucene core are now gathered in a small patch (de-finalized Document and Term) and one new class (InterfaceIndexWriter implemented by IndexWriter in patch) instead of attaching the whole trunk.\n\nStill fails a few score- and RMI-tests. ",
            "date": "2006-07-23T13:59:58.000+0000",
            "id": 21
        },
        {
            "author": "Karl Wettin",
            "body": "Performance from live environemt:\n\n * 150,000 documents, average size is 2K.\n\n * Consumes 2x the memory of a RAMDirectory.\n\n * Average user query match 90 documents.\n\n * RAMDirectory takes 60x more time to collect and instantiate the resulting documents.\n\nI would very much apreciate if someone with knowledge of the scoring code could take a look at the seven final(tm) failing tests. Them failing is not a problem for me, but it would be nice if they passed. ",
            "date": "2006-07-26T20:34:59.000+0000",
            "id": 22
        },
        {
            "author": "Dejan Nenov",
            "body": "Can we please get the class diagrams in PDF format - the PNGs are so tny - they are undreadable :(",
            "date": "2006-07-26T20:56:13.000+0000",
            "id": 23
        },
        {
            "author": "Karl Wettin",
            "body": "> Can we please get the class diagrams in PDF format - \n> the PNGs are so tny - they are undreadable :(\n\nShamless promotion:\n\nI'm actually in the progress of porting all my old diagrams to <http://www.appliedmodels.com/>, this fantastic MDA-tool a friend of mine just released to the public. So quite soon there will be new diagrams. Pehaps even PDF.\n\nUntil then you're stuck to zooming :)",
            "date": "2006-07-26T21:21:05.000+0000",
            "id": 24
        },
        {
            "author": "Dejan Nenov",
            "body": "And whil ewe wait - may we please have highres PNGs - so that the zoomed-in versions are a little more readable?",
            "date": "2006-07-26T22:53:29.000+0000",
            "id": 25
        },
        {
            "author": "Karl Wettin",
            "body": "Here is what I just sent to Wolgang. I've adapted his bench test case to also work with InstantiatedIndex. It is worth noticing this is a test with one document only, and the speed is not linear according to my previous tests. InstantiatedIndex is much more than 3x faster than RAMDirectory in a larger index. So this is really only to compare MemoryIndex with InstantiatedIndex, and not as a bench against RAMDirectory.\n\nRAMDirectory:\n\nsecs = 95.159\nqueries/sec= 315.26184\nMB/sec = 9.900338\nDone benchmarking (without checking correctness).\n\n\nMemoryIndex:\n\nsecs = 26.692\nqueries/sec= 1123.9323\nMB/sec = 35.295456\nDone benchmarking (without checking correctness).\n\n\n\nInstantiatedIndex:\n\nsecs = 27.44\nqueries/sec= 1093.2944\nMB/sec = 34.333317\nDone benchmarking (without checking correctness).\n\n\nMemoryIndex is a bit faster than InstantiatedIndex. But I'm aware of a couple of small optimizations I can do. ",
            "date": "2006-11-21T18:05:16.000+0000",
            "id": 26
        },
        {
            "author": "wolfgang hoschek",
            "body": "What's the benchmark configuration? For example, is throughput bounded by indexing or querying?  Measuring N queries against a single preindexed document vs. 1 precompiled query against N documents? See the line\n\nboolean measureIndexing = false; // toggle this to measure query performance\n\nin my driver. If measuring indexing, what kind of analyzer / token filter chain is used? If measuring queries, what kind of query types are in the mix, with which relative frequencies? \n\nYou may want to experiment with modifying/commenting/uncommenting various parts of the driver setup, for any given target scenario. Would it be possible to post the benchmark code, test data, queries for analysis?\n",
            "date": "2006-11-21T18:19:53.000+0000",
            "id": 27
        },
        {
            "author": "wolfgang hoschek",
            "body": "Other question: when running the driver in test mode (checking for equality of query results against RAMDirectory) does InstantiatedIndex pass all tests? That would be great!",
            "date": "2006-11-21T18:22:23.000+0000",
            "id": 28
        },
        {
            "author": "Karl Wettin",
            "body": "wolfgang hoschek [21/Nov/06 10:22 AM]\n> Other question: when running the driver in test mode (checking for equality of query\n> results against RAMDirectory) does InstantiatedIndex pass all tests? That would be great! \n\nIt sure does!\n\nxfiles = [./CHANGES.txt, ./LICENSE.txt]\n\n########### iteration=0\n\n*********** FILE=./CHANGES.txt\ndiff=-0.020341659, query=term, scoreII=0.020341659, scoreRAM=0.020341659\ndiff=-0.024093388, query=term*, scoreII=0.024093388, scoreRAM=0.024093388\ndiff=-0.025180675, query=term~, scoreII=0.025180675, scoreRAM=0.025180675\ndiff=-0.018685007, query=Apache, scoreII=0.018685007, scoreRAM=0.018685007\ndiff=-0.014089426, query=Apach~ AND Copy*, scoreII=0.014089426, scoreRAM=0.014089426\n\n*********** FILE=./LICENSE.txt\ndiff=0.0, query=term, scoreII=0.0, scoreRAM=0.0\ndiff=-0.027122213, query=term*, scoreII=0.027122213, scoreRAM=0.027122213\ndiff=-0.028767452, query=term~, scoreII=0.028767452, scoreRAM=0.028767452\ndiff=-0.023488527, query=Apache, scoreII=0.023488527, scoreRAM=0.023488527\ndiff=-0.043373547, query=Apach~ AND Copy*, scoreII=0.043373547, scoreRAM=0.043373547\n\nsecs = 3.766\nqueries/sec= 2.655337\nMB/sec = 0.083386995\nNo bug found. done.\n\nProcess finished with exit code 0\n",
            "date": "2006-11-21T20:41:38.000+0000",
            "id": 29
        },
        {
            "author": "wolfgang hoschek",
            "body": "Ok. That means a basic test passes. For some more exhaustive tests, run all the queries in \n\nsrc/test/org/apache/lucene/index/memory/testqueries.txt\n\nagainst matching files such as \n\n    String[] files = listFiles(new String[] {\n      \"*.txt\", //\"*.html\", \"*.xml\", \"xdocs/*.xml\", \n      \"src/java/test/org/apache/lucene/queryParser/*.java\",\n      \"src/java/org/apache/lucene/index/memory/*.java\",\n    });\n \n\nSee testMany() for details. Repeat for various analyzer, stopword toLowerCase settings, such as \n\n    boolean toLowerCase = true;\n//    boolean toLowerCase = false;\n//    Set stopWords = null;\n    Set stopWords = StopFilter.makeStopSet(StopAnalyzer.ENGLISH_STOP_WORDS);\n    \n    Analyzer[] analyzers = new Analyzer[] { \n//        new SimpleAnalyzer(),\n//        new StopAnalyzer(),\n//        new StandardAnalyzer(),\n        PatternAnalyzer.DEFAULT_ANALYZER,\n//        new WhitespaceAnalyzer(),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, false, null),\n//        new PatternAnalyzer(PatternAnalyzer.NON_WORD_PATTERN, true, stopWords),        \n//        new SnowballAnalyzer(\"English\", StopAnalyzer.ENGLISH_STOP_WORDS),\n    };\n \n",
            "date": "2006-11-21T20:50:09.000+0000",
            "id": 30
        },
        {
            "author": "wolfgang hoschek",
            "body": "> diff=-0.024093388, query=term*, scoreII=0.024093388, scoreRAM=0.024093388\n\nActually, diff != 0 means the test fails, unless the diff is very small due too rounding error, say 10E-9. The driver should report a IllegalStateException(\"BUG DETECTED:\"",
            "date": "2006-11-21T20:56:55.000+0000",
            "id": 31
        },
        {
            "author": "Karl Wettin",
            "body": "> > diff=-0.024093388, query=term*, scoreII=0.024093388, scoreRAM=0.024093388\n>\n> Actually, diff != 0 means the test fails, unless the diff is very small due too rounding error, say 10E-9. \n> The driver should report a IllegalStateException(\"BUG DETECTED:\"\n\nRight, that was a bug in my code. The diff /output/ was calculated on scoreMEM - scoreRAM (were scoreMEM is 0) and not scoreII - scoreRAM ; )",
            "date": "2006-11-21T21:15:48.000+0000",
            "id": 32
        },
        {
            "author": "Karl Wettin",
            "body": "wolfgang hoschek [21/Nov/06 12:50 PM]\n> Ok. That means a basic test passes. For some more exhaustive tests, run all the queries in\n\nAll Lucene unit tests have been adapted to work with my alternate index. Everything but proximity queries pass. Have not looked in to why as I don't use them (yet). And I have written an in depth index comparator to make sure that an InstantiatedIndex equals a Directory implementation. Hence I have already verified that the index works as expected. \n\nTodays postings from me is more to show that InstantiatedIndex is /almost/ as fast as MemoryIndex and could thus be an interesting replacement, as as it handles more than one document it might even be preferable in some cases.\n\nI will however run your suggested tests tomorrow and report back. \nAnd post the latest patches, including my adaptation of your unit test, in case you want to explore it by your self.",
            "date": "2006-11-21T21:28:50.000+0000",
            "id": 33
        },
        {
            "author": "wolfgang hoschek",
            "body": "> All Lucene unit tests have been adapted to work with my alternate index. Everything but proximity queries pass. \n\nSounds like you're almost there :-)\n\nRegarding indexing performance with MemoryIndex: Performance is more than good enough. I've observed and measured that often the bottleneck is not the MemoryIndex itself, but rather the Analyzer type (e.g. StandardAnalayzer) or the I/O for the input files or term lower casing (http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6265809) or something else entirely.\n\nRegarding query performance with MemoryIndex: Some queries are more efficient than others. For example, fuzzy queries are much less efficient than wild card queries, which in turn are much less efficient than simple term queries. Such effects seem partly inherent due too the nature of the query type, partly a function of the chosen data structure (RAMDirectory, MemoryIndex, II, ...), and partly a consequence of the overall Lucene API design.\n\nThe query mix found in testqueries.txt is more intended for correctness testing than benchmarking. Therein, certain query types dominate over others, and thus, conclusions about the performance of individual aspects cannot easily be drawn.\n\nWolfgang.\n",
            "date": "2006-11-21T23:30:46.000+0000",
            "id": 34
        },
        {
            "author": "wolfgang hoschek",
            "body": "I've now checked in a version of MemoryIndexTest  into contrib/memory that more easily allows to switch between measuring indexing or querying. Example output for measuring query throughput on simple term queries: ~500000 queries/sec on a MacBook Pro, jdk 1.5.0_06, server VM. As always, your mileage may vary.",
            "date": "2006-11-22T08:10:55.000+0000",
            "id": 35
        },
        {
            "author": "Karl Wettin",
            "body": "This is the current version of my local Lucene branch, including InstantiatedIndex. As I have not merged with the trunk for a while, it also features my locally patched version. It really is just a few small changes. Some classes are no longer final, plus I have introduced InterfaceIndexWriter and InterfaceIndexModifier.\n\n/lucene2karl/lucene2-apache-karl-patched\n/lucene2karl/lucene2-karl/test <--- all (search) test cases adapted to run with instantiated index\n/lucene2karl/lucene2-karl/index\n/lucene2karl/lucene2-karl/instantiated\n/lucene2karl/lucene2-karl/searchfork   <--- non important stuff\n/lucene2karl/lucene2-karl/analysis   <--- just some stuff\n/lucene2karl/lucene2-karl/core   <-- patches for the lucene trunk\n/memoryindex   <---  stuff for wolfgang\n\nAll tests pass, except remote, multi and parallell searchers.\n\nJira admins: you are more than welcome to remove all old attachments, except images.",
            "date": "2006-11-22T13:22:11.000+0000",
            "id": 36
        },
        {
            "author": "Karl Wettin",
            "body": "> Jira admins: you are more than welcome to remove all old attachments, except images.\n\noh, i had no clue my status was upgraded. cool. fixed it my self.",
            "date": "2006-11-27T16:49:42.000+0000",
            "id": 37
        },
        {
            "author": "Doug Cutting",
            "body": "I don't see a patch file here.  Your proposal would be easier to evaluate as a patch file.  Also, a contribution like this will be easier to accept if your new classes are in the contrib tree.  Then, if they prove popular, they can move into the core.  Or perhaps folks will find them so obviously useful they'll want them in the core from the start, but contrib would require less convincing.",
            "date": "2007-01-12T18:16:15.660+0000",
            "id": 38
        },
        {
            "author": "Karl Wettin",
            "body": "Doug Cutting [12/Jan/07 10:16 AM] \n> I don't see a patch file here. Your proposal would be easier to evaluate as a patch file.\n\nAttached!\n\n> easier to accept if your new classes are in the contrib tree. \n\nThere are a couple of chages in the core, the rest has been moved to contrib/indexfacade and contrib/instantiated. There is some clean up to do: a couple of static tests in instantiated. And perhaps some common logging artifacts left from debugging.\n\nI'm quite certain that both contrib/packages depends on java<1.5>. At least concurrency in instantiated. ",
            "date": "2007-01-13T00:58:31.210+0000",
            "id": 39
        },
        {
            "author": "Karl Wettin",
            "body": "New patch has all assimilated test cases moved to a new non conflicting package.\n\nAlso contains contrib/cache that depends on everything else.",
            "date": "2007-01-14T17:04:28.531+0000",
            "id": 40
        },
        {
            "author": "Hoss Man",
            "body": "I've been trying to follow the work you've been doing Karl, but i must admit a lot of it is over my head -- but since i've got a long weekend and your patch now makes so few changes to the core i could acctually make sense of that part, so here are some comments on those changes...\n\n1) some of these changes seem to be duplicated in LUCENE-774 and LUCENE-775 ... just pointing that out for other people who might get confused.\n\n2) since the new ScoreDoc.docComparator and ScoreDoc.scoreComparator are public, they should have some javadocs clarifing what they are for.\n\n3) i don't think the Hits.setSearcher method you added is safe ... i believe that at a minimum hitDocs, first, last, and weight all need to be reset -- weight's a tricky one since the instance doesn't currently hang on to the orriginal query.\n\n4) I would personally prefer IndexWriterInterface and IndexModifierInterface over InterfaceIndexWriter and InterfaceIndexModifier -- if for no other reason then so they sort together .. but that's a minor nit.\n\n\nI've only briefly looked at the new stuff in contrib, because I got lost ... there isn't any package or class level javadocs or a build.xml in either contrib.  A big thing i did notice is that the code in indexfacade puts things in the o.a.l.search and o.a.l.index packages, which is being discouraged for contribs (among other reasons it makes it confusing to understand where a class is coming form) ideally those classes should live under o.a.l.indexfacade.index and o.a.l.indexfacade.index (or maybe just o.a.l.facade - but you get the idea)\n\n",
            "date": "2007-01-15T08:16:35.163+0000",
            "id": 41
        },
        {
            "author": "Hoss Man",
            "body": "I just realized that all of the tests in contrib/instantiated/src/test/java/org/apache/lucene/instantiated/assimilated/ are duplicates of tests from the core with a few line changes so they use an InstantiatedIndex to get a reader/writer/seracher etc.\n\nI think it would be *much* better if we changed the orriginal versions of these tests to include an accessors for constructing/fetching those objects which could be subclassed by tests in your contrib -- that way any bugs found/fixed in those test classes and any additional test methods added to those classes would automatically be inherited by your versions (instead of winding up with duplicate cut/paste test code)",
            "date": "2007-01-15T08:39:53.819+0000",
            "id": 42
        },
        {
            "author": "Hoss Man",
            "body": "Karl: the trunk.diff i just attached fixes a small autoboxing dependency your patch introduced into the core (preventing compilation on java 1.4). I also added build.xml files to the new contrib dirs, rearanged the directory of the contribs so they match the default for contribs and the   the build.xml files could be simple.  Once i did this i discovered some unneccessary dependencies on commons-logging that i removed.  Then i ran the tests, and got some errors -- which are included in test-reports.zip so you can check them out.",
            "date": "2007-01-15T09:35:29.565+0000",
            "id": 43
        },
        {
            "author": "Karl Wettin",
            "body": "Thanks alot Hoss, for taking the time. I sure do appreciate it.\n\nI'll get back on your comments.",
            "date": "2007-01-15T09:51:12.125+0000",
            "id": 44
        },
        {
            "author": "Karl Wettin",
            "body": "New sunday, new code. \n\nHoss Man [15/Jan/07 12:16 AM]\n> I've only briefly looked at the new stuff in contrib, because I got lost ... there isn't\n> any package or class level javadocs or a build.xml in either contrib.\n\nTried to do something about the java docs. Also made a new fresh class diagram with some comments in it. I can make it PDF or XUL if prefered.\n\nThat boxing error you fixed might be back. Where was it? Could not find it in the patch (all adding and no -+ fix) and it was too late to apply your patch on my local version..\n\n> Hoss Man [15/Jan/07 12:16 AM]\n>\n> 1) some of these changes seem to be duplicated in LUCENE-774 and LUCENE-775 \n> ... just pointing that out for other people who might get confused.\n\nIs it considered better practise to keep all my changes in this one huge issue? I thought it could be nice to pop in minor patches such as them. \n\n> 4) I would personally prefer.. \n> but that's a minor nit.\n\nThere has been a lot of refactoring of packages and class names as suggested. (I'm still not happy with the notification listener classes.)\n\nA few new changes to the core:\n\nLazy initialization of the fields collection in Document .\n\nSome definalization to allow decoration of IndexReader.\nhttp://www.nabble.com/IndexReader-can-not-be-decorated-tf3041647.html#a8461125 \n\n> Hoss Man [15/Jan/07 12:16 AM]\n>\n> 3) i don't think the Hits.setSearcher method you added is safe\n\nIt smeared out on java-dev: http://www.nabble.com/Decorative-cache-%28and-Hits.setSearcher%29-tf3009848.html#a8428139\n\nI did not investigate this any further with test code, but I have identitfied lazy fields as a problem. Instead I'm considering a supplementary decorated document cache on the IndexReader, and implementing a replacement for Hits.\n\nHoss Man [15/Jan/07 12:39 AM]\n> I just realized that all of the tests in contrib/instantiated/src/test/java/org/apache/lucene/\n> instantiated/assimilated/ are duplicates of tests from the core with a few line changes\n> so they use an InstantiatedIndex to get a reader/writer/seracher etc. \n\nThis is not a bad idea at all, but I will not have time to do it right anytime soon. It would be a simpler task if the facade was a part of the core, as this is just the thing it was built for -- unison index handling. ;-)\n\nHoss Man [15/Jan/07 01:35 AM]\n> Then i ran the tests, and got some errors -- which are included in test-reports.zip so you can check them out.\n\nWhat tool do you recommend to inspect these reports?\n\nI know for a fact that remote searchable will fail. I hope for someone to show up, need it and fix it.\n",
            "date": "2007-01-21T19:21:43.313+0000",
            "id": 45
        },
        {
            "author": "Karl Wettin",
            "body": "Patch of the week.\n\nChanges:\n\n * CachedSearcher -- soft referenced hit collection-, TopDocs- and TopFieldDocs cache. Backed by NotifiableIndex.\n\nRemoved Hits cache due to uncertainty but introduced:\n\n * CachedIndexReader -- soft referenced documents cache. Backed by NotifiableIndex.\n\nTopDocs/TopFieldDocs- and IndexReader cache combined almost replace a fully cached Hits.\n\nThe number of unit tests and detail of them is increasing.\n\n\nThe plan is now to have the cached reader pre-loading documents to memory from an own thread when server load allows it. \n\n\n\nAlso added some abstractation levers used by above:\n * AutofreshedIndexReader -- always up to date with the index.\n * ReadOnlyIndexReader -- makes sure the user don't delete stuff with the decorated reader.\n\n\nHad some problems with decorating the IndexModifierInterface against Directory in NotifiableIndex, so removed the Index.indexModifierFactory() and introduced a index facade backed version:\n\norg.apache.lucene.index.facade.IndexModifier(myIndex, analyzer, create)\n\nwhere all reader/writer creation is myIndex.indexReaderFactory() and indexWriterFactory();\n\nMakes the Notifiable code a bit simpler.\n\n",
            "date": "2007-01-27T16:52:27.305+0000",
            "id": 46
        },
        {
            "author": "Karl Wettin",
            "body": "new diagram with lots of notes\n(this is also available in the patch as an uxf-file for umlet)",
            "date": "2007-01-28T18:22:40.998+0000",
            "id": 47
        },
        {
            "author": "Karl Wettin",
            "body": "Refactored the Term->Document relationships a bit for speed optimizations. It also resulted with getting all term frequency vector information except for offsets free of charge. More information on that in the class diagram.\n\nRemoved a whole bunch of todo:s in the writer and reader.\n\nThe current lock implementen is worthless. I need to read up on RentrentLock. Or should I perhaps use the lock Directory:s use?\n\n(And that class diagram is of course granted for ASF, my misstake.)",
            "date": "2007-01-28T18:34:34.520+0000",
            "id": 48
        },
        {
            "author": "Karl Wettin",
            "body": "Added support for contrib/memory MemoryIndex, so now it works with readers and writers as if it was any other index.\n\nAdded a consumer level index implementation that handles cache, notifications, and all the stuff this issue is about:\n\n// This is the instace one is supposed to use for all access against the index in this JVM.\nIndexFacade index = new IndexFacade(new RAMDirectoryIndex());\n\n// Accessors\nIndexWriterInterface writer = index.indexWriterFactory(anayzler, true);\nDocument doc = new Document();\ndoc.add(...\nwriter.add(doc);\nwriter.close();\nIndexReader deleter = index.indexReaderFactory();\nindex.getSearcher().search(...\nindex.getReader().doc(0)\ndeleter.close();\nassertEquals(0, index.getReader().numDocs());\n\npublic class IndexFacade {\n\n  /** wrapps any storage, optional cache settings */\n  public IndexFacade(I index, CachedSearcher.HitCollectionCacheState hitCollectionCache, boolean topDocsCache, boolean topFieldsCache, boolean documentsCache) throws IOException {\n  public CachedSearcher getSearcher() throws IOException {\n\n  /** The general consumer searcher to be used when querying this index. Always fresh. */\n  public Searcher getSearcher() throws IOException {\n\n  /** The general consumer read only index reader to be used when inspecting this index. Always fresh. */\n  public IndexReader getReader() throws IOException {\n   \n\n",
            "date": "2007-02-03T18:15:57.412+0000",
            "id": 49
        },
        {
            "author": "Karl Wettin",
            "body": "Can now be loaded from, and be persisted in an FSDirectory. \n\nThe actual implementation is a bit more abtract than that though. It is not super nice yet, but all low level index comparator tests pass. \n\nIntroduced functionallity to load an instantiated from any index reader (e.g. a FSDirectory)\n\n{code:java}\n  /**\n   * Creates a new instantiated index that looks just like the index in a specific state as represented by a reader.\n   * \n   * @param sourceIndexReader the source index this new instantiated index will be copied from.\n   * @throws IOException if the source index is not optimized, or when accesing the source.\n   */\n  public InstantiatedIndex(IndexReader sourceIndexReader) throws IOException {\n{code}\n\nAlso introduced class SimpleSychronizedIndex, a class that kind of works like unix command \"tee\", makes sure that all changes to a main index (e.g. an instantiated index) also is applied to a mirror index (e.g. the fs directory loaded to the instantiated index at constructor time). \n\nSome class that handles these two things a single entity will probably be added soon.\n\nBasiacally this is replicating changes to a secondary index on commits. Thus it takes about twice the time to insert documents. Perhaps the secondary index should be updated in a secondary thread?\n\n",
            "date": "2007-02-10T21:30:55.855+0000",
            "id": 50
        },
        {
            "author": "Karl Wettin",
            "body": "the last attachment is of course for ASF distribution. sorry.",
            "date": "2007-02-10T21:32:49.477+0000",
            "id": 51
        },
        {
            "author": "Karl Wettin",
            "body": "Introduced a method in instantiated index that appends the entire content to any other index.\n\n{code}\n/**\n   * Adds the complete content of this instantiated index on to any other index using an index writer.\n   * <p/>\n   * This can for instance be used for\n   * merging multiple instantiated indices\n   * and periodically storing persistent snapshots in an FSDirectory.\n   * <p/>\n   * Non stored offsets are partially rebuilt. This can be improved quite a bit. See comments in code.\n   * <p/>\n   * The analyzer creates one complete token stream of all fields with the same name the first time it is requested,\n   * and after that an empty for each remaining. todo: this is a problem?\n   * <p/>\n   * It can be buggy if the same token appears as synonym to it self (position increment 0). not really something to worry about.. or?\n   *\n   * @param indexWriter represents the index on wich to add all the content of this instantiated index.\n   * @throws IOException when accessing parameter indexWriter\n   */\n  public void writeToIndex(IndexWriterInterface indexWriter) throws IOException {\n{code}",
            "date": "2007-02-11T17:21:37.088+0000",
            "id": 52
        },
        {
            "author": "Karl Wettin",
            "body": "Updated spell checker code",
            "date": "2007-02-17T07:26:47.172+0000",
            "id": 53
        },
        {
            "author": "Karl Wettin",
            "body": "UML class diagram of the adaptive spell checker with all java docs as comments",
            "date": "2007-02-17T07:29:11.278+0000",
            "id": 54
        },
        {
            "author": "Karl Wettin",
            "body": "(now proof read and all)\nPackage level java doc of the spell checker:\n\nA dictionary with weighted suggestions,\nordered by user activity,\nbacked by algorithmic suggestions.\n<p/>\n\n<h1>What, where, when and how.</h1>\n\n<h2>Goal trees</h2>\nA user session could contain multiple quests for content.\nFor example,\nfirst the user looks for the Apache licence,\nspells it wrong, inspects different results,\nand then the user searches for the author Ivan Goncharov.\n<p/>\nIn this package we call them different goals.\n<p/>\nUser activities are represented by a tree of QueryGoalNodes,\neach describes a user query,\nif the current query (goal node) was a suggestion from the system to a previous user query,\nwhat search results was further inspected,\nwhen it happend,\nand for how long.\n<p/>\nThe biggest task as a consumer when implementing this package\nwill be to keep track of what goal node the user came from,\nso that the new queries (goal node) will become children to the parent.\nProbably you add it as meta data to all actions,\ne.g. in the &lt;a href=\"?goalID=>, as &lt;input type=hidden name=\"goalID\" value=>, et c,\nand keep track of them in a Map&lt;Integer, QueryGoalNode> in the user session.\n<p/>\nIt is up to the QueryGoalTreeExtractor implementations to decide what\nevents in a session are parts of the same goal,\nas we don't want to suggest the user to check out Goncharov\nwhen they are looking for the Apache license.\n<p/>\nIn the default query goal tree extractor,\nnodes are parts of the same goal as their parent when:\n<ul>\n  <li>The queries are the same.</li>\n  <li>The user took a suggestion from the system.</li>\n  <li>The current and the parent queries are similair enough.</li>\n  <li>The queries was entered within short enough time.</li>\n</ul>\n<p/>\n\n<h2>Adaptive training</h2>\nAdaptive means that the suggestions to a query\ndepends on how users previously have been acting.\nThis means that the dictionary could be tampered with quite easy\nand you should therefore try to train only with data from trusted users.\n<p/>\nThe default trainer implementation works like this:\n<ul>\n  <li>If a user accepts the suggestion made by the system, then we increase the score for that suggestion. (positive\n    adaptation)\n  </li>\n  <li>If a user does not accept the suggestion made by the system, then we decrease the score for that suggestion.\n    (negative adaptation)\n  </li>\n  <li>\n    If the goal tree is a single query, one query only (perhaps with multiple inspections)\n    then we adapt negative once again.\n  </li>\n  <li>\n    Suggestions are the queries with inspections, ordered by the classification weight.\n    All the queries in the goal witout inspections will be adpated positive with\n    the query with inspections that has the shortest edit distance.\n  </li>\n  <li>Suggests back from best goal to second best goal. homm -> heroes of might and magic -> homm</li>\n</ul>\n<p/>\n\n<h2>Suggesting</h2>\nSuggestions are created by the suggester, that navigates a dictionary.\nThe default implementation works like this:\n<ul>\n  <li>\n    Returns highest scoring suggestion available,\n    unless the score is lower than the suggestion supression threadshold.\n  </li>\n  <li>\n    If there are no suggestions available, the second level suggesters\n    registred to the dictionary are used to produce the suggestions.\n  </li>\n  <li>\n    If the top scoring suggestion is same as the query,\n    and the second best is not supressed below threadshold,\n    change order\n  </li>\n</ul>\nIgnoring a suggestion 50 times or so with a DefaultTrainer makes a score hit 0.05d.\n<p/>\n\n<h2>Second level suggestion</h2>\nIf the dictionary does not contain a suggestion for a given query,\nit will be passed on to any available SecondLevelSuggester,\nusually an algorithmic suggestion scheme\nthat hopefully can come up with a suggestion.\nAs a user accepts such a suggestion it will be trained\nand become a part of the adaptive layer.\n<h3>Token suggesters</h3>\nThe lowest level of suggestion is single token suggestions,\nand the default implementation is a refactor of the contrib/spellcheck.\n<h3>TokenPhraseSuggester</h3>\nA layer on top of the single token suggesting that enables muti token (phrase) suggestions.\n<p/>\nFor example, the user places the query \"thh best game\".\nThe matrix of similar tokens are:\n<pre>\n  the best game\n  tho rest fame\n           lame\n</pre>\nThese can be represented in a finite number of ways:\n<pre>\n  tho best game\n  tho best fame\n  tho best lame\n  tho rest game\n  tho rest fame\n  tho rest lame\n  the best game\n  the best fame\n  the best lame\n  the rest game\n  the rest fame\n  the rest lame\n</pre>\nA query is created for each combination, in the default SpanNearQueries, to find valid suggestions.\n<p/>\nIf any of the valid hits contains a TermPositionVector\nit will be analyzed and suggest the query in the order of terms in the index.\nE.g. query \"camel that broke the staw\" is suggested with \"straw that broke the camel\"\ntodo: if term positions available and stored, suggest that for cosmetic reasons.)\n\n\n<h1>Consumer interface example</h1>\nCode from the test cases. \n<pre>\n  private SuggestionFacade&lt;R> suggestionFacade;\n\n  @Override\n  protected void setUp() throws Exception {\n    suggestionFacade = = new SuggestionFacade&lt;R>();\n  }\n\n  public void testBasicTraining() throws Exception {\n    QueryGoalNode&lt;R> node;\n\n    node = new QueryGoalNode&lt;R>(null, \"heroes of nmight and magic\", 3);\n    node = new QueryGoalNode&lt;R>(node, \"heroes of night and magic\", 3);\n    node = new QueryGoalNode&lt;R>(node, \"heroes of might and magic\", 10);\n    node.new Inspection(23, QueryGoalNode.GOAL);\n    suggestionFacade.queueGoalTree(node.getRoot());\n\n    node = new QueryGoalNode&lt;R>(null, \"heroes of night and magic\", 3);\n    node = new QueryGoalNode&lt;R>(node, \"heroes of knight and magic\", 7);\n    node = new QueryGoalNode&lt;R>(node, \"heroes of might and magic\", 20);\n    node.new Inspection(23, QueryGoalNode.GOAL);\n    suggestionFacade.queueGoalTree(node);\n\n    node = new QueryGoalNode&lt;R>(null, \"heroes of might and magic\", 20, 1l);\n    suggestionFacade.queueGoalTree(node);\n\n    node = new QueryGoalNode&lt;R>(null, \"heroes of night and magic\", 7, 0l);\n    node = new QueryGoalNode&lt;R>(node, \"heroes of light and magic\", 14, 1l);\n    node = new QueryGoalNode&lt;R>(node, \"heroes of might and magic\", 2, 6l);\n    node.new Inspection(23, QueryGoalNode.GOAL);\n    node.new Inspection(23, QueryGoalNode.GOAL);\n    suggestionFacade.queueGoalTree(node);\n\n    node = new QueryGoalNode&lt;R>(null, \"heroes of night and magic\", 4, 0l);\n    node = new QueryGoalNode&lt;R>(node, \"heroes of knight and magic\", 17, 1l);\n    node = new QueryGoalNode&lt;R>(node, \"heroes of might and magic\", 2, 2l);\n    node.new Inspection(23, QueryGoalNode.GOAL);\n    suggestionFacade.queueGoalTree(node);\n\n    suggestionFacade.flush();\n\n    assertEquals(\"heroes of might and magic\", suggestionFacade.didYouMean(\"heroes of light and magic\"));\n    assertEquals(\"heroes of might and magic\", suggestionFacade.didYouMean(\"heroes of night and magic\"));\n    assertEquals(\"heroes of might and magic\", suggestionFacade.didYouMean(\"heroes ofnight andmagic\"));\n  }\n</pre>\n<p/>\nNotice the last assertation:\n<pre>\n  assertEquals(\"heroes of might and magic\", suggestionFacade.didYouMean(\"heroes ofnight andmagic\"));\n</pre>\nThe dictionary will strip keys from puctuation and whitespace,\nresulting in better support for de/compositions of words.\n<p/>\nAbove example will be user session analyzing and adaptive only,\nno algorithmic suggestions if the user types in something nobody miss spelled before.\nSimply add one to the dictionary:\n<pre>\n  protected void setUp() throws Exception {\n    suggestionFacade = new SuggestionFacade&lt;R>();\n\n    // your primary index that suggestions must match.\n    IndexFacade aprioriIndex = new IndexFacade(new RAMDirectoryIndex());\n    String aprioriField = \"title\";\n\n    // build the ngram suggester\n    IndexFacade ngramIndex = new IndexFacade(new RAMDirectoryIndex());\n    NgramTokenSuggester ngramSuggester = new NgramTokenSuggester(ngramIndex);\n    ngramSuggester.indexDictionary(new TermEnumIterator(aprioriIndex.getReader(), aprioriField));\n\n    // the greater the better results but with a longer response time.\n    int maxSuggestionsPerToken = 3;\n\n    // add ngram suggester wrapped in a single token phrase suggester as second level suggester.\n    suggestionFacade.getDictionary().getPrioritesBySecondLevelSuggester().put(new SecondLevelTokenPhraseSuggester(ngramSuggester, aprioriField, false, maxSuggestionsPerToken, new WhitespaceAnalyzer(), aprioriIndex), 1d);\n  }\n</pre>\n<h1>Persistence and memory usage.</h1>\nBy default the dictionary is soft referenced,\nmeaning it will consume as much memory it can get,\nand if some other application is in need of memory\nlow prioritized (priority is decided by the JVM) instances will be released.\n<p/>\nThere is currently no persistence but java.io.Serliazlible available for the in the adaptive layer.\nYou need to implement your own Map&lt;String, SuggestionList> that is persistent\nand pass it to the constructor of your directory.\n",
            "date": "2007-02-17T08:25:49.369+0000",
            "id": 55
        },
        {
            "author": "Karl Wettin",
            "body": "I'll try to keep updated and built javadocs at this location:\n\nhttp://ginandtonique.org/~kalle/javadocs/didyoumean/org/apache/lucene/search/didyoumean/package-summary.html\n\n(Sorry for flooding..)",
            "date": "2007-02-17T11:31:08.080+0000",
            "id": 56
        },
        {
            "author": "Karl Wettin",
            "body": "Added lots of documentation",
            "date": "2007-02-19T14:20:29.439+0000",
            "id": 57
        },
        {
            "author": "Karl Wettin",
            "body": "Support for deleteDocuments in IndexWriterInterface, InstantiatedIndex and NotifiableIndex.\n\nSomewhat hacky solution to pick up the deletions in NotifiableIndex, but it is a solution.",
            "date": "2007-02-20T20:32:14.697+0000",
            "id": 58
        },
        {
            "author": "Karl Wettin",
            "body": "New Patch. Mainly updates in contrib/didyoumean. Merged some core conflicts.\n\nTestGoalJuror now import 200,000 real user queries from a log containing session id, query, category, timestamp and number of hits, ordered by session id and time. \n\nThis means that the trainer and suggester are not aware of if the user followed or ignored a suggestion from the system, what results was inspected, if the query contained a goal, et c. So it does not work as if trained from the start with the adaptive layer.\n\nStill, the suggester navigates the dictionary fairly well and misspelled queries will be suggested the correct suggestion, but many correct spelled phrases will recommend something silly.  As one start reporting user interaction to the suggester any silly recommendation should go away.\n\nIn essence, it can only adapt the suggestions positive based on what the QueryGoalJuror says is a goal. Negative is only when a user don't take a suggestion. It could be solved with bootstrapping. Will mess with that later. ",
            "date": "2007-02-25T23:37:04.190+0000",
            "id": 59
        },
        {
            "author": "Karl Wettin",
            "body": "Switched from java.util.PriorityQueue to org.apache.lucene.util.PriorityQueue, and made the latter <Generic>. \n\nFixed some major bugs in the TermFreqVector inspection for the spell checker.\n\nDemonstrate in TestGoalJuror how to build an a priori corpus for the ngram token suggester based on user input by inverting the suggestion dictionary. That should probably be extracted to a helper class in the future. This makes it faster to query the a apriori, but it also means that what the system takes for grantent is correct comes from user input, and even if the correct data is what users point out as a real query goal, it does not have to be correct. Although, it makes the suggester much faster.\n\n",
            "date": "2007-03-03T13:18:26.289+0000",
            "id": 60
        },
        {
            "author": "Karl Wettin",
            "body": "Removed the dependencies to LUCENE-626.",
            "date": "2007-03-03T19:56:30.275+0000",
            "id": 61
        },
        {
            "author": "Karl Wettin",
            "body": "Patched contrib/benchmark to support InstantiatedIndex.\n\nFixed a bug with mergeFactor.\n\nReverted java 1.5<G> changes in PriorityQueue to (ClassCasting). (This is actually a spell checker thingy, but due to local dependencies the changes are located in this patch).\n\nRemoved write locks. These had severe bugs and need to be reconsidered. Should be back in next patch. Using multiple InstantiatedIndex:es as segments on a MultiReader rather than updating the same index, this can be made completly lockless.\n\n\n\n\n\n\n\n",
            "date": "2007-03-13T02:22:09.212+0000",
            "id": 62
        },
        {
            "author": "Karl Wettin",
            "body": "A note on, and output from contrib/benchmark:\n\nI'm getting really poor results compared to my own test and live enviroment stats. At query time I expected maximum 1/6th time spent in InstantiatedIndex than RAMDirectory, but it turns out that in the benchmarker the speed is almost the same as RAMDirectory. Retrieving documents is only 1/5th of the speed rather than maximum 1/60th as expected.\n\nInvestigated the code a bit and noticed that ReadTask creates a new instance of IndexReader and IndexSearcher for each query. Could this be the reason?\n\nMemory consumption is 3x of a RAMDirectory, but half of the memory is spent on keeping the Document instances in heap. Perhaps it would be interesting to use the same persistency for these as in the Directory implementations.\n\nThe merge factor sweet spot is around 2500, where it turns out to be a little bit faster than the RAMDirectory sweet spot. At defualt 10 InstantiatedIndex consumes about 5x more time than a RAMDirectory. If I fix the locklessness as suggested in previous comment, it most probably will be much faster than a RAMDirectory at any setting.\n\n/**\n   * The sweet spot for this implementation is at 2500.\n   * <p/>\n   * Benchmark output:\n   * <pre>\n   *  ------------> Report sum by Prefix (MAddDocs) and Round (8 about 8 out of 160153)\n   *  Operation      round  mrg buf cmpnd   runCnt   recsPerRun        rec/s  elapsedSec    avgUsedMem    avgTotalMem\n   *  MAddDocs_20000     0   10  10  true        1        20000         81,4      245,68   200 325 152    268 156 928\n   *  MAddDocs_20000 -   1 1000  10  true -  -   1 -  -   20000 -  -   494,1 -  -  40,47 - 247 119 072 -  347 025 408\n   *  MAddDocs_20000     2   10 100  true        1        20000        104,8      190,81   233 895 552    363 720 704\n   *  MAddDocs_20000 -   3 2000 100  true -  -   1 -  -   20000 -  -   527,2 -  -  37,94 - 266 136 448 -  378 273 792\n   *  MAddDocs_20000     4   10  10 false        1        20000        103,2      193,75   222 089 792    378 273 792\n   *  MAddDocs_20000 -   5 3000  10 false -  -   1 -  -   20000 -  -   545,2 -  -  36,69 - 237 917 152 -  378 273 792\n   *  MAddDocs_20000     6   10 100 false        1        20000        102,7      194,67   237 018 976    378 273 792\n   *  MAddDocs_20000 -   7 4000 100 false -  -   1 -  -   20000 -  -   535,8 -  -  37,33 - 309 680 640 -  501 968 896\n   * </pre>\n   *\n   * @see org.apache.lucene.index.IndexWriterInterface#setMergeFactor(int)\n   */\n  public void setMergeFactor(int mergeFactor) {\n\n\nI would not pay to much attention to the numbers below until I've got the benchmarker under control, but here are the stats:\n\nOutput from InstantiatedIndex:\n\n [java] ------------> Report Sum By (any) Name (19 about 160153 out of 160153)\n     [java] Operation                       round mrg buf cmpnd   runCnt   recsPerRun        rec/s  elapsedSec    avgUsedMem    avgTotalMem\n     [java] Rounds_8                            0  10  10  true        1     25142792     19?842,0    1?267,15   291?055?680    377?163?776\n     [java] Populate -  -  -  -  -  -  -  -  -  - - - - - -   - -  -   8 -  -   20003 -  -   148,1 -  1?080,73 - 249?711?264 -  354?926?592\n     [java] CreateIndex                         -   -   -     -        8            1      1?142,9        0,01   178?670?624    322?181?120\n     [java] MAddDocs_20000 -  -  -  -  -  -  -  - - - - - -   - -  -   8 -  -   20000 -  -   148,0 -  1?080,72 - 249?706?256 -  354?926?592\n     [java] AddDoc                              -   -   -     -   160000            1        156,2    1?024,02   228?890?976    339?588?384\n     [java] Optimize -  -  -  -  -  -  -  -  -  - - - - - -   - -  -   8 -  -  -  - 1 -  - 8?000,0 -  -   0,00 - 249?679?056 -  354?926?592\n     [java] CloseIndex                          -   -   -     -        8            1      2?666,7        0,00   249?689?056    354?926?592\n     [java] OpenReader -  -  -  -  -  -  -  -   - - - - - -   - -  -  16 -  -  -  - 1 -   16?000,0 -  -   0,00 - 246?507?072 -  354?926?592\n     [java] SearchSameRdr_5000                  -   -   -     -        8         5000        806,6       49,59   250?121?728    354?926?592\n     [java] CloseReader -  -  -  -  -  -  -  -  - - - - - -   - -  -  16 -  -  -  - 1 -   16?000,0 -  -   0,00 - 249?146?336 -  354?971?648\n     [java] WarmNewRdr_50                       -   -   -     -        8      1000000  3?118?908,5        2,57   249?616?272    354?926?592\n     [java] SrchNewRdr_500 -  -  -  -  -  -  -  - - - - - -   - -  -   8 -  -  -  500 -  -   806,5 -  -   4,96 - 252?762?128 -  354?926?592\n     [java] SrchTrvNewRdr_300                   -   -   -     -        8       335500    135?891,9       19,75   250?484?240    354?926?592\n     [java] SrchTrvRetNewRdr_100 -  -  -  -  -  - - - - - -   - -  -   8 -  -  209216 -  267?326,0 -  -   6,26 - 245?991?776 -  354?926?592\n     [java] SearchSameRdr_5000_2500/sec_Par     -   -   -     -        8         5000      1?163,3       34,39   250?892?304    355?016?704\n     [java] WarmNewRdr_50_25/sec_Par -  -  -  - - - - - - -   - -  -   8 -  - 1000000 -  507?872,0 -  -  15,75 - 250?855?648 -  355?016?704\n     [java] SrchNewRdr_50_25/sec_Par            -   -   -     -        8           50         25,5       15,69   254?289?584    355?016?704\n     [java] SrchTrvNewRdr_300_150/sec_Par -  -  - - - - - -   - -  -   8 -  -  335500 -  177?807,2 -  -  15,10 - 251?699?584 -  355?016?704\n     [java] SrchTrvRetNewRdr_100_50/sec_Par     -   -   -     -        8       232076    117?106,6       15,85   252?423?376    355?016?704\n\n\nOutput from RAMDirectory:\n[java] ------------> Report Sum By (any) Name (19 about 160153 out of 160153)\n     [java] Operation                       round mrg buf cmpnd   runCnt   recsPerRun        rec/s  elapsedSec    avgUsedMem    avgTotalMem\n     [java] Rounds_8                            0  10  10  true        1     25142792     36?177,3      694,99   119?427?680    182?538?240\n     [java] Populate -  -  -  -  -  -  -  -  -  - - - - - -   - -  -   8 -  -   20003 -  -   482,0 -  - 331,99 - 114?288?472 -  140?156?416\n     [java] CreateIndex                         -   -   -     -        8            1      2?666,7        0,00    48?867?204    124?752?384\n     [java] MAddDocs_20000 -  -  -  -  -  -  -  - - - - - -   - -  -   8 -  -   20000 -  -   499,2 -  - 320,51 - 111?734?320 -  135?969?280\n     [java] AddDoc                              -   -   -     -   160000            1        604,9      264,49    90?860?048    130?812?488\n     [java] Optimize -  -  -  -  -  -  -  -  -  - - - - - -   - -  -   8 -  -  -  - 1 -  -  -  0,7 -  -  11,48 - 123?532?104 -  140?156?416\n     [java] CloseIndex                          -   -   -     -        8            1      8?000,0        0,00   114?288?472    140?156?416\n     [java] OpenReader -  -  -  -  -  -  -  -   - - - - - -   - -  -  16 -  -  -  - 1 -  -   197,5 -  -   0,08 - 113?600?096 -  143?475?712\n     [java] SearchSameRdr_5000                  -   -   -     -        8         5000      1?209,4       33,07   115?720?920    143?314?944\n     [java] CloseReader -  -  -  -  -  -  -  -  - - - - - -   - -  -  16 -  -  -  - 1 -   16?000,0 -  -   0,00 - 102?590?368 -  145?079?552\n     [java] WarmNewRdr_50                       -   -   -     -        8      1000000     65?734,9      121,70   105?734?472    143?314?944\n     [java] SrchNewRdr_500 -  -  -  -  -  -  -  - - - - - -   - -  -   8 -  -  -  500 -  -   417,4 -  -   9,58 - 104?480?168 -  146?795?008\n     [java] SrchTrvNewRdr_300                   -   -   -     -        8       335500    133?532,3       20,10   116?353?456    146?795?008\n     [java] SrchTrvRetNewRdr_100 -  -  -  -  -  - - - - - -   - -  -   8 -  -  209216 -   60?686,3 -  -  27,58 - 124?211?040 -  146?795?008\n     [java] SearchSameRdr_5000_2500/sec_Par     -   -   -     -        8         5000      1?596,0       25,06   114?145?856    146?844?160\n     [java] WarmNewRdr_50_25/sec_Par -  -  -  - - - - - - -   - -  -   8 -  - 1000000 -  105?678,9 -  -  75,70 - 104?830?320 -  146?844?160\n     [java] SrchNewRdr_50_25/sec_Par            -   -   -     -        8           50         25,5       15,70   107?417?728    146?844?160\n     [java] SrchTrvNewRdr_300_150/sec_Par -  -  - - - - - -   - -  -   8 -  -  335500 -  178?635,6 -  -  15,02 - 116?779?312 -  146?835?968\n     [java] SrchTrvRetNewRdr_100_50/sec_Par     -   -   -     -        8       232076    100?569,2       18,46   111?881?152    146?819?584\n\n\n",
            "date": "2007-03-13T02:35:35.047+0000",
            "id": 63
        },
        {
            "author": "Doron Cohen",
            "body": "That's a good point about the task-benchmark karl! \n\nAll 4 ReaderTasks are reusing the reader if it is already open, but if it is not already open, each task opens a private one, and closes it after the task is done. \n\nI now see that the javadocs can be improved here - especially in the reader sub-tasks. I will update the documentation to clarify this point. \n\nAnyhow, for the running tasks to share a reader, the alg part of the .alg file should have something like this:\n\n  OpenReader\n\n  ReaderTaskA\n  ReaderTaskB\n  ReaderYaskC\n\n  CloseReader\n\nThis way all three tasks would share the same, already open, reader.\n",
            "date": "2007-03-13T05:15:55.434+0000",
            "id": 64
        },
        {
            "author": "Karl Wettin",
            "body": "A graph showing performance of hit collection using InstantiatedIndex, RAMDirectory and FSDirectory.\n\nIn essence, there is no great win in pure search time when there are more than 7000 documents. However, retreiving documents is still not associate with any cost what so ever, so in a 250000 sized index that use Lucene for persistency of fields, I still see a boost with 6-10x or so compared to RAMDirectory. \n\ndocuments in corpus \\t  queries per second \n\norg.apache.lucene.store.instantiated.InstantiatedIndex@628704\n\t250\t37530,00\n\t500\t29610,00\n\t750\t22612,50\n\t1000\t19267,50\n\t1250\t16027,50\n\t1500\t14737,50\n\t1750\t13230,00\n\t2000\t12322,50\n\t2250\t11482,50\n\t2500\t10125,00\n\t2750\t9802,50\n\t3000\t8508,25\n\t3250\t8469,80\n\t3500\t7788,61\n\t3750\t5207,29\n\t4000\t5484,52\n\t4250\t4912,50\n\t4500\t4420,58\n\t4750\t4006,49\n\t5000\t4357,50\n\t5250\t3886,67\n\t5500\t3573,93\n\t5750\t3236,76\n\t6000\t3602,10\n\t6250\t3420,00\n\t6500\t3075,00\n\t6750\t2805,00\n\t7000\t2680,98\n\t7250\t2908,55\n\t7500\t2769,46\n\t7750\t2644,86\n\t8000\t2496,25\n\t8250\t2377,50\n\t8500\t2578,71\n\t8750\t2390,11\n\t9000\t2160,00\n\t9250\t2037,96\n\t9500\t1872,19\n\t9750\t2041,38\n\t10000\t1959,12\nCreated 10000 documents\n\norg.apache.lucene.index.facade.RAMDirectoryIndex@af993e\n\t250\t4845,00\n\t500\t3986,01\n\t750\t4330,67\n\t1000\t4682,82\n\t1250\t4148,78\n\t1500\t4847,65\n\t1750\t4535,23\n\t2000\t4192,50\n\t2250\t4203,30\n\t2500\t3695,65\n\t2750\t3742,50\n\t3000\t3485,76\n\t3250\t3470,76\n\t3500\t3525,00\n\t3750\t2877,61\n\t4000\t3221,78\n\t4250\t2983,51\n\t4500\t2982,02\n\t4750\t2724,55\n\t5000\t3092,86\n\t5250\t2646,18\n\t5500\t2940,00\n\t5750\t2709,58\n\t6000\t2423,30\n\t6250\t2602,50\n\t6500\t2305,39\n\t6750\t2462,57\n\t7000\t1815,00\n\t7250\t2431,42\n\t7500\t2171,74\n\t7750\t2297,90\n\t8000\t2134,30\n\t8250\t2308,85\n\t8500\t2038,98\n\t8750\t2231,65\n\t9000\t2097,90\n\t9250\t2041,38\n\t9500\t1819,77\n\t9750\t2102,24\n\t10000\t1876,87\nCreated 10000 documents\n\n\norg.apache.lucene.index.facade.FSDirectoryIndex@4112c0\n\t250\t3448,28\n\t500\t2422,50\n\t750\t2677,50\n\t1000\t2607,39\n\t1250\t2241,92\n\t1500\t2486,27\n\t1750\t2472,53\n\t2000\t1733,52\n\t2250\t2325,00\n\t2500\t2194,21\n\t2750\t1969,55\n\t3000\t2125,75\n\t3250\t2009,00\n\t3500\t1473,08\n\t3750\t1858,14\n\t4000\t1925,57\n\t4250\t1671,66\n\t4500\t1786,25\n\t4750\t1694,15\n\t5000\t1217,63\n\t5250\t1595,11\n\t5500\t1745,75\n\t5750\t1526,18\n\t6000\t1431,78\n\t6250\t1524,66\n\t6500\t1648,35\n\t6750\t1544,23\n\t7000\t1428,22\n\t7250\t1487,29\n\t7500\t1494,02\n\t7750\t1106,13\n\t8000\t1455,00\n\t8250\t1284,86\n\t8500\t1182,63\n\t8750\t1292,33\n\t9000\t1399,70\n\t9250\t1000,00\n\t9500\t1291,04\n\t9750\t1359,56\n\t10000\t1194,62\nCreated 10000 documents",
            "date": "2007-03-17T20:11:10.956+0000",
            "id": 65
        },
        {
            "author": "Karl Wettin",
            "body": "made graph more readable",
            "date": "2007-03-17T20:34:24.604+0000",
            "id": 66
        },
        {
            "author": "Nicolas Lalev\u00e9e",
            "body": "This a very interesting benchmark graph ! Note that there is just a little mistake in there : the labels of the axes are switched.\n\nAnd you said that you still have lot of gain with 250 000 documents because retreiving cost. But if I have to made the choice of having everything in memory, I won't put the data of my own model into Lucene. I will keep them in memory while not transforming them into stored Lucene Document. I will just transform them for indexing purpose and just keep an ID in the Lucene store which will help me map the search result to my own model data. This will avoid the transformation Lucene-Document -> MyModel-Data.\n\n(after relooking at the UML diagram) : Unless you allow to put POJO objects in a Document ?\n",
            "date": "2007-03-18T09:04:52.524+0000",
            "id": 67
        },
        {
            "author": "Karl Wettin",
            "body": "> Nicolas Lalev\u00e9e [18/Mar/07 02:04 AM]\n\n> This a very interesting benchmark graph ! Note that there is just a little mistake in there : the labels of the axes are switched. \n\nThe test is sort of crued, a set of queries with variable complexity that for each iteration is placed on a new IndexSearcher and IndexReader. Index is optimized at all measure points.\n\n> And you said that you still have lot of gain with 250 000 documents because\n> retreiving cost. But if I have to made the choice of having everything in memory, \n> I won't put the data of my own model into Lucene. I will keep them in memory\n> while not transforming them into stored Lucene >Document. I will just transform \n> them for indexing purpose and just keep an ID in the Lucene store which will \n> help me map the search result to my own model data. This will avoid the \n> transformation Lucene-Document -> MyModel-Data.\n\nI can only agree.\n\n>(after relooking at the UML diagram) : Unless you allow to put POJO objects in a Document ? \n\nThat is the hypothesis. I've actually been a bit baffled by the results I've seen the last days while benchmarking. \n\nThe application this was orginially built for (the one with 250 000 documents) is fairly busy, on average one query every 10ms 24/7. Peeks at one every 2ms. On the single machine setup with 4GB and Solaris the CPU went from 90% busy to 90% idle when switching from RAMDirectory to InstantiatedIndex. I can at this point not say if this is due to bad use of Lucene and compensating for that with a crazy solution. But I don't think so. I think I've missed a bunch of benchmark factors.\n\nSince that project, and that was some time ago, I have not implemented any applications with a \"normal\" corpus using InstantiatedIndex. \n\nIt is the backbone of the active cache (also availabe in this patch). I'm sure people made similar things with MemoryIndex. For each batch of new documents inserted, I apply cached queries on the batch-index to detect if the new data would affect the results associated with the cached query. (The cache does other active things too.)\n\nIn the didyoumean issue I use InstantiatedIndex as a speedy a priori index, a small index with feature selected text (common user queries known to be correct, very common phrases in document titles, et c) that is used to build ngrams for token suggestions, build phrase suggestions, rearrange term order in phrases, et c. As these documents are very small (a small phrase) it is some 10x-20x faster than a RAMDirectory at 50 000 documents.\n\n",
            "date": "2007-03-18T15:47:57.885+0000",
            "id": 68
        },
        {
            "author": "Karl Wettin",
            "body": "x/y axis names updates",
            "date": "2007-03-18T15:50:15.066+0000",
            "id": 69
        },
        {
            "author": "Karl Wettin",
            "body": "This is a small and completely isolated version of InstantiatedIndex, the results of my \"last attempt\" thread:\nhttp://www.nabble.com/Last-attempt-tf4153815.html\n\nIt requires no changes to the Lucene core but hogs a bit more RAM and probably depends on your JIT to avoid wasting CPU. So prior required definalization and generalization is replaced by aggregation (strategy pattern). I also had to remove all the polymorphic index handling  (IndexWriterInterface et c), and I have removed the IndexWriter in InstantiatedIndex. One now have to create a new InstantiatedIndex and pass down an IndexReader instead. So there is no appending allowed. Also, there are no locks no more, but that should not be needed anymore.\n\nThe port of the complete test suite from Lucene to the unison index handling has been removed. Ie there are no real test cases that demonstrate this patch. Anything but term vectors and payloads should work great though. The code base is over a year old and these are new features I did not have time to implement or test. \n\nNo new benchmarks. The greatest loss is the loss of features, not CPU and RAM. Perhaps it waste 15% more resources than the previous patch?\n\nAs I personally enjoy the features removed in this patch, I will keep on running Lucene 2.0 and the old version, but this should be easier to understand and maintain if anyone else wants to take a look at it.",
            "date": "2007-08-04T14:28:34.391+0000",
            "id": 70
        },
        {
            "author": "Grant Ingersoll",
            "body": "Hey Karl,\n\nI started to look at this, but there are a few stoppers at this point for me:\n1. No build file\n2. Tests are virtually non-existent\n\nIt could also use some documentation, especially on the how and why of the InstantiatedIndex.\n\nCheers,\nGrant\n\n\n\n\n\n",
            "date": "2007-08-08T01:22:35.518+0000",
            "id": 71
        },
        {
            "author": "Karl Wettin",
            "body": "Grant Ingersoll - 07/Aug/07 06:22 PM\n> 1. No build file\n> 2. Tests are virtually non-existent\n>\n> It could also use some documentation, especially on the how and why of the InstantiatedIndex.\n\nI'll come up with some stuff asap. \n\nAbout tests, the new patch is more or less a redection of the previous patch. The latter contains more or less all tests assimilated to run on instantiated index. WIth the new patch there is no IndexWriter, so I will have to reassimilate it all.\n\nIn the old patch there is a test case that compare two index readers - enumerating all parts of an a priori reader and a test reader comparing the values. It passed in the old patch, so I don't think there is any problem. I'll reintroduce it though. Do you think that would be enough, or do you want the assimilated tests back?\n\nIs the payload API fixed? There is a bunch of TODOs and warnings here and there in the code, the reason for me not implementing  it in this store.",
            "date": "2007-08-08T15:59:55.211+0000",
            "id": 72
        },
        {
            "author": "Grant Ingersoll",
            "body": "On the Payload question, it is still marked as experimental, but if your patch gets in before anyone changes it, the onus is on that person to make sure the change is functional, so I would think you are fine to assume the current payload is fixed for the time being.",
            "date": "2007-08-08T16:16:33.409+0000",
            "id": 73
        },
        {
            "author": "Karl Wettin",
            "body": "Added support for payloads\nReintroduced InstantiatedIndexWriter (no locks!)\nReintroduced TestIndicesEquals\nIntroduced build.xml\nIntroduced pom.xml (this file is missing java 1.5 setting)\nAdded some silly javadocs\n\nIt also hit me that I could have a HashMap<Term, Integer> parallell to the List<Term> orderdTerms. The latter is currently beeing binarysearched in TermEnum, and a HashMap would make it much faster, especially as the index grows. Might speed things up alot.",
            "date": "2007-08-08T21:25:14.106+0000",
            "id": 74
        },
        {
            "author": "Karl Wettin",
            "body": "\n> It also hit me that I could have a HashMap<Term, Integer> parallel to the \n> List<Term> orderdTerms. The latter is currently beeing binarysearched \n> in TermEnum, and a HashMap would make it much faster, especially as\n> the index grows. \n\nJust looked in to this. There is some performance to gain, but not much. I'll do some benches later on and see if it was worth it.\n\nMost binary searches are placed in the IndexWriter, and I honestly don't care too much about make that part faster if it slows down searching or makes it hog more RAM.",
            "date": "2007-08-08T22:59:35.444+0000",
            "id": 75
        },
        {
            "author": "Grant Ingersoll",
            "body": "Should I wait on this until you figure this out?",
            "date": "2007-08-16T00:17:46.731+0000",
            "id": 76
        },
        {
            "author": "Karl Wettin",
            "body": "Grant Ingersoll - 15/Aug/07 05:17 PM\n> Should I wait on this until you figure this out? \n\nPlease don't. I'm just thinking really lound.",
            "date": "2007-08-16T01:43:47.135+0000",
            "id": 77
        },
        {
            "author": "Karl Wettin",
            "body": "I just found a bug that I can not explain. \n\nWhile scoring this one specific phrase query in this one specific corpus of mine, the scorer calls TermPositions.nextPosition() more than TermPositions.freq() times. Never seen this error before, and it does not do this when running against a Directory. TestIndicesEquals does however pass, so it must be me that does not reset currentTermPosition counter, or something along that way.\n\nI have been debugging for hours and hours in the scorer code in order to understand the difference between II and Directory is, but I can't figure it out. Completely lost in this (read: any) scorer code.\n\nIt sure is a show stopper if it sometimes does not work, so I'll try to find the bug. This is the first time I've seen it though. I mean, I do use phrase queries in other places in conjunction with this store, and that makes it even more strange.\n\nI have tried to come up with an isolated test case, but I can't. I can however pass the corpus and code that produce this error to some specific person, but I'm afraid I can't post it here.\n\n\nThere is also a minor TermFreqVector bug that throws a NPE, solved in the next patch.\n\nException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 12\n\tat org.apache.lucene.store.instantiated.InstantiatedTermPositions.nextPosition(InstantiatedTermPositions.java:70)\n\tat org.apache.lucene.search.PhrasePositions.nextPosition(PhrasePositions.java:76)\n\tat org.apache.lucene.search.PhrasePositions.firstPosition(PhrasePositions.java:65)\n\tat org.apache.lucene.search.ExactPhraseScorer.phraseFreq(ExactPhraseScorer.java:34)\n\tat org.apache.lucene.search.PhraseScorer.doNext(PhraseScorer.java:94)\n\tat org.apache.lucene.search.PhraseScorer.next(PhraseScorer.java:81)\n\tat org.apache.lucene.search.DisjunctionSumScorer.initScorerDocQueue(DisjunctionSumScorer.java:105)\n\tat org.apache.lucene.search.DisjunctionSumScorer.next(DisjunctionSumScorer.java:144)\n\tat org.apache.lucene.search.BooleanScorer2.next(BooleanScorer2.java:360)\n\tat org.apache.lucene.search.DisjunctionSumScorer.initScorerDocQueue(DisjunctionSumScorer.java:105)\n\tat org.apache.lucene.search.DisjunctionSumScorer.next(DisjunctionSumScorer.java:144)\n\tat org.apache.lucene.search.BooleanScorer2.score(BooleanScorer2.java:327)\n\tat org.apache.lucene.search.IndexSearcher.search(IndexSearcher.java:146)\n\tat org.apache.lucene.search.Searcher.search(Searcher.java:118)\n\tat org.apache.lucene.search.Searcher.search(Searcher.java:97)",
            "date": "2007-08-17T20:24:25.158+0000",
            "id": 78
        },
        {
            "author": "Karl Wettin",
            "body": "Previously mentioned problems deloused. The phrase (term position) problem turned out to be the constructor InstantiatedIndex(IndexReader) that had a bug, ending up with a index not equal to one created via InstantiatedIndexWriter.\n\nI also did a bunch of tests on how much it would speed up by replacing the binary searches over lists with hash tables (maps). Gained perhaps 5% speed, but lost quite a bit of RAM, so I reverted those things.\n\nDo you want more test cases than the TestIndicesEquals?\n\nPayloads needs to be verified. I never really worked with them, and the Directory-centric test will not be ported easily.",
            "date": "2007-08-17T22:09:55.441+0000",
            "id": 79
        },
        {
            "author": "Grant Ingersoll",
            "body": "If I understand your test correctly, you have gone through and compared term by term, etc. (vectors, etc.)\n\nI would like to see payloads tested as well.\n\nI also think you need a package level javadoc that explains the use cases for this and the basics of using it.\n\nAlso, I notice the caveat about no locking (in the javadocs for InstantiatedIndex) and I notice a TODO as well saying implement locking.  Thoughts on implementing it?",
            "date": "2007-09-22T12:52:06.183+0000",
            "id": 80
        },
        {
            "author": "Karl Wettin",
            "body": "Grant Ingersoll - 22/Sep/07 05:52 AM\n\n> I would like to see payloads tested as well.\n\nI'm new to payloads and don't know what makes sense when it comes to populating the aprioi/test indices.  Any preferences? Or should I just randomly add some payloads to the positions of a couple of terms in a couple of documents?\n\n> package level javadoc\n\nAny comments on how to include graphics in the documentation? (I'm a big fan of UML, you might have noticed there is quite a bit of ASCII class diagram stubs in the javadocs of fields that represent binary associations, association classes and qualifications.) Also, where should I store the XML used to render the graphics? Just pop it all in the src classpath?\n\n> I notice a TODO as well saying implement locking. Thoughts on implementing it?\n\nIt used to be a ReentrantLock, but for some reason I can't seem to recall, this was a bad idea. There are TODO: lock and TODO: release lock tags left throughout the code. I should probably take a look at o.a.l.store.Lock.\n\n\nThere are three more caveats I know of, but I'm not certain how important they are to fix.\n\nIndexReader:\n\n  public Document document(int n, FieldSelector fieldSelector) throws IOException {\n    // todo: it does not make to much sense to use field selector using this implementation,\n    // todo: so it simply ignores this and return everything.\n    return document(n);\n  }\n\n  public Collection getFieldNames(FieldOption fldOption) {\n    if (fldOption != FieldOption.ALL) {\n      throw new IllegalArgumentException(\"Only FieldOption.ALL implemented.\"); // todo\n    }\n\n\nIndexWriter.addDocument does not support readerValue and binaryValue.\n\n        if (field.isTokenized()) {\n          int termCounter = 0;\n          final TokenStream tokenStream;\n          // todo readerValue(), binaryValue()\n          if (field.tokenStreamValue() != null) {\n\n",
            "date": "2007-09-23T07:33:40.533+0000",
            "id": 81
        },
        {
            "author": "Hoss Man",
            "body": "> Any comments on how to include graphics in the documentation? (I'm a big fan of UML, \n> you might have noticed there is quite a bit of ASCII class diagram stubs in the javadocs of \n> fields that represent binary associations, association classes and qualifications.) Also, where \n> should I store the XML used to render the graphics? Just pop it all in the src classpath?\n\nimages that you want to embed in (or files you want to link to from) javadocs should live in a \"doc-files\" directory in the package....\n\nhttp://java.sun.com/j2se/javadoc/writingdoccomments/#images\n\n...iwould put the XML source for the image in there as well, and put a link to it in the javadocs as well.",
            "date": "2007-09-23T21:26:33.844+0000",
            "id": 82
        },
        {
            "author": "Karl Wettin",
            "body": "New in this patch:\n\n * Payloads added to TestIndicesEquals\n * Package level java docs with UMLet class diagram\n * Some additional todo-tags in the code that shows what can be improved\n\nI've noticed that there are some differences in the behavior of IndexWriter and InstantiatedIndexWriter when a document containing multiple fields with the same name but different settings, such as:\n\n{code}\n d.add(new Field(\"f\", \" All work and no play makes Jack a dull boy\", Field.Store.YES, Field.Index.TOKENIZED, Field.TermVector.WITH_POSITIONS_OFFSETS));\n d.add(new Field(\"f\", \" All work and no play makes Jack a dull boy\", Field.Store.NO));\n d.add(new Field(\"f\", \" All work and no play makes Jack a dull boy\", Field.Store.YES, Field.Index.NO_NORMS, Field.TermVector.NO));\n{code}\n\nWould this be considered an invalid document? Should there be a term vector or not? Or perhaps just term vector for the tokens in the first field?",
            "date": "2007-09-27T23:49:01.285+0000",
            "id": 83
        },
        {
            "author": "Karl Wettin",
            "body": "Oups, the patch is of course granted ASF licence.",
            "date": "2007-09-27T23:50:56.774+0000",
            "id": 84
        },
        {
            "author": "Karl Wettin",
            "body": "In this patch:\n\n * Minor discrepancy in IndexReader#norms(String field, byte[] bytes, int offset) between SegmentReader and InstantiatedIndexReader fixed and demonstrated in TestIndicesEquals.\n\nhttp://www.nabble.com/norms%28String-field%2C-byte---bytes%2C-int-offset%29-tf4580460.html#a13075367\n\n * Updated maven pom and fixed some typos in documentation.",
            "date": "2007-10-08T00:24:49.359+0000",
            "id": 85
        },
        {
            "author": "Karl Wettin",
            "body": "In this path:\n\n * As the Segment-dito, non-mapper term vector methods returns null rather than throwing NPE when term vector is not available.",
            "date": "2007-10-17T03:17:49.580+0000",
            "id": 86
        },
        {
            "author": "Karl Wettin",
            "body": "In this patch:\n\n * IndexReader.terms(Term) optimization, initial seek now jit-call away given the term exists, rather than using binary search.\n * A handful of minor optimizations\n * IndexReader.version() mimics Segment-dito\n\n ",
            "date": "2007-10-19T14:00:19.306+0000",
            "id": 87
        },
        {
            "author": "Karl Wettin",
            "body": "In this patch:\n\n * Replaced all List<T> with T[] as Array.binarySearch is 20% faster than Collections.binarySearch.\n * Ad hoc binarySearch using variable pivot increase speed of TermDocs.skipTo  20%-400%, courtesy of Olivier Chafik.\n * Default InstantiatedWriter.mergeFactor changed from 1 to 2500 ;-)",
            "date": "2007-10-21T15:44:38.495+0000",
            "id": 88
        },
        {
            "author": "Grant Ingersoll",
            "body": "{quote}\ncourtesy of Olivier Chafik\n{quote}\n\nWhat does this mean?  He contributed the code personally or you got it from him?  In other words, do you have the authority to assign the ASF copyright for said code?\n\nFYI, the patch applies clean and compiles.  I still have some benchmarking to do, but would like to commit.",
            "date": "2007-12-10T22:11:56.517+0000",
            "id": 89
        },
        {
            "author": "Karl Wettin",
            "body": "{quote}\nGrant Ingersoll - 10/Dec/07 02:11 PM\n> courtesy of Olivier Chafik\nWhat does this mean? He contributed the code personally or you got it from him? In other words, do you have the authority to assign the ASF copyright for said code?\n{/quote}\n\nYes, \n\nhttp://ochafik.free.fr/blog/?p=106\n\n\nKarl Wettin dit: \n20 October 2007 at 7:54 pm\nHi Olivier,\n\nI was just going nuts over the lack of offset and length in Collections.binarySearch. I was thinking that perhaps a subList would be OK, but it turns out that the overhead of AbstractList.subList (in my case an ArrayList) is huge. It takes 1/3 the time to search the complete subList owner of 5000 instanes compared to instantiate and binarySearch a subListIn(2500, 5000).\n\nGoogle suggested your blog post.\n\nI have based some non-released optimization in http://issues.apache.org/jira/browse/LUCENE-550 on your code. Would you mind donating it to the Apache Software Foundation? Lucene does not state author credits in source code, only in CHANGES.TXT.\n\nLUCENE-550 is an alternative RAM index store that is up to 100x faster than the standard RAMDirectory and it is built to support my machine learning projects such as http://issues.apache.org/jira/browse/LUCENE-626 and http://issues.apache.org/jira/browse/LUCENE-1025\n\nzOlive dit: \n21 October 2007 at 9:02 am\nHi Karl,\n\nThanks for your message, I'm happy to hear that someone actually made some use of this code !\nApart from the offset feature, the only specificity of my code is its relative speed for lookups in sorted integer lists, which I'm unsure whether it's exactly your use case or not.\nHowever, I will be more than pleased to contribute this tiny piece of code to Apache, and I must say I'm a bit surprised that there isn't such a method in any of their projects yet (say, in Jakarta Commons - http://commons.apache.org/collections/).\nWhere shall I post it to ?\n\nKarl Wettin dit: \n21 October 2007 at 4:32 pm\nThanks!\n\nYou don't need to post it anywhere, I have simply pasted it in this class of mine and adapted it to fit my needs.\n\nIt is indeed an int[] (actually MyClass[].getInt()) I'm seeking in, the variable pivot is most welcome.",
            "date": "2007-12-10T22:27:10.463+0000",
            "id": 90
        },
        {
            "author": "Karl Wettin",
            "body": "I was poking around in the javadocs of this and came to the conclution that InstantiatedIndexWriter is depricated code, that it is enough one can construct InstantiatedIndex using an optimized IndexReader. This makes all InstantiatedIndexes immutable. That makes the no-locks caveat to go away.\n\nAlso, it is a hassle to make sure that InstantiatedIndexWriter work just as IndexWriter does.\n\nIn the future, a segmented Directory-facade could be built on top of this, where each InstantiatedIndex is a segment created by IndexWriter flush. It would potentially be slower to populate this, but it would be compatible with everything. Adding more than one segement will requite merging and optimizing indices forth and back in RAMDirectories a but, but InstantiatedIndexes are usually quite small.\n\nIt feels like much of that code is already there.\n\nOn the matter of RAM consumption, using a profiler I recently noticed a 3.2MB directory of 3-5;3-3;3-5 ngrams with term vectors consumed something like 35MB RAM when loaded to an InstantiatedIndex.\n\n\n",
            "date": "2008-01-14T15:47:55.235+0000",
            "id": 91
        },
        {
            "author": "Grant Ingersoll",
            "body": "Did zOlive ever post his code Jakarta Commons?  Without him actually doing it, I don't know that it is good enough legally to accept it.\n\nAlso, is your last comment such that you think there is a new patch?",
            "date": "2008-02-24T03:18:08.341+0000",
            "id": 92
        },
        {
            "author": "Karl Wettin",
            "body": "{quote}\nDid zOlive ever post his code Jakarta Commons? Without him actually doing it, I don't know that it is good enough legally to accept it.\n{quote}\n\nHe did not. Should I ask him to post the code as an ASL-tagged attachment to this issue? Or is commons a better place?\n\n{quote}\nAlso, is your last comment such that you think there is a new patch?\n{quote}\n\nNot anytime soon. They are only ideas that could make it a bit less ad hoc. But I'm actually quite happy with the way it works now. The code has sucessfully been used in a handful of commercial projects.",
            "date": "2008-02-24T20:27:23.766+0000",
            "id": 93
        },
        {
            "author": "Grant Ingersoll",
            "body": "\n\n\nCommons would be all right, since this is a contrib and it can have  \ndependencies.  But putting it on this patch would be just as useful.   \nYour call.  Putting it into Lucene makes it more likely that it will  \nbe addressed as part of this patch, and thus committed.  Going the  \nCommons route is probably for the greater good, but we may not see it  \nfor a good long time, depending on their commit/release needs.\n\n\n\nOK.  Once we get the legal piece resolved, I am going to commit.\n\n-Grant\n",
            "date": "2008-02-24T21:08:14.992+0000",
            "id": 94
        },
        {
            "author": "Olivier Chafik",
            "body": "Here is an enhanced binarySearch method for int arrays, which I wrote and wish to donate to the ASF (for the Lucene project or any other purpose), following Karl Wettin's request.\nThis code was initially published on my blog : http://ochafik.free.fr/blog/?p=106\nHave fun with it !\n--\nOlivier Chafik",
            "date": "2008-02-25T18:38:31.470+0000",
            "id": 95
        },
        {
            "author": "Grant Ingersoll",
            "body": "Cleaned up a few things, added CHANGES.txt, added ASL to a file.    I'll commit tomorrow, pending any more feedback.",
            "date": "2008-03-08T23:36:57.316+0000",
            "id": 96
        },
        {
            "author": "Karl Wettin",
            "body": "Added more javadocs.\nThe patch is not sticky enough for instantiated/docs/classdiagram.jpg.\n",
            "date": "2008-03-09T03:09:22.184+0000",
            "id": 97
        },
        {
            "author": "Karl Wettin",
            "body": "Some dull colors, rendered via PDF to PNG and then scaled to fit 1024x768. Also softscaled in package.html, but linked to when clicked on.",
            "date": "2008-03-09T04:44:11.333+0000",
            "id": 98
        },
        {
            "author": "Grant Ingersoll",
            "body": "Committed revision 636745.  Thanks Karl!",
            "date": "2008-03-13T12:33:55.992+0000",
            "id": 99
        }
    ],
    "component": "core/store",
    "description": "Represented as a coupled graph of class instances, this all-in-memory index store implementation delivers search results up to a 100 times faster than the file-centric RAMDirectory at the cost of greater RAM consumption.\n\nPerformance seems to be a little bit better than log2n (binary search). No real data on that, just my eyes.\n\nPopulated with a single document InstantiatedIndex is almost, but not quite, as fast as MemoryIndex.    \n\nAt 20,000 document 10-50 characters long InstantiatedIndex outperforms RAMDirectory some 30x,\n15x at 100 documents of 2000 charachters length,\nand is linear to RAMDirectory at 10,000 documents of 2000 characters length.\n\nMileage may vary depending on term saturation.\n\n\n",
    "hasPatch": true,
    "hasScreenshot": true,
    "id": "LUCENE-550",
    "issuetypeClassified": "RFE",
    "issuetypeTracker": "RFE",
    "priority": "Major",
    "product": "LUCENE",
    "project": "LUCENE",
    "summary": "InstantiatedIndex - faster but memory consuming index",
    "systemSpecification": true,
    "version": "2.0.0"
}