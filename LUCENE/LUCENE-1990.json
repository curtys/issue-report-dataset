{
    "comments": [
        {
            "author": "Fuad Efendi",
            "body": "\nSpecifically for FieldCache, let's see... suppose Field may have 8 different values, and number of documents is high.\n\n{code}\nValue0  0  1  0  0  0  0  0   0  1  0  0  0  0  0 ...  \nValue1  1  0  1  0  0  0  0   0  0  0  0  0  0  0 ...  \nValue2  0  0  0  1  1  0  0   0  0  0  0  0  0  0 ...  \nValue3  0  0  0  0  0  0  0   0  0  0  0  1  0  0 ...  \nValue4  0  0  0  0  0  0  1   0  0  0  0  0  0  0 ...  \nValue5  0  0  0  0  0  1  0   0  0  0  1  0  1  0 ...  \nValue6  0  0  0  0  0  0  0   1  0  1  0  0  0  0 ...  \nValue7  0  0  0  0  0  0  0   0  0  0  0  0  0  1 ...  \n{code}\n\n- represented as Matrix (or as a Vector); for instance, first row means that Document1 and Document8 have Value0.\n\nAnd now, if we go \"horizontally\" we will end up with 8 arrays of int[]. What if we go \"vertically\"? Field could be encoded as 3-bit (8 different values).\n\nCONSTRAINT: specifically for FieldCache, each Column must have the only \"1\".\n\nAnd we can end with array of 3-bit values storing position in a column! Size of array is IndexReader.maxDoc().\n\n\nhope I am reinventing bycycle :)\n\nP.S.\nOf course each solution has pros and cons, I am trying to focus on FieldCache specific use cases.\n\n1. For a given document ID, find a value for a field\n2. For a given query results, sort it by a field values\n3. For a given query results, count \"facet\" for each field value\n\nI don't think such naive compression is slower than abstract int[] arrays... and we need to change public API of field cache too: if method returns int[] we are not saving any RAM.\n\nBetter is to compare with SOLR use cases and to make API closer to real requirements; SOLR operates with some bitsets instead of arrays...",
            "date": "2009-11-10T14:00:42.568+0000",
            "id": 0
        },
        {
            "author": "Earwin Burrfoot",
            "body": "bq. hope I am reinventing bycycle\nI believe some databases do that.",
            "date": "2009-11-11T22:46:05.032+0000",
            "id": 1
        },
        {
            "author": "Fuad Efendi",
            "body": "Suttiwat sent me a link:\nhttp://blog.juma.me.uk/2008/10/14/32-bit-or-64-bit-jvm-how-about-a-hybrid/\n\nThis is vendor-specific, and possibly may cause unexpected problems, but we can try in some specific cases:\n\"Compressed Oops have been included (but disabled by default) in the performance release JDK6u6p (requires you to fill a survey), so I decided to try it in an internal application and compare it with 64-bit mode and 32-bit mode.\"\n\n-XX:+UseCompressedOops\n\nThere are other vendors around too such as Oracle JRockit which is much faster server-side... ",
            "date": "2009-11-12T17:02:09.533+0000",
            "id": 2
        },
        {
            "author": "Toke Eskildsen",
            "body": "I have very recently done some experiments with random-access packed positive integer arrays (we could also call them unsigned). The basic approach is to put the bits after each other in an int- or long-array, then extract the value by shifting and masking. Unfortunately I have not been able to determine a single winning strategy for space/speed trade-offs.\n\nI've tried four simple implementations:\n\n1. Pack the bits right after each other.\n2. Pack the bits right after each other but allow only 1, 2, 4, 8, 16 or 32 as value-bits.\n3. Wrap an int[] or long[] and store the values directly (for comparison with 1 & 2).\n4. Use int[] directly without any wrapping.\n\n(Code can be found at http://summa.svn.sourceforge.net/viewvc/summa/trunk/Common/src/dk/statsbiblioteket/summa/common/util/bits/ where #1 is BitsArrayPacked, #2 is BitsArrayAligned and #3 is BitsArrayInt)\n\nThe obvious benefit from #2 is that the bits for values are always contained in a single block (int or long), which reduces the amount of operations for set and get considerably. Unfortunately this means that as soon as a value greater than 65535 needs to be stored, the internal representation will require 32 bits/value. This means no space-benefit compared to #3 while the speed penalty remains. A hybrid approach might be considered where the implementation is determined by the number of bits needed to store a value.\n\nI've done some performance tests of the implementations on an aging 1.8GHz single-core laptop (Dell 820). The code can be found at http://summa.svn.sourceforge.net/viewvc/summa/trunk/Common/test/dk/statsbiblioteket/summa/common/util/bits/BitsArrayPerformanceTest.java?revision=2038&view=markup\n\nIn the tables below, the measurements for Packed, Aligned, Int, Constant and int[] are the total time in milliseconds to perform actionCount actions (either read or write). Random numbers (using the same seed) were used for index as well as value and the overhead of constructing the random numbers were subtracted from the measurements. \"Constant\" is a dummy where no values are stored and the same value is always returned on a get. It is used to measure method-call overhead.\n\nFor arrays of 10M values, 6-33 million values can be read or written per second. If this is within acceptable limits, I'd be happy to try and make a contribution to Lucene based on the code. However, I probably won't find the time before February or March 2010.\n\n{code}\nactionCount arrayLength  actionType    valueMax  Packed(#1) Aligned(#2)     Int(#3)    Constant   int[](#4)\n   10000000     1000000       write           1         583         416         984         254         635\n   10000000     1000000       write          15         594         499        1172         286         843\n   10000000     1000000       write         255         604         478        1057         213         656\n   10000000     1000000       write         256         734         765        1062         109         729\n   10000000     1000000       write       65535        1036         802        1124         417         734\n   10000000     1000000       write       65536        1015        1130        1072         172         781\n   10000000     1000000       write     2097151        1020        1187        1052         223         614\n   10000000     1000000       write  2147483646        1136        1073         839          73         719\n   10000000     1000000        read           1         286         203         786         104           0\n   10000000     1000000        read          15         291         182         859          78           0\n   10000000     1000000        read         255         672         494         989          67           0\n   10000000     1000000        read         256         568         729        1104          93           0\n   10000000     1000000        read       65535         833         755        1088          99           0\n   10000000     1000000        read       65536         947         974        1062         104           0\n   10000000     1000000        read     2097151         999         963        1062          88           0\n   10000000     1000000        read  2147483646        1349         869        1260          84           0\n\n   10000000    10000000       write           1         833         568        1458         239        1229\n   10000000    10000000       write          15        1427        1255        1432         276        1615\n   10000000    10000000       write         255        1599        1578        1448         250        1244\n   10000000    10000000       write         256        1656        1520        1317         109        1109\n   10000000    10000000       write       65535        1734        1630        1385         245        1307\n   10000000    10000000       write       65536        1718        1640        1395         182        1208\n   10000000    10000000       write     2097151        1807        1781        1447         250        1291\n   10000000    10000000       write  2147483646        1718        1599        1281          73        1099\n   10000000    10000000        read           1         562         296        1301         109           0\n   10000000    10000000        read          15        1187        1198        1322          83           0\n   10000000    10000000        read         255        1421        1432        1526          99           0\n   10000000    10000000        read         256        1521        1583        1588         104           0\n   10000000    10000000        read       65535        1578        1427        1374          31           0\n   10000000    10000000        read       65536        1634        1499        1489         113           0\n   10000000    10000000        read     2097151        1625        1374        1468         224           0\n   10000000    10000000        read  2147483646        1609        1349        1499          83           0\n{code}\n",
            "date": "2009-12-30T03:39:12.374+0000",
            "id": 3
        },
        {
            "author": "Michael McCandless",
            "body": "These are great results -- thanks Toke!\n\nWhat's the difference between the two \"sections\" of your results?  The bottom section seems to have slower times overall than the top one.\n\nIt's curious that \"aligned\" isn't always a win.\n\nFor the packed case, did you generate specialized code for each of the cases?  I wonder how much / if that'd really help in practice.\n\nFor the standard codec's terms dict, my guess is we'd just go with packed ints.",
            "date": "2010-01-01T12:01:23.485+0000",
            "id": 4
        },
        {
            "author": "Toke Eskildsen",
            "body": "The first section if for 1M values in the structure, the second is for 10M. As the CPU on the test-machine (Intel T2400) has only 2MB of level 2 cache, the increased processing time for the seemingly same amount of work is an effect of more cache-misses.\n\nCaching also accounts for why the packed version is sometimes better than the aligned. For values representable as 9 or 17 bits, the aligned version needs 16 and 32 bits respectively. In the case with 10M values, the packed version uses 1.1MB and 2.1MB for 9 and 17 bits respectively, while the aligned uses 2MB and 4MB respectively. The simpler logic of the aligned version does not compensate enough for the higher amount of trips around main memory.\n\nI did not generate any specialized code for the aligned case: No matter the number of bits/value, the amount of shifts, masks and ors is always the same. If the number of bits/value is known beforehand, specialized cases should be used (I made a factory that selects between packed, aligned and direct (#3), depending on the number of bits/value). The reason for not doing so in the first place is that I wanted to let the structure auto-adjust the bits/value when a new value was added. Having different implementations encapsulated in the same class means another level of indirection or conditionals, both of which I wanted to avoid for performance reasons. That being said, I haven't tested how much of a penalty this would be.\n\nThe standard use case seems to be some sort of update-round, after which no updates are performed. Having a cleanupAndOptimize-call that potentially creates a new and optimized structure, would fit well into this and would avoid the indirection / conditional penalty.\n\nA whole other matter is long vs. ints. I've tried using longs instead of ints as the backing array and the penalty on my 32bit processor was very high (I need to make some tests on this). If it must be possible to set and get longs, it's hard to avoid using long[] as the internal structure, but if ints are accepted as the only valid values, selecting long[] as backing array for 64 bit machines and int[] for 32 bit, might be the solution.\n\nAll this calls for a factory-approach to hide the fairly complex task of choosing the right implementation.",
            "date": "2010-01-02T15:03:10.843+0000",
            "id": 5
        },
        {
            "author": "Toke Eskildsen",
            "body": "I made some small tweaks to improve performance and added long[]-backed versions of Packed (optimal space) and Aligned (no values span underlying blocks), the ran the performance tests on 5 different computers. It seems very clear that level 2 cache (and presumably RAM-speed, but I do not know how to determine that without root-access on a Linux box) plays a bigger role for access speed than mere CPU speed. One 3GHz with 1MB of level 2 cache was about half as fast than a 1.8GHz laptop with 2MB of level 2 cache.\n\nThere is a whole lot of measurements and it is getting hard to digest. I've attached logs from the 5 computers, should anyone want to have a look. Some observations are:\n\n1. The penalty of using long[] instead of int[] on my 32 bit laptop depends on the number of values in the array. For less than a million values, it is severe: The long[]-version if 30-60% slower, depending on whether packed or aligned values are used. Above that, it was 10% slower for Aligned, 25% slower for Packed.\nOn the other hand, 64 bit machines dos not seem to care that much whether int[] or long[] is used: There was 10% win for arrays below 1M for one machine, 50% for arrays below 100K for another (8% for 1M, 6% for 10M) for another and a small loss of below 1% for all lenghts above 10K for a third.\n\n2. There's a fast drop-off in speed when the array reaches a certain size that is correlated to level 2 cache size. After that, the speed does not decrease much when the array grows. This also affects direct writes to an int[] and has the interesting implication that a packed array out-performs the direct access approach for writes in a number of cases. For reads, there's no contest: Direct access to int[] is blazingly fast.\n\n3. The access-speed of the different implementations converges when the number of values in the array rises (think 10M+ values): The slow round-trip to main memory dwarfs the logic used for value-extraction. \n\nObservation #3 supports Mike McCandless choice of going for the packed approach and #1 suggests using int[] as the internal structure for now. Using int[] as internal structure makes if unfeasible to accept longs as input (or rather: longs with more than 32 significant bits). I don't know if this is acceptable?",
            "date": "2010-01-04T14:21:47.874+0000",
            "id": 6
        },
        {
            "author": "Michael McCandless",
            "body": "bq. The first section if for 1M values in the structure, the second is for 10M. As the CPU on the test-machine (Intel T2400) has only 2MB of level 2 cache, the increased processing time for the seemingly same amount of work is an effect of more cache-misses.\n\nGot it.\n\nbq. Caching also accounts for why the packed version is sometimes better than the aligned. For values representable as 9 or 17 bits, the aligned version needs 16 and 32 bits respectively. In the case with 10M values, the packed version uses 1.1MB and 2.1MB for 9 and 17 bits respectively, while the aligned uses 2MB and 4MB respectively. The simpler logic of the aligned version does not compensate enough for the higher amount of trips around main memory.\n\nOK, though, I think we should somehow exclude these CPU cache effects\nfrom the test.  In a real production situation, lots of other things\nare competing for that cache, so I think the mostly-cache-miss case is\nmost realistic here.\n\nActually a good way to do that is to test it in a wider context, eg\nonce I can get LUCENE-2186 \"integrated\", we can test sorting by int\nfield with these different ways of encoding.\n\n{quote}\nI did not generate any specialized code for the aligned case: No matter the number of bits/value, the amount of shifts, masks and ors is always the same. If the number of bits/value is known beforehand, specialized cases should be used (I made a factory that selects between packed, aligned and direct (#3), depending on the number of bits/value).\n{quote}\n\nOK I have a start at this under LUCENE-2186.  I'll try to clean up &\npost here...\n\n{quote}\nThe reason for not doing so in the first place is that I wanted to let the structure auto-adjust the bits/value when a new value was added. Having different implementations encapsulated in the same class means another level of indirection or conditionals, both of which I wanted to avoid for performance reasons. That being said, I haven't tested how much of a penalty this would be.\n\nThe standard use case seems to be some sort of update-round, after which no updates are performed. Having a cleanupAndOptimize-call that potentially creates a new and optimized structure, would fit well into this and would avoid the indirection / conditional penalty.\n{quote}\n\nI think the writing API can be a write-once API, where I declare the\nmaxValue I will write.  This fits with the indexing chain, where we\nbuffer values in RAM and then flush to the segmetn files.\n\nThis way we don't need the complexity of having to resize the bits\ninternally when a new max value is seen.\n\nSo, the factory would take number of values we will write, the max\nvalue, and I guess an enum for Packed/Aligned/DedicatedArray, and\nreturn a simple writer that just exposes an \"add(long value)\" method?\n\nbq. A whole other matter is long vs. ints. I've tried using longs instead of ints as the backing array and the penalty on my 32bit processor was very high (I need to make some tests on this). If it must be possible to set and get longs, it's hard to avoid using long[] as the internal structure, but if ints are accepted as the only valid values, selecting long[] as backing array for 64 bit machines and int[] for 32 bit, might be the solution.\n\nHmm... I guess we could still support values requiring more than 32\nbits, encoded into int[], but it's more hairy as the value could span\n2 or 3 ints.\n\nProbably we should specialize/default the factory selection based on\nwhether the JVM is 32/64 bit?  And, whether the bit size is <= 32.\n\nbq. All this calls for a factory-approach to hide the fairly complex task of choosing the right implementation.\n\nYes.\n\n{quote}\nI made some small tweaks to improve performance and added long[]-backed versions of Packed (optimal space) and Aligned (no values span underlying blocks), the ran the performance tests on 5 different computers. It seems very clear that level 2 cache (and presumably RAM-speed, but I do not know how to determine that without root-access on a Linux box) plays a bigger role for access speed than mere CPU speed. One 3GHz with 1MB of level 2 cache was about half as fast than a 1.8GHz laptop with 2MB of level 2 cache.\nThere is a whole lot of measurements and it is getting hard to digest. I've attached logs from the 5 computers, should anyone want to have a look. Some observations are:\n\n1. The penalty of using long[] instead of int[] on my 32 bit laptop depends on the number of values in the array. For less than a million values, it is severe: The long[]-version if 30-60% slower, depending on whether packed or aligned values are used. Above that, it was 10% slower for Aligned, 25% slower for Packed.\nOn the other hand, 64 bit machines dos not seem to care that much whether int[] or long[] is used: There was 10% win for arrays below 1M for one machine, 50% for arrays below 100K for another (8% for 1M, 6% for 10M) for another and a small loss of below 1% for all lenghts above 10K for a third.\n\n2. There's a fast drop-off in speed when the array reaches a certain size that is correlated to level 2 cache size. After that, the speed does not decrease much when the array grows. This also affects direct writes to an int[] and has the interesting implication that a packed array out-performs the direct access approach for writes in a number of cases. For reads, there's no contest: Direct access to int[] is blazingly fast.\n\n3. The access-speed of the different implementations converges when the number of values in the array rises (think 10M+ values): The slow round-trip to main memory dwarfs the logic used for value-extraction.\n\nObservation #3 supports Mike McCandless choice of going for the packed approach and #1 suggests using int[] as the internal structure for now. Using int[] as internal structure makes if unfeasible to accept longs as input (or rather: longs with more than 32 significant bits). I don't know if this is acceptable?\n{quote}\n\nI think we should agree on an API that LUCENE-2186 can use to\nwrite/read packed ints, then get our two patches talking.  I'll pull\nout the barebones packed ints I'm currently using, and post\nhere... then let's merge/iterate to a common API, so I can cutover to\nthe patch from here in LUCENE-2186?\n",
            "date": "2010-01-13T12:00:22.447+0000",
            "id": 7
        },
        {
            "author": "Michael McCandless",
            "body": "How about something like this API, for writing packed ints:\n\n{code}\nabstract class Writer {\n  public abstract void add(long v) throws IOException;\n  public abstract void finish() throws IOException;\n}\n{code}\n\nthen a factory:\n\n{code}\nenum Mode {Packed, Aligned, FixedArray};\n\npublic static Writer getWriter(IndexOutput out, int valueCount, long maxValue, Mode mode);\n{code}\n\n(we can iterate on the names... always the hardest part).\n\nPacked means full bit packing (most space efficient, but slowest\ndecode time), Aligned might waste some bits (eg for nbits=4, that's\nnaturally aligned, but for nbits=7, we'd waste 1 bit per long,\nFixedArray (which'd use byte[], short[], int[], long[]) would\npotentially waste the most bits but have the fastest decode.\n\nIf nbits happens to be 8, 16, 32, 64, the factory should just always\nFixedArray I think?  And of course powers of two will automatically be\nAligned (with the per-nbits specialized code).\n\nWew can also default impls to underlying int[] vs long[] backing store\ndepending on 54/32 bit jre, and, nbits.  If jre is 32 bit but nbits is\n> 32 bit I think we just use long[] backing.\n\nFor reading, a similar API:\n\n{code}\nabstract class Reader {\n  public abstract long get(index);\n}\n\npublic static Reader getReader(IndexInput in);\n{code}\n",
            "date": "2010-01-13T12:09:36.479+0000",
            "id": 8
        },
        {
            "author": "Michael McCandless",
            "body": "Attached patch with my current roughed up approach for packed ints\n(from LUCENE-2186).\n\nLet's try to standardize the API, then merge the two approaches, then\nI'll cutover with LUCENE-2186.\n\nIt includes gen.py, which autogens dedicated decoders for each of the\nnbits cases, excluding 8, 16, 32, 64 bits, since these are done with\ndedicated array reader impls.\n\nIt uses a single writer (I don't think we need specialized writers),\nbut the writer encodes in the same byte order as\nIndexOutput.writeLong, so that the byte order matches the dedicated\narray reader impls.\n\nIt only encodes into long[] -- we should create cases for int[]\n(selected by the factory depending on 32 vs 64 bit jre).\n\nWe should also explore just reading in a full byte[] and using\nInt/Short/Long buffer to decode.  This API should also allow for a\nfuture mmap impl as well.\n\nProbably we should name all of these UnsignedPackedInts, since they\nrequire values >= 0.  (Hmm, though, the 64 bit case is tricky -- I\nguess we make an exception for that case).\n",
            "date": "2010-01-13T12:22:15.426+0000",
            "id": 9
        },
        {
            "author": "Toke Eskildsen",
            "body": "Introducing yet another level of indirection and making a byte/short/int/long-prvider detached from the implementation of the packed values it tempting. I'm fairly afraid of the overhead of the extra method-calls, but I'll try it and see what happens.\n\nI've read your (Michael McCandless) code an I can see that the tiny interfaces for Reader and Writer works well for your scenario. However, as the Reader must have (fast) random access, wouldn't it make sense to make it possible to update values? That way the same code can be used to hold ords for sorting and similar structures.\n\nInstead of Reader, we could use\n\n{code}\nabstract class Mutator {\n  public abstract long get(int index);\n  public abstract long set(int index, long value);\n}\n{code}\n\n...should the index also be a long? No need to be bound by Java's 31-bit limit on array-length, although I might very well be over-engineering here.\n\nThe whole 32bit vs. 64bit as backing array does present a bit of a problem with persistence. We'll be in a situation where the index will be optimized for the architecture used for building, not the one used for searching. Leaving the option of a future mmap open means that it is not possible to do a conversion when retrieving the bits, so I have no solution for this (other than doing memory-only).",
            "date": "2010-01-19T23:46:20.228+0000",
            "id": 10
        },
        {
            "author": "Michael McCandless",
            "body": "bq.Introducing yet another level of indirection and making a byte/short/int/long-prvider detached from the implementation of the packed values it tempting.\n\nYou mean the layer that stores the minValue, so that the full range is\nsupported?  I actually think we should absorb that into packed ints,\nso it's only one method call per lookup, and specialize the \"positive\nonly\" cases to avoid the extra add per lookup.\n\nWith that fix, it's still a method call per lookup, but I don't see\nhow we can get away from that, unless we allow for exposure of the raw\narray for the no-packing cases (which we could consider...).\n\nRemember we use packed ints in places where we can accept some loss of\nCPU perf. for improvements in RAM usage (see the comment I just added\nto LUCENE-2186).\n\nbq.  However, as the Reader must have (fast) random access, wouldn't it make sense to make it possible to update values?\n\nYeah, we do eventually want CSF to be updateable, but I don't think we\nneed this for phase 1?  Likewise, I think all we need now for Lucene\nis a \"WriteOnceWriter\", not a \"RandomAccessWriter\".  Ie, you open a\nwriter, you add (sequentially) all values, you close.\n\nbq. ...should the index also be a long?\n\nI would stick with int now (we are doing this for Lucene, whose docIDs\nare still ints...).  Design for today.\n\nbq. The whole 32bit vs. 64bit as backing array does present a bit of a problem with persistence. We'll be in a situation where the index will be optimized for the architecture used for building, not the one used for searching. Leaving the option of a future mmap open means that it is not possible to do a conversion when retrieving the bits, so I have no solution for this (other than doing memory-only).\n\nI'm confused -- a future mmap impl shouldn't put pressure on the file\nformat used by packed ints today?  Ie, a future mmap impl can use a\ntotally different format than the designed-to-be-slurped-into-RAM\nformat for packed ints, today?\n\nAlso, what do you mean by optimized for building not searching?\n\nNote that on 32 bit machines, if there is actually a gain, we can make\na backing store with ints yet still allow for storage of nbits>32?  It\n\"just\" means a value may be split across 2 or 3 values?\n",
            "date": "2010-01-20T10:16:40.222+0000",
            "id": 11
        },
        {
            "author": "Paul Elschot",
            "body": "I've made a remark at LUCENE-1410 (a first attempt at a PFOR implementation) about the header structure for encoding this.\nOne thing that is not covered here is how to deal with input arrays with intermediate length that are shorter than 32 and longer than 3 or 4. Shorter ones can easily be encoded as vByte.\nSimple9 might be a solution, but it has only 28 data bits and 9 different encoding cases so it appears to be somewhat small.\nThere is first attempt at Simple9 at LUCENE-2189.\n\nSince the discussion here is on alignment (int/long) I'm wondering how (and whether) to go from the current byte aligned structures to int aligned. Using aligned ints would save the shifting done at IndexInput.getInt() that reads 4 bytes and shifts them into place to create an int from them.\nSimple9 can be int aligned and I'd like to add bigger variations of that, but peferably only ones that add a multiple of 4 bytes.\n\nSo would make sense to add functionality to IndexInput and IndexOutput to allow int aligned access?\nAre java's data streams and/or nio buffers smart enough to avoid the byte shifting for ints in such cases?\n",
            "date": "2010-01-20T13:29:51.888+0000",
            "id": 12
        },
        {
            "author": "Yonik Seeley",
            "body": "bq. Using aligned ints would save the shifting done at IndexInput.getInt() that reads 4 bytes and shifts them into place to create an int from them.\n\nHow's that?  Is there some JVM intrinsic?",
            "date": "2010-01-20T14:53:43.983+0000",
            "id": 13
        },
        {
            "author": "Paul Elschot",
            "body": "For the record: on the flex branch I just saw IntIndexInput and IntIndexOutput.\n",
            "date": "2010-01-20T15:54:26.685+0000",
            "id": 14
        },
        {
            "author": "Paul Elschot",
            "body": "{quote}\n| Using aligned ints would save the shifting done at IndexInput.getInt() that reads 4 bytes and shifts them into place to create an int from them.\n\nHow's that? Is there some JVM intrinsic?\n{quote}\n\nIn the aligned case, and with the right byte order, getInt() on a java data stream might be reduced to processor instructions operating on 4 bytes at a time.\n\nIs that what you mean by JVM intrinsic?",
            "date": "2010-01-20T16:00:07.210+0000",
            "id": 15
        },
        {
            "author": "Yonik Seeley",
            "body": "bq. In the aligned case, and with the right byte order, getInt() on a java data stream might be reduced to processor instructions operating on 4 bytes at a time. Is that what you mean by JVM intrinsic?\n\nYes.  But are you aware of that having been implemented in any JVMs?",
            "date": "2010-01-20T16:25:46.004+0000",
            "id": 16
        },
        {
            "author": "Toke Eskildsen",
            "body": "{quote}\nToke:\nIntroducing yet another level of indirection and making a byte/short/int/long-prvider detached from the implementation of the packed values it tempting.\n{quote}\n\n{quote}\nYou mean the layer that stores the minValue, so that the full range is\nsupported? I actually think we should absorb that into packed ints,\nso it's only one method call per lookup, and specialize the \"positive\nonly\" cases to avoid the extra add per lookup.\n{quote}\n\nNo, I mean the backing array of ints or longs. For memory, the obvious choice is int[] or long[], but designing for flexibility calls for an API, which coincidentally is identical to Reader. So, a 4-bit Aligned could be backed by a DirectInt (which will contain an int[]) or a Persistent (doing mmap or some other persistent-oriented lookup).\n\n...I should show this in code instead. I'll try and find the time.\n\n{quote}\nYeah, we do eventually want CSF to be updateable, but I don't think we\nneed this for phase 1?\n{quote}\n\nNot in the specific scenario, no.\n\n\n{quote}\nToke:\nThe whole 32bit vs. 64bit as backing array does present a bit of a problem with persistence. We'll be in a situation where the index will be optimized for the architecture used for building, not the one used for searching. Leaving the option of a future mmap open means that it is not possible to do a conversion when retrieving the bits, so I have no solution for this (other than doing memory-only).\n{quote}\n\n{quote}\nI'm confused - a future mmap impl shouldn't put pressure on the file\nformat used by packed ints today? Ie, a future mmap impl can use a\ntotally different format than the designed-to-be-slurped-into-RAM\nformat for packed ints, today?\n\nAlso, what do you mean by optimized for building not searching?\n{quote}\n\nWhen we're using Aligned, the choice of using int or long for the backing array dictates how the persistent bitstream will be. If the index builder is a 64 bit machine and 7 bits/value is used, the result will be longs, each containing 9 values.\n\nWhen the structure is read into memory by the searcher, the backing array will again be long. But if the searcher happens to be a 32 bit machine, the performance will be less than if ints were used for the backing array.\n\nOne way to handle this is to do a conversion, when loading into memory. If the searcher is 64 bit, it will always convert into longs. If the searcher is 32 bit, it will convert into int, if the bits/value is <= 32. The conversion is cheap, so this is no problem in itself.\n\nHowever, if we're planning for the future (or for flexibility, depending on point of view), we would very much like the persistent format to be directly usable, so that we don't need to load the whole structure into memory. This rules out conversion and sets us back to step 1: The index will be optimized for either 32bit or 64 bit searchers.\n\nOh well, we could always just ignore it and say that Aligned is 64 bit based. As it is more memory-efficient than Aligned on 32 bit machines, maybe the slightly smaller number of backing longs will compensate for the overhead of retrieving longs on a 64 bit machine.\n\n{quote}\nNote that on 32 bit machines, if there is actually a gain, we can make\na backing store with ints yet still allow for storage of nbits>32? It\n\"just\" means a value may be split across 2 or 3 values?\n{quote}\n\nMy guess is that the number of values vs. the available level 2 cache will play a big role here: For a relatively small number of values, the added logic will be costly. For a larger number of values, the cache-misses will dwarf that.",
            "date": "2010-01-20T16:43:27.065+0000",
            "id": 17
        },
        {
            "author": "Paul Elschot",
            "body": "Paul: In the aligned case, and with the right byte order, getInt() on a java data stream might be reduced to processor instructions operating on 4 bytes at a time. Is that what you mean by JVM intrinsic?\n\nYonik: Yes. But are you aware of that having been implemented in any JVMs?\n\nI remember reading about an implementation doing that, but I can't find it back now.\n\nIf one cannot have such ints directly, there is not much point in unpacking via IndexInput.getInt(), it would be better to unpack directly from the bytes.\nAlso, in that case, I'd prefer to use single byte increments (above 4 byte increments) for the size of the encoded data for variations on Simple9.",
            "date": "2010-01-20T17:30:55.769+0000",
            "id": 18
        },
        {
            "author": "Toke Eskildsen",
            "body": "Looking at bit patterns and persistence, I see 3 different ones: Packed, aligned32 and aligned64. Regardless of whether 32bit or 64bit is used when a packed structure is created, it can be read as both 32bit and 64bit packed. As for the special cases of 8, 16, 32 and 64 bits/value, the bit patterns are identically to both packed and aligned. This leeds me to propose a header designating one of the three structures mentioned.\n\nThe current draft from Michael McCandless states both bitsPerValue and maxValue in the persistent format. It seems a redundant to have both, but I might be missing something here? Either way, the bitsPerValue is ambiguous as it does not translate to memory usage the same way for packed, aligned32 or aligned64. Should I choose, I'd go for maxValue.\n\nWhat about a header stating\n{code}\nformat (String \"packed\", \"aligned32\" or \"aligned64\")\nvalueCount (vInt)\nmaxValue (vLong)\n{code}\n?\n\nI have working code for packed32 and packed64 and am currently fitting it into Michael's patch. I hope to finish it this weekend.",
            "date": "2010-01-22T08:07:51.016+0000",
            "id": 19
        },
        {
            "author": "Paul Elschot",
            "body": "How about encoding the header something like this:\n\nVByte 1 bit.\nSimple9 4 bits. These cases imply valueCount and maxValue.\nFor around 4-16 numbers encode the complete header in 5-6 bits, also implying valueCount and maxValue.\nFor FrameOfRef, encoding 32 or more numbers, a larger header can be used, 4 bytes for example, maxValue is implied from the number of frame bits. valueCount could be 32, 64, 128 (i.e. 2 bits). Also the number of exceptions could be put there.\n\nThis header \"type\" can be chosen depending on the given length of the encoded sequence.\n",
            "date": "2010-01-22T08:37:01.369+0000",
            "id": 20
        },
        {
            "author": "Michael McCandless",
            "body": "bq. I have working code for packed32 and packed64 and am currently fitting it into Michael's patch. I hope to finish it this weekend.\n\nNice!  Sounds like good progress Toke!\n\nbq. The current draft from Michael McCandless states both bitsPerValue and maxValue in the persistent format\n\nI was only storing maxValue as a convenience for the layer above -- we don't need to do that -- I think storing format (packed, aligned32, aligned64) and bitsPerValue makes sense.\n\nbq. Regardless of whether 32bit or 64bit is used when a packed structure is created, it can be read as both 32bit and 64bit packed.\n\nRight, but with the challenge (if we use 32bit backing array) of properly handling the nbits>32 case (this is perfectly doable... \"it's just software\" ;) ).\n\nbq. As for the special cases of 8, 16, 32 and 64 bits/value, the bit patterns are identically to both packed and aligned.\n\nI had chosen to match IndexOutput/Inputs's byte order (big-endian) so that the packed format naturally reads back with IndexInput's readLong/Int/Short (I added a readShort).\n\nI'm assuming for these special cases that dedicated Reader impls, with byte[], short[], int[], long[] backing array, is faster than eg backing with a long[] and shift/masking per lookup.\n\nBut eg for the nbits=3 case, aligned 32/64 would ensure that no value spans across two underlying entries in the backing array (wasting some bits of storage in exchange).  Whereas the nbits=2 or 4 cases would naturally be aligned anyway...\n\nOne question: the Reader api is now this:\n{code}\nlong get(int index);\n{code}\n\nWhich is convenient since obviously long can accommodate all of the underlying possible nbits, but... for small nbits values, this logically entails a cast.  EG say nbits=8, so it's a direct byte[] backing array.  get() must cast up to long, and caller must operate with long... I'm wondering whether that forced casting is going to hurt performance enough to make us want to have dedicated precision (8, 16, 32, 64) Reader interfaces....",
            "date": "2010-01-22T08:39:12.294+0000",
            "id": 21
        },
        {
            "author": "Michael McCandless",
            "body": "bq. This header \"type\" can be chosen depending on the given length of the encoded sequence.\n\nI think we should separate the header needed for this issue (single header stored once at the beginning of a potentially massive file), from the per-block header used by int block based formats like SimpleN/PForDelta/etc?\n\nI think Toke's proposed header, if we swap in bitsPerValue in place of maxValue, is good for this issue?",
            "date": "2010-01-22T08:45:21.058+0000",
            "id": 22
        },
        {
            "author": "Toke Eskildsen",
            "body": "I've uploaded a preliminary patch with packed32, packed64, directByte, directShort, directInt and directLong implementations. I've used Michael McCandless patch as foundation, but the new patch is generated to be independent from the old one. It uses maxValue instead of bitsPerValue for the header, there's no test of packed32 and there's a general need for cleanup. The main missing components are aligned32 and aligned64.\n\nI've done quite a bit of refactoring and (cheater that I am) added setters to all implementations of Reader, although not to the interface. Besides the nitty-gritty details of the implementation, I suspect that the code for selecting which implementation to use is a prime candidate for discussion. It is located in PackedInts and tries to select the best implementation based on preference for packed, aligned and direct paired with preference for 32bit and 64bit.\n\n{code}\n  private static IMPLEMENTATION getImplementation(\n          long maxValue, PRIORITY priority, BLOCK_PREFERENCE block) {\n    int bits = bitsRequired(maxValue);\n    switch (priority) {\n      case direct: {\n        bits = getNextFixedSize(bits);\n        break;\n      }\n      case aligned: {\n        if (block == BLOCK_PREFERENCE.bit32) {\n          if (bits == 7 || bits >= 11) {\n            bits = getNextFixedSize(bits); // Align to byte, short, int or long\n          }\n        } else {\n          if ((bits >= 13 && bits <= 15) || (bits >= 22)) {\n            bits = getNextFixedSize(bits); // Align to short, int or long\n          }\n        }\n      }\n    }\n    switch (bits) { // The safe choices\n      case 8: return IMPLEMENTATION.directByte;\n      case 16: return IMPLEMENTATION.directShort;\n      case 32: return IMPLEMENTATION.directInt;\n      case 63:\n      case 64: return IMPLEMENTATION.directLong;\n    }\n\n    if (priority == PRIORITY.aligned || bits == 1 || bits == 2 || bits == 4) {\n      return block == BLOCK_PREFERENCE.bit32 && bits < 32 ?\n              IMPLEMENTATION.aligned32 : IMPLEMENTATION.aligned64;\n    }\n    return block == BLOCK_PREFERENCE.bit32 && bits < 32 ?\n            IMPLEMENTATION.packed32 : IMPLEMENTATION.packed64;\n\n    return IMPLEMENTATION.packed64;\n{code}\n\nI think that an \"auto\"-value for priority is worth considering: For 9, 17 and 33 bits/value, packed is often faster than aligned due to only using half the memory and thus having lower risk of level 2 cache misses. For high bits/value, such as 30, 31, 62, 63 and 64 (guesstimating here), choosing direct seems to be the best choice for most situations. Users of PackedInts should not be expected to know this.\n\nI'll start work on aligned32 and aligned64, but I will leave the rest of the patch alone for now, as I suspect that there'll be some changes to the current draft.",
            "date": "2010-01-22T12:27:10.763+0000",
            "id": 23
        },
        {
            "author": "Paul Elschot",
            "body": "The generated code in the patches has quite a few switch statements to decode a single value.\nThese switch statements could be avoided by using something like this (adapted from the 1410b patch):\n{code}\n/** Decode a value from the compressed array of b bit values by retrieving the corresponding bits.\n * Since numFrameBits is always smaller than the number of bits in an int,\n * at most two ints in the buffer will be used.\n */\npublic int decodeCompressedValueBase(int compressedPos, int numBits) {\n  int compressedBitPos = numBits * compressedPos;\n  int intIndex = (compressedBitPos >> 5);\n  int firstBitPosition = compressedBitPos & 31;\n  int value = intBuffer.get(intIndex) >>> firstBitPosition;\n  if ((firstBitPosition + numBits) > 32) { // value does not fit in first int\n    intIndex++;\n    value |= (intBuffer.get(intIndex) << (32 - firstBitPosition));\n  }\n  final int maxValue = (int) ((1L << numBits) - 1);\n  return value & maxValue;\n}\n{code}\nAs maxValue is essentially a mask, it could also be looked up in an array.\n\nCould that be faster than these generated switch statements?\n",
            "date": "2010-01-22T16:17:33.320+0000",
            "id": 24
        },
        {
            "author": "Toke Eskildsen",
            "body": "I think Michaels generated code was meant as a temporary solution, until a handcrafted version was available. In packed32 and packed64, the code for decoding a value is \n{code}\n  public long get(final int index) {\n    final long majorBitPos = index * elementBits;\n    final int elementPos = (int)(majorBitPos >>> BLOCK_BITS); // / BLOCK_SIZE\n    final int bitPos =     (int)(majorBitPos & MOD_MASK); // % BLOCK_SIZE);\n\n    final int base = bitPos * FAC_BITPOS;\n\n    return ((blocks[elementPos] << shifts[base]) >>> shifts[base+1]) |\n            ((blocks[elementPos+1] >>> shifts[base+2]) & readMasks[bitPos]);\n  }\n{code}\nwhich looks a lot like your (Paul Elschot)  suggestion. It  avoids all conditionals at the cost of more bit-operations and a dummy element at the end of the backing array. I must admit that my performance testing of the different solutions has been fairly ad hoc (measure, tweak, repeat), so an appropriate test would be in order.",
            "date": "2010-01-22T21:11:08.430+0000",
            "id": 25
        },
        {
            "author": "Paul Elschot",
            "body": "Nice to see a more mature alternative.\nThe trade off between (dummy element/unconditioned extra access) and (conditioned extra access) is of later concern.\nBoth the extra access and the condition take cycles, so it's not clear which one will be faster. It might even depend on the value of elementBits.\n",
            "date": "2010-01-23T10:44:44.306+0000",
            "id": 26
        },
        {
            "author": "Paul Elschot",
            "body": "As to whether to use int or long in the interface unsigned packed int, the only numbers that will probably need to be long in the foreseeable future are docids. However this change can be delayed by not allowing an index segment to grow beyond 2^32 or 2^31-1docs, and by only implementing the long docids for multiple index segments.\nSo as long as it is ok to assume that an index segment can have MAXINT docs at most, we could use an int interface here.\nDo Nutch and/or Solr already have long docids implemented on multiple index readers/writers or segments?\n\nThe other border is the max size of a document field. If that goes beyond MAXINT, the positions and maybe even the frequencies would need to be changed from int to long. But for now I can't think of a real use case with a document field that has more than MAXINT positions. That would be like a book with ten million pages of text. Did anyone ever run into this limitation?\n",
            "date": "2010-01-23T11:48:57.328+0000",
            "id": 27
        },
        {
            "author": "Michael McCandless",
            "body": "Good progress !\n\nbq. I think Michaels generated code was meant as a temporary solution, until a handcrafted version was available\n\nActually that was intended to be a fast impl... the switch should be\ncompiled to a direct lookup (maybe plus a conditional to catch the\n\"default\" case even though it will never happen...ugh).  But I like\nyour impl with no conditional at all.  We should test both.\n\nbq. As to whether to use int or long in the interface unsigned packed int, the only numbers that will probably need to be long in the foreseeable future are docids.\n\nAlso the file offsets into the terms dict, possibly the offsets in RAM\ninto the terms dict character data (UTF8 byte[]).  Also, when we do\ncolumn stride fields, we allow storing values > int.  I think we\nshould stick with {{long get(index)}} for now.\n\nOther comments:\n\n  * Maybe we should move all of this under oal.util.packed?\n    (packedints?  ints?)\n\n  * I think we should remove getMaxValue() from the Reader interface?\n\n  * Why create the IMPLEMENTATION enum?  Why not simply return an\n    [anonymous] instance of Writer?\n\n  * Why not store bitsPerValue in the header instead of maxValue?  EG\n    maybe my maxValue is 7000, but because I'm using directShort,\n    bitsPerValue is 16.  Also, the maxValue at write time should not\n    have to be known -- eg the factory API should let me ask for a\n    direct short writer without declaring the maxValue I will store.\n\n  * I wonder if we should add an optional Object\n    getDirectBackingArray().  The packed/aligned impls would return\n    null, but the direct byte/short/int/long impls would return their\n    array.  This would allow callers to specialize upstream impls to\n    do the direct array lookup without the cast-to-long (like how\n    FieldComparator now has impls for byte,short,int,long).  I suspect\n    for column stride fields, when sorting by an integer field, on a\n    32bit arch, this would be a perf win.  But: let's wait until we\n    have CSFs, and we can test whether there really is a gain here....\n\n  * I think we shouldn't put a getWriter on every Reader\n    impl... because it's a one to many mapping?  Eg the format written\n    by PackedWriter can be read by direct byte/short/int/long,\n    Packed32/64.\n\n  * For starters I don't think we should make reader impls that can\n    read nbits > 31 bits with an int[] backing array.  I think long[]\n    backing array is fine.\n\n  * I don't think we need separate PRIORITY and BLOCK_PREFERENCE?\n    Can't we have a single enum (STORAGE?) with: packed, aligned32,\n    aligned64?  \"Direct\" is really just packed with nbits rounded up\n    to 8,16,32,64.\n\n  * Aligned32/64 is very wasteful for certain nbits... I like the idea\n    of \"auto\" to avoid risk that caller picks a bad combination.\n\n  * I think for starters we should not make any reader impls that do\n    remapping at load time.\n",
            "date": "2010-01-25T21:21:39.116+0000",
            "id": 28
        },
        {
            "author": "Paul Elschot",
            "body": "{quote}\nAs to whether to use int or long in the interface unsigned packed int, the only numbers that will probably need to be long in the foreseeable future are docids.\n{quote}\n{quote}\nAlso the file offsets into the terms dict, possibly the offsets in RAM\n into the terms dict character data (UTF8 byte[]). Also, when we do\n column stride fields, we allow storing values > int. I think we\n should stick with long get(index) for now.\n{quote}\nIndeed I missed the offsets. However, a long get(index) will probably get in the way, because there are far fewer offsets\nthan normal data, and the 32 bit processors will be around for a long time. So I think we'll need both long (for the offsets) and int (for the rest) in the end.\n",
            "date": "2010-01-25T21:49:36.317+0000",
            "id": 29
        },
        {
            "author": "Toke Eskildsen",
            "body": "{quote}\nI think we should remove getMaxValue() from the Reader interface?\n{quote}\n\nYes. I only left maxValue in the code because I ran out of time.\n\n{quote}\nWhy create the IMPLEMENTATION enum? Why not simply return an\n[anonymous] instance of Writer?\n{quote}\n\nThe IMPLEMENTATION enum is only used internally and is package private. It was introduced to separate decision-making from specific implementations - e.g. the packed writer is the same for packed32 and packed64, although the reader differs. But it could very well be that it confuses more than it helps.\n\n{quote}\nWhy not store bitsPerValue in the header instead of maxValue?\n{quote}\n\nAs above - I did not have the time to fix it and wanted to push the patch in order to move the discussion along.\n\n{quote}\nAlso, the maxValue at write time should not\nhave to be known - eg the factory API should let me ask for a\ndirect short writer without declaring the maxValue I will store.\n{quote}\n\nSince Packed and Aligned needs maxValue (or bitsPerValue), this would require two distinct methods in the factory, each returning a subset of the possible implementations. I find that rather confusing.\n\n{quote}\nI wonder if we should add an optional Object\ngetDirectBackingArray(). The packed/aligned impls would return\nnull, but the direct byte/short/int/long impls would return their\narray. [...] \n{quote}\n\nSpeaking of API additions, I find that\n{code}\npublic int getBitsPerValue();\npublic int size();\npublic void set(long value);\npublic void clear();\n{code}\nare trivial to implement for the known implementations. They open up for things like auto-growing to fit higher values by using a delegating wrapper, re-using the structure for counting purposes and sorting in-place.\n\n{quote}\nI think we shouldn't put a getWriter on every Reader\nimpl... because it's a one to many mapping? Eg the format written\nby PackedWriter can be read by direct byte/short/int/long,\nPacked32/64.\n{quote}\n\nQuite right.\n\n{quote}\nFor starters I don't think we should make reader impls that can\nread nbits > 31 bits with an int[] backing array. I think long[]\nbacking array is fine.\n{quote}\nThe current patch limits nbits to 32 for Packed32. I am confident that an int-backed reader with nbits > 32 will be slower than a long-backed reader on a 32 bit machine.\n\n{quote}\nI don't think we need separate PRIORITY and BLOCK_PREFERENCE?\nCan't we have a single enum (STORAGE?) with: packed, aligned32,\naligned64? \"Direct\" is really just packed with nbits rounded up\nto 8,16,32,64.\n{quote}\nI agree that it does complicate matters somewhat to have them separated. When calling getReader the BLOCK_PREFERENCE should also be removed, as the block preference will always be the same as that architecture. Removing the \"direct\" option would require the caller to do some of the logic in some cases: If low processing requirements is a priority, direct is preferably and when the bitsPerValue is calculated, the caller would have to do the if (bitsPerValue > 32) bitsPerValue = 64 and so on.",
            "date": "2010-01-26T00:17:15.680+0000",
            "id": 30
        },
        {
            "author": "Michael McCandless",
            "body": "{quote}\nbq. Also, the maxValue at write time should not have to be known - eg the factory API should let me ask for a direct short writer without declaring the maxValue I will store.\n\nSince Packed and Aligned needs maxValue (or bitsPerValue), this would require two distinct methods in the factory, each returning a subset of the possible implementations. I find that rather confusing.\n{quote}\n\nMaybe the caller just always uses the bitsRequired method to get the\nrequired bit width per value?\n\nThough, when we enable specializing storing of negative values as\nwell, that'll be a hassle...\n\nOK let's leave it as you must pass the maxValue for now.\n\n{quote}\nSpeaking of API additions, I find that\n\n{code}\npublic int getBitsPerValue();\npublic int size();\npublic void set(long value);\npublic void clear();\n{code}\n\nare trivial to implement for the known implementations. They open up for things like auto-growing to fit higher values by using a delegating wrapper, re-using the structure for counting purposes and sorting in-place.\n{quote}\n\nI think the first 2 make sense, but I'd rather not pursue the 2nd two\nat this time.  Ie, I think this API only needs write-once, and then\nread-only.\n\nIf we open up random writing (set/clear), with auto-growing, etc.,\nthat does add complexities to the impl.  EG the backing store can no\nlonger be final, we'd have to do some locking (or mark the array\nvolatile) for thread safety, etc.\n\nAs far as I can tell... Lucene today doesn't yet need random write to\nthe packed ints.  The terms dict index and CSF are the two needs I\nthink we have now.  Someday (when CSF supports writing) we will... but\nnot yet today?\n\n{quote}\nbq. I don't think we need separate PRIORITY and BLOCK_PREFERENCE?  Can't we have a single enum (STORAGE?) with: packed, aligned32, aligned64? \"Direct\" is really just packed with nbits rounded up to 8,16,32,64.\n\nI agree that it does complicate matters somewhat to have them separated. When calling getReader the BLOCK_PREFERENCE should also be removed, as the block preference will always be the same as that architecture. Removing the \"direct\" option would require the caller to do some of the logic in some cases: If low processing requirements is a priority, direct is preferably and when the bitsPerValue is calculated, the caller would have to do the if (bitsPerValue > 32) bitsPerValue = 64 and so on.\n{quote}\n\n(There's a bug in the patch in PackedInts.getReader, where it switches\nthe block size based on whether JRE is 64 bit: it's always choosing 64\nbit now).\n\nThe \"direct\" option only applies during writing (ie, you round up to\nthe nearest native type bit width).  At read time it's just a packed\n8/16/32/64.\n\nHmm... maybe we could just add an optional 2nd arg to bitsRequired, a\nboolean eg \"roundUpToNative\" or something, which if true does that\nrounding for you?  (And then go back to caller computes bit width and\npasses it in?).\n",
            "date": "2010-02-04T19:24:50.652+0000",
            "id": 31
        },
        {
            "author": "Michael McCandless",
            "body": "Toke, are you still working on this...?  If not, I can take a crack?  I'd really like to get something online here before we land flex, so the terms dict index isn't so wasteful of RAM.",
            "date": "2010-02-10T11:23:05.741+0000",
            "id": 32
        },
        {
            "author": "Toke Eskildsen",
            "body": "Changing the code to use bitsPerValue instead of maxValue for constructors and persistent format took a bit longer than anticipated. To get things flowing, I've attached the code as it is now. I've moved the classes to o.a.l.util.packed and performed some clenup too. It still needs aligned32 and aligned64 implementations and more cleanup, which I'll work on for the next hour today and hopefully some hours tomorrow.\n\nOne current use-case for mutable packed ints would be for StringOrdValComparator (using an auto-grow wrapper), although the gain might be small as the overhead of the Strings is so large. I understand the problem of making all packed ints mutable, but a compromise might be to have a Mutable interface and a new factory-method that returns the same implementations as Mutable instead of Reader? That way it is possible to use the implementations for things such as sorting instead of having to re-implement them. I've left the interface for Reader clean as you suggested, but kept the implementations of set in the classes for now, as the code has already been made.",
            "date": "2010-02-10T14:49:44.329+0000",
            "id": 33
        },
        {
            "author": "Toke Eskildsen",
            "body": "I've read through the comments on LUCENE-1990 and implemented most of what has been suggested. The attached patch contains implementations for all the variants we've talked about, including aligned. There's a known bug in persistence for aligned64 (and probably also for aligned32) that I haven't stomped yet. There's also a clear need for a more elaborate unit-test with regard to persistence.\n\nOther outstanding issues, as I see them, are whether or not mutable packed arrays should be requestable (as general purpose data structures) and how the factory for creating a writer should work. I have added a getMutable-method to the factory and not touched the return type Reader for the getReader-method. That way read-only users will not be tempted to try and update the received structure. As for the arguments to the factory, Michael McCandless suggested that the preferences should be expressed with (packed | aligned32 | aligned64 | auto). As fas as I can see, this should work. However, I've only just reached this conclusion and haven't had the time to implement it.\n\nA speed-test has been added and the results from my machine can be seen below. In order for it to be really usable, it should be tried on other machines too.\n\nI won't touch the code before sometime next week, but I'll keep an eye on LUCENE-1990 comments until then.\n\n{code}\n        bitsPerValue          valueCount            getCount    PackedDirectByte   PackedDirectShort            Packed32     PackedAligned32     PackedDirectInt            Packed64     PackedAligned64    PackedDirectLong\n                   1                1000            10000000                 167                 141                 258                 242                 172                 264                 242                 183\n                   1             1000000            10000000                 224                 232                 266                 233                 246                 262                 238                 338\n                   1            10000000            10000000                 359                 469                 280                 278                 508                 278                 272                 551\n                   3                1000            10000000                 168                 166                 265                 241                 163                 262                 243                 166\n                   3             1000000            10000000                 227                 226                 261                 251                 239                 274                 249                 330\n                   3            10000000            10000000                 406                 476                 301                 304                 522                 300                 308                 547\n                   4                1000            10000000                 167                 168                 266                 239                 164                 285                 239                 169\n                   4             1000000            10000000                 228                 231                 294                 274                 262                 291                 269                 314\n                   4            10000000            10000000                 385                 480                 308                 333                 514                 331                 315                 557\n                   7                1000            10000000                 172                 174                 278                 248                 162                 271                 238                 177\n                   7             1000000            10000000                 224                 236                 289                 281                 272                 278                 277                 345\n                   7            10000000            10000000                 405                 473                 389                 447                 516                 399                 402                 553\n                   8                1000            10000000                 192                 171                 268                 242                 174                 291                 240                 163\n                   8             1000000            10000000                 226                 232                 291                 284                 286                 274                 265                 314\n                   8            10000000            10000000                 381                 467                 406                 428                 512                 422                 419                 580\n\n        bitsPerValue          valueCount            getCount   PackedDirectShort            Packed32     PackedAligned32     PackedDirectInt            Packed64     PackedAligned64    PackedDirectLong\n                   9                1000            10000000                 166                 274                 241                 170                 261                 237                 163\n                   9             1000000            10000000                 229                 299                 273                 250                 284                 275                 327\n                   9            10000000            10000000                 483                 443                 477                 519                 438                 455                 568\n                  15                1000            10000000                 170                 265                 239                 174                 264                 235                 162\n                  15             1000000            10000000                 232                 285                 274                 240                 278                 269                 339\n                  15            10000000            10000000                 473                 518                 524                 523                 519                 521                 550\n                  16                1000            10000000                 166                 263                 236                 172                 264                 235                 160\n                  16             1000000            10000000                 229                 285                 278                 244                 293                 272                 332\n                  16            10000000            10000000                 470                 513                 517                 509                 534                 529                 548\n\n        bitsPerValue          valueCount            getCount            Packed32     PackedAligned32     PackedDirectInt            Packed64     PackedAligned64    PackedDirectLong\n                  17                1000            10000000                 262                 255                 177                 260                 234                 160\n                  17             1000000            10000000                 290                 306                 273                 304                 290                 320\n                  17            10000000            10000000                 532                 572                 533                 529                 556                 551\n                  28                1000            10000000                 269                 256                 187                 267                 238                 163\n                  28             1000000            10000000                 293                 295                 253                 293                 296                 312\n                  28            10000000            10000000                 542                 567                 501                 548                 567                 542\n                  31                1000            10000000                 260                 235                 177                 266                 232                 158\n                  31             1000000            10000000                 292                 294                 244                 296                 297                 328\n                  31            10000000            10000000                 552                 563                 516                 562                 568                 548\n\n        bitsPerValue          valueCount            getCount     PackedDirectInt            Packed64     PackedAligned64    PackedDirectLong\n                  32                1000            10000000                 172                 263                 241                 166\n                  32             1000000            10000000                 241                 291                 297                 320\n                  32            10000000            10000000                 519                 556                 573                 546\n\n        bitsPerValue          valueCount            getCount            Packed64     PackedAligned64    PackedDirectLong\n                  33                1000            10000000                 264                 239                 159\n                  33             1000000            10000000                 293                 374                 319\n                  33            10000000            10000000                 559                 595                 552\n                  47                1000            10000000                 264                 242                 164\n                  47             1000000            10000000                 319                 369                 322\n                  47            10000000            10000000                 577                 601                 548\n                  49                1000            10000000                 261                 243                 162\n                  49             1000000            10000000                 323                 413                 319\n                  49            10000000            10000000                 584                 610                 551\n                  63                1000            10000000                 269                 235                 161\n                  63             1000000            10000000                 396                 369                 313\n                  63            10000000            10000000                 592                 596                 559\n{code}\n\n(Java 1.6.0_15-b03, default settings on a Dell Precision M6500: Intel i7 Q 820 @ 1.73GHz, 8 MB level 2 cache,  dual-channel PC 1333 RAM, running Ubuntu Karmic)",
            "date": "2010-02-12T02:57:21.940+0000",
            "id": 34
        },
        {
            "author": "Michael McCandless",
            "body": "Great progress Toke!\n\nI guess we should do Mutable since you're so far along already :)\n\nBut, now that we have getMutable, can we make the concrete impls\npackage private?  Javadocs for Mutable.set should note that the size\nis fixed once you allocate it.  We have no way to save a\nMutable... should we add that?  If so, we may want to rename Writer ->\nWriteOnceWriter.  This way consumers can also get a Mutable, do random\nwrites, then save, if the \"write once\" model isn't a good fit.\n\nMaybe we should just merge Mutable & Reader, then?  (LongStore?\nLongArray?  PackedLongs?)\n\nWe should state clearly that these are all unsigned ints storage.\n\nMaybe rename PackedDirectInt to PackedDirect32 (and Short to 16,\nByte to 8).  Because... while it is using a direct int[] under the hood,\nit's really using all 32 bits for the full positive int range.  So\nPackedDirect32 can be used even for pos ints that would overflow a\nnormal java \"int\".  (Though, for long we obviously can't use that 64th\nbit for positive ints...).\n\nThe @see in the new IndexInput.readShort is wrong (referencing\nwriteInt).\n\nCan you add @lucene.internal to the javadocs?\n\nSeems like once we stomp the bugs, beef up the tests, and merge\nPRIORITY and BLOCK_PREFERENCE (into maybe STORAGE?) for\nthe public API, we are nearly done?  Thanks Toke!\n",
            "date": "2010-02-12T12:10:44.838+0000",
            "id": 35
        },
        {
            "author": "Toke Eskildsen",
            "body": "I am sorry, but personal issues sapped my time and energy this week, so Lucene got bumped down my priority-list. I am going to code4lib next week and I'll try and get some hacking done in the plane from Denmark to USA, but that depends on whether or not there is a power socket near my seat. If I don't upload a patch late monday, it will be early march before I'll get it done\n\n{quote}\nBut, now that we have getMutable, can we make the concrete impls\npackage private? Javadocs for Mutable.set should note that the size\nis fixed once you allocate it.\n{quote}\n\nAgreed on both.\n\n{quote}\nWe have no way to save a Mutable... should we add that?\n{quote}\n\nI dont know enough about persistence in Lucene to make that call. Since the writer is tied to Lucene, it would not work for general purposes, so making a writer for Mutables only seems to make sense if the user uses it to build index-structures?\n\n{quote}\nMaybe we should just merge Mutable & Reader, then? (LongStore?\nLongArray? PackedLongs?)\n{quote}\n\nI don't understand that one? You made a compelling argument for returning immutables to readers earlier (problems with concurrency and having all back ends support writes).\n\nAs for the name... I don't know. None of the sound right, but I have no other suggestion.\n\n{quote}\nWe should state clearly that these are all unsigned ints storage.\n\nMaybe rename PackedDirectInt to PackedDirect32 (and Short to 16,\nByte to 8). Because... while it is using a direct int[] under the hood,\nit's really using all 32 bits for the full positive int range.\n{quote}\n\nGood point. The rest of your suggestions are also very valid.\n",
            "date": "2010-02-20T21:52:20.392+0000",
            "id": 36
        },
        {
            "author": "Toke Eskildsen",
            "body": "I've renamed most of the classes to short form, as the \"Packed\"-prefix did was not that descriptive and fixed some bugs. Still pending is the mutable writer and a bug in persistence for aligned64. Good news (for Lucene at least) is that an airplane blocking snowdrift means that I have time this week for continued hacking.\n\n{quote}\nBut, now that we have getMutable, can we make the concrete impls\npackage private? Javadocs for Mutable.set should note that the size\nis fixed once you allocate it.\n{quote}\n\nThe implementations are now package private, but I only put the note about fixed size on the getMutable-method. There's nothing wrong with creating a custom auto growing Mutable.\n\n{quote}\nWe should state clearly that these are all unsigned ints storage.\n{quote}\n\nDone.\n\n{quote}\nMaybe rename PackedDirectInt to PackedDirect32 (and Short to 16,\nByte to 8).\n{quote}\n\nDone (Direct8, Direct16, Direct32 and Direct64).\n\n{quote}\nThe @see in the new IndexInput.readShort is wrong (referencing\nwriteInt).\n{quote}\n\nFixed.\n\n{quote}\nCan you add @lucene.internal to the javadocs?\n{quote}\n\nShould this also be applied to package private classes? Marking those as internal seems redundant.\n\n{quote}\nSeems like once we stomp the bugs, beef up the tests, and merge\nPRIORITY and BLOCK_PREFERENCE (into maybe STORAGE?) for\nthe public API, we are nearly done?\n{quote}\n\nI've removed BLOCK_PREFERENCE from the API. It's still used internally, mainly to do controlled testing. Tests are beefed up (and currently fails for aligned, so clearly beefing worked).",
            "date": "2010-02-23T15:33:30.566+0000",
            "id": 37
        },
        {
            "author": "Toke Eskildsen",
            "body": "Now we're getting somewhere. I finally squashed the persistence bug and the tests has been turned up another notch. Everything seems to run as it should. Pending issues, as I see them:\n\n- Review of the code\n- Should we make a MutableWriter?\n- Should we drop support for aligned?\n\nThe last one is interesting. The code for getting a value from aligned uses devision and a single RAM-request:\n{code}\n  public long get(final int index) {\n    final int blockPos = index / valuesPerBlock;\n    final int bitPos = (index - (blockPos * valuesPerBlock)) * bitsPerValue;\n    return (blocks[blockPos] >>> shifts[bitPos]) & readMask;\n{code}\n\nwhere the code for packed uses shift and two RAM-requests:\n{code}\n    final long majorBitPos = index * bitsPerValue;\n    final int elementPos = (int)(majorBitPos >>> BLOCK_BITS); // / BLOCK_SIZE\n    final int bitPos =     (int)(majorBitPos & MOD_MASK); // % BLOCK_SIZE);\n\n    final int base = bitPos * FAC_BITPOS;\n\n    return ((blocks[elementPos] << shifts[base]) >>> shifts[base+1]) |\n            ((blocks[elementPos+1] >>> shifts[base+2]) & readMasks[bitPos]);\n{code}\n\nI have done some tests (see the TODO-file in the attached patch) and on 64 bit machines, the difference in access-speed for aligned vs. packed is not that great and not always in favor of aligned. Probably because some space is wasted and the RAM-cache is not so well utilized. If this is also the case for 32 bit machines, I vote for removing aligned and only used packed with the special-case optimizations direct8, direct16, direct32 and direct64. This would also mean that there is only one persistent format.\n\n{code}\njava -cp lucene-core-3.1-dev.jar org.apache.lucene.util.packed.PackedIntsPerformance\n{code}\nRuns throught the performance tests and delivers a simple report, so it should be very easy to test on different platforms. It only measures access speed.\n\nI consider this patch ready for review and concentrate on other matters until I hear more.",
            "date": "2010-02-26T14:03:54.721+0000",
            "id": 38
        },
        {
            "author": "Toke Eskildsen",
            "body": "I couldn't help making a tiny tweak to the performance test so that it outputs execution time means for the different implementations. I have attached measurements from 5 different 64 bit machines. Looking at the means, I observe the following:\n\n  * i7 Q820 and Xeon L5420: Practically no difference between aligned and packed with a small edge to aligned\n  * Core 2 and Xeon 5148: Aligned is consistently about 10% slower than packed\n  * Xeon MP (old with just 1 MB CPU cache): Aligned ranges from 0-10% slower than packed, depending on bits/value\n\nThe direct implementations outperforms packed and aligned for all sane cases (using direct8 to hold only 1 bit/value is clearly a bad idea). No surprise there.\n\nCaveat: The tests were run without any other significantly resource heavy processes disturbing it. This means that there were no fighting for the CPU cache.\n\nMajor caveat: Tests are needed on other processors than 64 bit Intel.\n\nI would be great if someone could figure out how to make an aligned getter without using division as that is surely the thing that hampers aligned performance.",
            "date": "2010-02-26T15:49:46.761+0000",
            "id": 39
        },
        {
            "author": "Michael McCandless",
            "body": "Great progress!  I think this is very close.\n\nAirplane blocking snow drifts!?  Where on earth are you anyway?\n\n{quote}\nbq. Can you add @lucene.internal to the javadocs?\n\nShould this also be applied to package private classes? Marking those as internal seems redundant.\n{quote}\n\nYeah I agree package private APIs don't need the @lucene.internal...\n\nIt's very interesting that align is never a win -- I think in that\ncase removing it makes sense?  It'll be a nice simplification.\n\nI think we don't need to make a MutableWriter, at least before\ncommitting?  Nobody needs it now... (I think?).\n\nOther small things:\n\n  * Can you use @lucene.internal instead of the NOTE that I had put on\n    the classes?\n\n  * We lost \"final\" in the RamUsageEstimator constants\n\n  * Did we ever test performance of the specialized (generated)\n    decoders using switch statements?\n",
            "date": "2010-02-26T20:04:34.775+0000",
            "id": 40
        },
        {
            "author": "Toke Eskildsen",
            "body": "{quote}\nAirplane blocking snow drifts!?  Where on earth are you anyway?\n{quote}\n\nIn Denmark. The guy responsible for clearing the runway did indeed clear the runway. He just forgot that the plane needs to taxi into the runway in the first place. That made us miss our connecting flight.\n\n{quote}\nIt's very interesting that align is never a win -- I think in that case removing it makes sense?  It'll be a nice simplification.\n{quote}\n\nWell, practically never wins for the machines I tested on and never wins with my implementation.\n\n{quote}\nCan you use @lucene.internal instead of the NOTE that I had put on the classes?\n{quote}\n\nDone... I think. I'm not very good at this part, so if someone else wants to do some cleanup i JavaDoc and such, they are very welcome by me.\n\n{quote}\nWe lost \"final\" in the RamUsageEstimator constants\n{quote}\n\nStrange. Oh well, fixed.\n\n{quote}\nDid we ever test performance of the specialized (generated) decoders using switch statements?\n{quote}\n\nI just did a quick hack in order to measure performance  and I was very surprised that the generated switch-based implementations performs so well. It's nearly on par with packed most of the time and exceeds it in some cases. I only tested on 3 machines though. The hack is in the LUCENE-1990-te20100226c.patch and is called when the performance test is executed.\n\nAttachment generated_performance-te20100226.txt contains measurements where the py-generated code is tested together with the other implementations.\n\nNote to self: Switch is not equivalent to a series of if-else, when we're talking performance and when we switch without omissions in the cases.",
            "date": "2010-02-26T22:55:25.326+0000",
            "id": 41
        },
        {
            "author": "Michael McCandless",
            "body": "{quote}\nbq. Airplane blocking snow drifts!? Where on earth are you anyway?\n\nIn Denmark. The guy responsible for clearing the runway did indeed clear the runway. He just forgot that the plane needs to taxi into the runway in the first place. That made us miss our connecting flight.\n{quote}\n\nGood grief!\n\n{quote}\nbq. It's very interesting that align is never a win - I think in that case removing it makes sense? It'll be a nice simplification.\n\nWell, practically never wins for the machines I tested on and never wins with my implementation.\n{quote}\n\nI think we should remove it...\n\n{quote}\nbq. Did we ever test performance of the specialized (generated) decoders using switch statements?\n\nI just did a quick hack in order to measure performance and I was very surprised that the generated switch-based implementations performs so well. It's nearly on par with packed most of the time and exceeds it in some cases. I only tested on 3 machines though. The hack is in the LUCENE-1990-te20100226c.patch and is called when the performance test is executed.\n{quote}\n\nThanks for testing this!  It is interesting.\n\nI ran the perf test on a CentOS 5.4 machine, java\n1.6.0_17-b04 64 bit server, Intel core 2 duo E8400 (3 ghz) -- attached\nperf-mkm-20100227.txt.  I also show the switch impl close, though\nalways a bit behind.\n\nSeems like we should just stick with the non-gen'd packed impl?\n\nbq. Note to self: Switch is not equivalent to a series of if-else, when we're talking performance and when we switch without omissions in the cases.\n\nRight, if the switch cases are compact, it should compile into a fast jump\ntable (though it may still do an unecessary bounds check).\n\nI think, once we removed aligned, this is ready to commit?  I think we\nshould land this on flex branch?  (It's using CodecUtil, BytesRef --\nI'll merge them when I commit).  Then I can cutover the terms index to\nuse packed ints.\n",
            "date": "2010-02-27T11:13:42.502+0000",
            "id": 42
        },
        {
            "author": "Toke Eskildsen",
            "body": "I've tested on two 32 bit Windows machines: An Intel T2400 (32 bit only) running XP and an Athlon X2 4850e (64 bit capable) running 32 bit XP. The result can be seen in attachment performance-20100301.txt. Something curious happens with high (32+) bits/value for the T2400 as aligned overtakes packed. However, the overall picture is still that aligned only wins for a few special cases, so now I'll be happy to remove it from the patch. As a note, generated is also slower than packed on the AMD processor, although not as much as for Intel.\n\nI have removed all traces of aligned from PackedInts, but kept the classes in the patch, in the case that someone finds a faster way to handle aligned. PackedIntsPerformance still includes both the generated switch-implementation and Aligned32 and Aligned64. It should be possible to apply the patch without Aligned32, Aligned64, AlignedWriter and PackedIntsPerformance.",
            "date": "2010-03-01T14:11:43.477+0000",
            "id": 43
        },
        {
            "author": "Toke Eskildsen",
            "body": "Some thoughts on avoiding the generic division by experimenting with reciprocal multiplication: For aligned, the sane number of values/block are [3, 5, 6, 7, 8, 9, 10, 16, 21, 32, 64]. I tried testing index from 0 to Integer.MAX_VALUE with these divisors and reciprocal multiplication. It worked perfectly for all divisors except [5, 7, 9, 10, 21]. Unfortunately it already falls for divisor 21 at index 252645140, which makes it useless as a full replacement. If one were so inclined, it would be possible to select aligned implementation based on valueCount, with fallback to the \"slow\" version. The gain of using fast division seems quite substantial as it makes aligned 14-40% faster than packed (note: Just tested on a single machine). However, re-introducing aligned with four different implementations (Aligned32, Aligned32Fast, Aligned64, Aligned64Fast) is rather daunting and it would make the selection code really messy.\n\nI can see that there are well-known tricks to get around the rounding errors. Some are described at http://www.cs.uiowa.edu/~jones/bcd/divide.html#fixed . I don't know if these extra tricks would negate the 14-40% speed gain though. Since I would like to get the patch out of the door, I vote for keeping aligned disabled and just note that more bit fiddling might make it attractive at some point.",
            "date": "2010-03-01T20:56:57.205+0000",
            "id": 44
        },
        {
            "author": "Michael McCandless",
            "body": "Patch looks great Toke -- a few small things:\n\n  * I think we shouldn't add Aligned*.java to svn?  It'll just add\n    unused bits to the JAR, and, we can always fallback to this issue\n    to pull them in at a future time?\n\n  * Can you resolve the remaining nocommits?  EG (since we are\n    unsigned) we can't get the 64 bit case working.  I don't think we\n    should rename to UnsignedXXX, nor, support minValue at this\n    point, and remove the ComparableBytesRef, and I'll merge BytesRef\n    into flex's when I commit.\n\nI can take these too -- I think it's ready to commit on flex after\nthis.  Thanks!\n",
            "date": "2010-03-07T11:51:24.412+0000",
            "id": 45
        },
        {
            "author": "Uwe Schindler",
            "body": "We should also add the @lucene.internal javadoc comments everywhere instead of the big NOTE. Why has one class a full-uppercase class name?",
            "date": "2010-03-07T11:59:05.520+0000",
            "id": 46
        },
        {
            "author": "Toke Eskildsen",
            "body": "Michael McCandless:\n{quote}\n    * I think we shouldn't add Aligned*.java to svn? It'll just add\n      unused bits to the JAR, and, we can always fallback to this issue\n      to pull them in at a future time?\n{quote}\n\nI agree. At the current state, Aligned is just dead weight.\n\nThis also means that the performance tester won't be part of the commit though. I can quickly make a performance tester that does not use aligned, if it is preferable to keep performance testing.\n\n{quote}\n    * Can you resolve the remaining nocommits? EG (since we are\n      unsigned) we can't get the 64 bit case working. I don't think we\n      should rename to UnsignedXXX, nor, support minValue at this\n      point, and remove the ComparableBytesRef, and I'll merge BytesRef\n      into flex's when I commit.\n\nI can take these too - I think it's ready to commit on flex after this\n{quote}\n\nIt will help a lot if you take care of these issues, thanks.",
            "date": "2010-03-09T12:33:20.391+0000",
            "id": 47
        },
        {
            "author": "Toke Eskildsen",
            "body": "Uwe Schindler:\n{quote}\nWe should also add the @lucene.internal javadoc comments everywhere instead of the big NOTE. Why has one class a full-uppercase class name? \n{quote}\n\nAre you looking at patch LUCENE-1990-te20100301.patch? I don't see any NOTE and no full-uppercase class name?",
            "date": "2010-03-09T12:34:52.106+0000",
            "id": 48
        },
        {
            "author": "Michael McCandless",
            "body": "bq. It will help a lot if you take care of these issues, thanks.\n\nOK will do.  I'll commit soon to flex... thanks Toke!",
            "date": "2010-03-09T18:19:06.256+0000",
            "id": 49
        },
        {
            "author": "Michael McCandless",
            "body": "bq. We should also add the @lucene.internal javadoc comments everywhere instead of the big NOTE.\n\nI found one more NOTE in CodecUtil -- I'll fix before committing.",
            "date": "2010-03-09T18:23:35.208+0000",
            "id": 50
        },
        {
            "author": "Michael McCandless",
            "body": "bq. Why has one class a full-uppercase class name?\n\nUwe you mean eg STORAGE?  (And also BLOCK, IMPLEMENTATION... but they are package private).  These are enums -- seems OK to make them all caps?\n\nThough I do think we can simplify some of this now that we're removing the aligned case... eg PERSISTENCE is an enum with only one value.  I'll take a stab & post patch.",
            "date": "2010-03-09T18:26:12.472+0000",
            "id": 51
        },
        {
            "author": "Michael McCandless",
            "body": "OK new patch attached:\n\n  - Ported to flex, and cutover to CodecUtil.  BytesRef required no\n    changes...\n\n  - Simplified the API/impl to not use STORAGE, PERSISTENCE,\n    IMPLEMENTATION, etc.  You just specify required bitsPerValue.\n\n  - Removed Aligned*, and ConsumesRAM interface\n\n  - Fixed the nocommits.\n\nI think it's ready!  I'll wait a day or two...\n",
            "date": "2010-03-09T22:14:17.576+0000",
            "id": 52
        },
        {
            "author": "Michael McCandless",
            "body": "Thanks Toke!",
            "date": "2010-03-13T16:34:52.034+0000",
            "id": 53
        },
        {
            "author": "Toke Eskildsen",
            "body": "Thanks for rounding off, Michael. It's been a pleasure.",
            "date": "2010-03-14T13:56:18.748+0000",
            "id": 54
        },
        {
            "author": "Robert Muir",
            "body": "By the way Toke, we have lately been benchmarking automaton queries, which are pretty intensive on the terms dictionary.\nI think we were expecting some acceptable slowdown once we switched to packed ints, but according to my benchmarks this is not the case.\n\nI think its pretty impressive to see no measurable performance impact on this stuff at all, great work.\n",
            "date": "2010-03-27T17:04:45.747+0000",
            "id": 55
        },
        {
            "author": "Toke Eskildsen",
            "body": "I am very happy to hear that, Robert. The benchmarks I made had the glaring flaw that they were ... well, benchmarks. With the CPU-cache being hammered in a real world scenario, your findings indicate that the slow round-trip to main memory dwarfs the extra logic for extracting the values from the packed structure. For a few scenarios, it might even be faster than plain arrays.\n\nGetting back to reality, my own findings indicates that using PackedInts for ord-based sorted search is not at all faster than plain arrays. The access pattern here is very sequential, so the chance that the needed value is already fetched from main memory is high for both plain and packed structures.",
            "date": "2010-03-31T10:28:39.589+0000",
            "id": 56
        },
        {
            "author": "Michael McCandless",
            "body": "Toke, are sort ords that much slower than straight arrays for sorting?\n\nAfter flex lands I'd really like to make a variant of FieldCache.StringIndex that uses BytesRef for the values and packed ints for the ords.... should save alot of memory in many cases (English text saves since utf8 is 1 byte per char; enumerated fields (eg country name) should save tons by using only a few bits instead of 32 we now always use) when sorting by string.",
            "date": "2010-03-31T10:39:04.284+0000",
            "id": 57
        },
        {
            "author": "Toke Eskildsen",
            "body": "In the original proof of concept for LUCENE-2335, I measured the time for extracting top-20 for ... 10 million? documents and got something like 600ms when using PackedInts, which is fairly slow in my book and recall getting better performance with straight arrays for that. This is all wery fuzzy though and I'd love to be proven wrong. If PackedInts are faster for sorting too, it's getting very hard to see the downside of that representation.\n\nSince LUCENE-2335 relies heavily on arays of sorted indexes into ordinal arrays, I'll make sure to performance test both PackedInts and straight arrays for sorted search.",
            "date": "2010-03-31T19:51:08.422+0000",
            "id": 58
        },
        {
            "author": "Toke Eskildsen",
            "body": "It seem like my unit-testing of PackedInts.Mutable wasn't good enough. There is a bug in Packed64 (and probably in Packed32 too) when using the set-method. In certain cases the secondary block is changed when it should be left alone. A simple unit-test is\n{code}\n    PackedInts.Mutable mutable = PackedInts.getMutable(26, 5);\n    mutable.set(24, 31);\n    mutable.set(4, 16);\n    assertEquals(\"The value #24 should remain unchanged\", 31, mutable.get(24));\n{code}\n\nThe PackedWriter uses a different algorithm for generating the bit stream and is unaffected by this bug.\n\nI expect the write-masks for the set-method to be at fault and I am working on a fix. ETA: Within an hour or sometime during the weekend, depending on difficulty.",
            "date": "2010-04-01T21:24:39.421+0000",
            "id": 59
        },
        {
            "author": "Michael McCandless",
            "body": "Good catch Toke!  Flex actually uses Mutable on loading the terms index when indexDivisor is not 1...",
            "date": "2010-04-01T21:38:20.709+0000",
            "id": 60
        },
        {
            "author": "Michael McCandless",
            "body": "Reopen to fix issue Toke found with Mutable",
            "date": "2010-04-01T21:38:39.557+0000",
            "id": 61
        },
        {
            "author": "Toke Eskildsen",
            "body": "I've located the bug and fixed it. As expected, it was in the write-masks. Unfortunately I'm running out of time, so I cannot make a patch right now. The code for Packed64 is\n{code}\n  private static final long[][] WRITE_MASKS =\n          new long[ENTRY_SIZE][ENTRY_SIZE * FAC_BITPOS];\n  static {\n    for (int elementBits = 1 ; elementBits <= BLOCK_SIZE ; elementBits++) {\n        long elementPosMask = ~(~0L << elementBits);\n        int[] currentShifts = SHIFTS[elementBits];\n        long[] currentMasks = WRITE_MASKS[elementBits];\n        for (int bitPos = 0 ; bitPos < BLOCK_SIZE ; bitPos++) {\n            int base = bitPos * FAC_BITPOS;\n            currentMasks[base  ] =~((elementPosMask\n                               << currentShifts[base + 1])\n                              >>> currentShifts[base]);\n            currentMasks[base+1] =\n                ~(elementPosMask << currentShifts[base + 2]);\n            currentMasks[base+2] = currentShifts[base + 2] == 0 ? 0 : ~0;\n          if (bitPos <= BLOCK_SIZE - elementBits) { // Second block not used\n            currentMasks[base+1] = ~0; // Keep all bits\n            currentMasks[base+2] = 0;  // Or with 0\n          }\n        }\n    }\n  }\n{code}\n\nThe changed code is the addition of the last check for second block usage. Likewise the fix for Packed32 is\n\n{code}\n  private static final int[][] WRITE_MASKS =\n          new int[ENTRY_SIZE][ENTRY_SIZE * FAC_BITPOS];\n  static {\n    for (int elementBits = 1 ; elementBits <= BLOCK_SIZE ; elementBits++) {\n      int elementPosMask = ~(~0 << elementBits);\n      int[] currentShifts = SHIFTS[elementBits];\n      int[] currentMasks = WRITE_MASKS[elementBits];\n      for (int bitPos = 0 ; bitPos < BLOCK_SIZE ; bitPos++) {\n        int base = bitPos * FAC_BITPOS;\n        currentMasks[base  ] =~((elementPosMask\n                << currentShifts[base + 1])\n                >>> currentShifts[base]);\n        currentMasks[base+1] = ~(elementPosMask\n                << currentShifts[base + 2]);\n        currentMasks[base+2] = currentShifts[base + 2] == 0 ? 0 : ~0;\n        if (bitPos <= BLOCK_SIZE - elementBits) { // Second block not used\n          currentMasks[base+1] = ~0; // Keep all bits\n          currentMasks[base+2] = 0;  // Or with 0\n        }\n      }\n    }\n  }\n{code}\n\nWithout checking thoroughly, I'd expect the two pieces of code to be exactly the same, at the difference between Packed32 and Packed64 is just long vs. int and some constants. The unit-test from above can be used for Packed32 by explicitly creating a Packed32 instead of calling the factory.\n\nI'll be back behind the screen in a few days where I can make a patch, but you are more than welcome to roll the patch if it is more convenient to get it immediately.",
            "date": "2010-04-01T21:51:46.560+0000",
            "id": 62
        },
        {
            "author": "Michael McCandless",
            "body": "I turned it into a patch (attached).\n\nBut: without the fix, when I run the test, I don't see it failing (on current flex branch).  I've fixed a few issues with packed ints on flex, but I don't think they would've fixed this.  Confused....",
            "date": "2010-04-01T22:06:17.364+0000",
            "id": 63
        },
        {
            "author": "Toke Eskildsen",
            "body": "I did a checkout with\n{code}\nsvn co https://svn.apache.org/repos/asf/lucene/dev/trunk/lucene lucene-flex\n{code}\n\nand added the following method to TestPackedInts\n\n{code}\n  public void testSecondaryBlockChange() throws IOException {\n    PackedInts.Mutable mutable = new Packed64(26, 5);\n    mutable.set(24, 31);\n    assertEquals(\"The value #24 should be correct\", 31, mutable.get(24));\n    mutable.set(4, 16);\n    assertEquals(\"The value #24 should remain unchanged\", 31, mutable.get(24));\n  }\n{code}\n\nafter which I ran\n\n{code}\nant test-core\n{code}\n\nwhich gave me\n\n{code}\n    [junit] Testsuite: org.apache.lucene.util.packed.TestPackedInts\n    [junit] Testcase: testSecondaryBlockChange(org.apache.lucene.util.packed.TestPackedInts):\tFAILED\n    [junit] The value #24 should remain unchanged expected:<31> but was:<28>\n    [junit] junit.framework.AssertionFailedError: The value #24 should remain unchanged expected:<31> but was:<28>\n    [junit] \tat org.apache.lucene.util.packed.TestPackedInts.testSecondaryBlockChange(TestPackedInts.java:106)\n    [junit] \tat org.apache.lucene.util.LuceneTestCase.runBare(LuceneTestCase.java:276)\n{code}\n\nthen I added\n\n{code}\n              if (bitPos <= BLOCK_SIZE - elementBits) { // Second block not used\n                currentMasks[base+1] = ~0; // Keep all bits\n                currentMasks[base+2] = 0;  // Or with 0\n              }\n{code}\n\nto the relevant parts of Packed32 and Packed, as described above and ran\n\n{code}\nant test-core\n{code}\n\nagain, which gave me\n\n{code}\n    [junit] Testsuite: org.apache.lucene.util.packed.TestPackedInts\n    [junit] Tests run: 7, Failures: 0, Errors: 0, Time elapsed: 5.463 sec\n{code}\n\nMy initial unit-test contained an error, which I corrected after a minute or two (as far as I remember). Maybe you used the first version?\n\nIt seems that the bug is indeed in trunk. It corrupts the value of the block after the current block in certain cases: Sequential assignment of values works fine, but out-of-order assignments corrupts the array.",
            "date": "2010-04-06T20:08:48.539+0000",
            "id": 64
        },
        {
            "author": "Michael McCandless",
            "body": "OK indeed now I can see the failure when I add the test (I guess I did use the first version), and the changes fix it.  I'll commit shortly.  Thanks Toke!",
            "date": "2010-04-06T20:46:13.618+0000",
            "id": 65
        },
        {
            "author": "Michael McCandless",
            "body": "Thanks Toke!",
            "date": "2010-04-06T20:58:39.879+0000",
            "id": 66
        },
        {
            "author": "Toke Eskildsen",
            "body": "I have discovered a bug in Packed32 and Packed64: When the number of bits exceed 2^31, the setters and getters fail. This is due to a missing cast in the calculation of the entry-point in the backing int/long-arrays.\n\nIn both Packed32 and Packed64 the line\n{code}\n    final long majorBitPos = index * bitsPerValue;\n{code}\nis used in get as well as set. This should be\n{code}\n    final long majorBitPos = (long)index * bitsPerValue;\n{code}\nin all 4 cases.\n\nA unit test for this is\n{code}\n  /*\n  Check if the structures properly handle the case where\n  index * bitsPerValue > Integer.MAX_VALUE\n   */\n  public void testIntOverflow() {\n    int INDEX = (int) Math.pow(2, 30);\n    int BITS = 4;\n\n    Packed32 p32 = new Packed32(INDEX, BITS);\n    p32.set(INDEX-1, 1);\n    assertEquals(\"The value at position \" + (INDEX-1)\n        + \" should be correct for Packed32\", 1, p32.get(INDEX-1));\n    p32 = null; // To free 512MB\n\n    Packed64 p64 = new Packed64(INDEX, BITS);\n    p64.set(INDEX-1, 1);\n    assertEquals(\"The value at position \" + (INDEX-1)\n        + \" should be correct for Packed64\", 1, p64.get(INDEX-1));\n  }\n{code}\n\nOne big problem with the unit-test is that it requires 2^30*4/8 bytes = 512MB of heap. I am guessing that this makes it impossible to run in the standard test-suite.\n\nI am unsure as to how I should push this fix through. Should I create a new JIRA issue? Make a patch against trunk? Or maybe a committer could just try the test above and insert the fix in trunk?",
            "date": "2010-08-31T08:41:45.087+0000",
            "id": 67
        },
        {
            "author": "Simon Willnauer",
            "body": "bq. One big problem with the unit-test is that it requires 2^30*4/8 bytes = 512MB of heap. I am guessing that this makes it impossible to run in the standard test-suite.\nSeems to be a bit high for a unittest but you can't help it, right? :)\n\nbq. I am unsure as to how I should push this fix through. Should I create a new JIRA issue? Make a patch against trunk? Or maybe a committer could just try the test above and insert the fix in trunk?\nI would suggest to create a new issue and attach a patch with the fix including your unittest. Since the unittest might break hudson etc I would recommend to add an @Ignore on top of it (JUnit 4) until we decided how to include tests like that. Maybe we might introduce a special flag that enables tests like that with a JUnit Assume call but that needs to be further discussed.\n",
            "date": "2010-08-31T09:01:32.610+0000",
            "id": 68
        },
        {
            "author": "Toke Eskildsen",
            "body": "Remembering signed integer representation, a better test would be \n{code}\n  /*\n  Check if the structures properly handle the case where\n  index * bitsPerValue > Integer.MAX_VALUE\n   */\n  public void testIntOverflow() {\n    int INDEX = (int)Math.pow(2, 30)+1;\n    int BITS = 2;\n\n    Packed32 p32 = new Packed32(INDEX, BITS);\n    p32.set(INDEX-1, 1);\n    assertEquals(\"The value at position \" + (INDEX-1)\n        + \" should be correct for Packed32\", 1, p32.get(INDEX-1));\n    p32 = null; // To free the 256MB used\n\n    Packed64 p64 = new Packed64(INDEX, BITS);\n    p64.set(INDEX-1, 1);\n    assertEquals(\"The value at position \" + (INDEX-1)\n        + \" should be correct for Packed64\", 1, p64.get(INDEX-1));\n  }\n{code}\n\nThis still triggers the bug but requires \"only\" 256 MB. Is this acceptable in the Hudson environment?",
            "date": "2010-08-31T09:21:14.635+0000",
            "id": 69
        },
        {
            "author": "Robert Muir",
            "body": "bq. This still triggers the bug but requires \"only\" 256 MB. Is this acceptable in the Hudson environment?\n\nThe default maxMemory size is wired at 512MB. i think this might be too large already: on my machine with 4 cpus\nthis means max 2GB for lucene and 4GB for solr tests.\n\none way to do this would be to make this maxMemory configurable with a -D, set it accordingly in hudson, and\nalso setup a way to write 'hudson-only' tests. then stuff like this could run in the nightly only.\n",
            "date": "2010-09-01T01:31:00.983+0000",
            "id": 70
        },
        {
            "author": "Toke Eskildsen",
            "body": "Correction: I have created LUCENE-2633 and uploaded a patch for the issue above.",
            "date": "2010-09-03T11:26:54.887+0000",
            "id": 71
        },
        {
            "author": "Uwe Schindler",
            "body": "Bulk close after release of 3.5",
            "date": "2011-11-27T12:29:33.586+0000",
            "id": 72
        }
    ],
    "component": "core/index",
    "description": "There are various places in Lucene that could take advantage of an\nefficient packed unsigned int/long impl.  EG the terms dict index in\nthe standard codec in LUCENE-1458 could subsantially reduce it's RAM\nusage.  FieldCache.StringIndex could as well.  And I think \"load into\nRAM\" codecs like the one in TestExternalCodecs could use this too.\n\nI'm picturing something very basic like:\n{code}\ninterface PackedUnsignedLongs  {\n  long get(long index);\n  void set(long index, long value);\n}\n{code}\n\nPlus maybe an iterator for getting and maybe also for setting.  If it\nhelps, most of the usages of this inside Lucene will be \"write once\"\nso eg the set could make that an assumption/requirement.\n\nAnd a factory somewhere:\n\n{code}\n  PackedUnsignedLongs create(int count, long maxValue);\n{code}\n\nI think we should simply autogen the code (we can start from the\nautogen code in LUCENE-1410), or, if there is an good existing impl\nthat has a compatible license that'd be great.\n\nI don't have time near-term to do this... so if anyone has the itch,\nplease jump!\n",
    "hasPatch": true,
    "hasScreenshot": false,
    "id": "LUCENE-1990",
    "issuetypeClassified": "IMPROVEMENT",
    "issuetypeTracker": "IMPROVEMENT",
    "priority": "Minor",
    "product": "LUCENE",
    "project": "LUCENE",
    "summary": "Add unsigned packed int impls in oal.util",
    "systemSpecification": true,
    "version": "4.0-ALPHA"
}