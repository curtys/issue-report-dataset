{
    "comments": [
        {
            "author": "Robert Muir",
            "body": "if anyone wants to take this, don't hesitate!",
            "date": "2011-09-25T03:36:49.847+0000",
            "id": 0
        },
        {
            "author": "Otis Gospodnetic",
            "body": "Would it be wise to stick with a name less specific than collapseSegments for example, in order not to have an incorrect name that requires another renaming when this \"command\" ends up doing something new in the future?",
            "date": "2011-09-25T04:31:30.495+0000",
            "id": 1
        },
        {
            "author": "Robert Muir",
            "body": "Otis: thats a good point, currently optimize is just a \"request\", we should probably figure out what it \"should be\".\n\nShould it be collapseSegments, which is a well-defined request without a cool sounding name?\n\nOr, should it be <something else>, which gives you a more optimal configuration for search performance... (i still think optimize is a bad name even for this)? Personally i suspect its going to be hard to support this case, e.g. you would really need to know things like, if the user has executionService set on the IndexSearcher and how big the threadpool is and things like that to make an 'optimal' configuration... and we don't have a nice way of knowing that information today.\n",
            "date": "2011-09-25T05:28:56.566+0000",
            "id": 2
        },
        {
            "author": "Shai Erera",
            "body": "I personally find optimize() clear, and people got used to it already. However I do agree it sounds like it's doing magic, but really it just merges segments.\n\nWe already have maybeMerge(), how about consolidating the two under merge(MergeLevel) where MergeLevel is either AGGRESSIVE (optimize) or DELICATE (maybeMerge)? Or something in that spirit.\n\nAnyway, if we end up renaming, we should probably rename MergePolicy.findSegmentsForOptimize as well. If we consolidate, we should consolidate it as well.",
            "date": "2011-09-25T06:53:55.533+0000",
            "id": 3
        },
        {
            "author": "Uwe Schindler",
            "body": "I like Shai's idea, let's remove optimize completely. maybeMerge has the ideal name.\n\nMergePolicy should then have only one method also getting this aggresiveness parameter.",
            "date": "2011-09-25T08:47:09.964+0000",
            "id": 4
        },
        {
            "author": "Michael McCandless",
            "body": "How about maybeMerge() and maybeMerge(int maxSegCount) (since we have to absorb optimize(int maxSegCount) too)?\n\nThis way what used to be optimize is now maybeMerge(1).\n\nI like that this forces the user to make an explicit decision about how many segments they require the index to merge down to, so they realize by picking 1 they are asking for tons of merging.",
            "date": "2011-09-25T13:20:18.025+0000",
            "id": 5
        },
        {
            "author": "Shai Erera",
            "body": "Fine. Can we use the opportunity to remove 'maybe'? Just merge(). If it ends up doing nothing, it's still ok, with me at least.",
            "date": "2011-09-25T14:09:30.899+0000",
            "id": 6
        },
        {
            "author": "Michael McCandless",
            "body": "Hmm... I like maybeMerge() better because it makes it clear that there may be no merging done?\n\nBut maybe we can find a different word from maybe instead :)  mergeIfNeeded?",
            "date": "2011-09-25T14:27:16.947+0000",
            "id": 7
        },
        {
            "author": "Shai Erera",
            "body": "It's just that maybeMerge feels like asking a question, to which you expect an answer. Why is it so important to have this 'maybe' or 'ifNeeded' in the API? just like optimize(), MP decides what to merge, and optimize() can end up doing nothing as well ...\n\nWhy do we have IR.reopen and not maybeReopen? That that it returns something is not much different than IW.merge(), IMO.",
            "date": "2011-09-25T16:00:31.675+0000",
            "id": 8
        },
        {
            "author": "Eks Dev",
            "body": "as a user, \n- +1 to parameter, if you do not know what NooSegments mean, you shouldn't be invoking this method. \n- what about tryMerge(int ), attempMerge\n",
            "date": "2011-09-25T16:33:25.224+0000",
            "id": 9
        },
        {
            "author": "DM Smith",
            "body": "When I started w/ Lucene, I read the docs and was drawn to call optimize because of its \"cool name.\" However, it was reading the documentation at the time that convinced me that it was appropriate for my use case:\n\nCreating an index that once created would never be modified. It needed to be as fast as possible for search on low performance computing devices (old laptops, ancient computers, netbooks, phones, ...).\n\nMaybe I misunderstood, but wasn't it and isn't it still appropriate for that?\n\nAnd I have no idea what NooSegments means.\n\nIf you want a really uncool name how about dumbDown()?\n\nBut either way, please document the appropriate use cases for it.",
            "date": "2011-09-25T18:12:34.787+0000",
            "id": 10
        },
        {
            "author": "Michael McCandless",
            "body": "bq. Why do we have IR.reopen and not maybeReopen?\n\nThat's a good point... and I actually don't like that naming either!!\n\nI think it trips users up because of it's hidden maybe-ness, ie, users who always close the old reader on calling this API (which, if no reopen actually occurred, closes the very same reader it had just returned).\n\nAlso, IW already has a merge method, taking a OneMerge parameter; that naming I think is correct because it's unconditional: IW will carry out the merge you passed to it.\n\nNaming is the hardest part!",
            "date": "2011-09-25T18:59:39.803+0000",
            "id": 11
        },
        {
            "author": "Mark Miller",
            "body": "In spitball land... requestAggressiveMerge?",
            "date": "2011-09-25T19:53:23.577+0000",
            "id": 12
        },
        {
            "author": "Mike Sokolov",
            "body": "squeeze()?  You apply some pressure - maybe it merges, and maybe it doesn't.  Depending how hard you squeeze.  squeeze(1) is squeezing harder than squeeze(10), which is a bit weird, but that's just down to units of squishiness.",
            "date": "2011-09-25T23:26:12.758+0000",
            "id": 13
        },
        {
            "author": "Jan H\u00f8ydahl",
            "body": "I've seen people optimize after every single add(). Even the Django search framework Solango did this terrible mistake.\nSo I think renaming is welcome, and now that Lucene does such a good merging job for you most people won't need optimize. How about:\n\nreduceSegments(int numSegments)\n\nDoes it convey the \"maybeness\" well enough? If I use it I need to know what a segment is and have some feeling for how many segments there are and how many I want, so its usage will imply some knowledge. But maybeMerge() works as well.",
            "date": "2011-09-26T09:56:59.854+0000",
            "id": 14
        },
        {
            "author": "Doron Cohen",
            "body": "To me merge(num) doing nothing \"because there are already no more than n segments\" is as fine as close() doing nothing \"because of already being closed\" so +1 for merge(num).\n",
            "date": "2011-09-26T12:22:00.246+0000",
            "id": 15
        },
        {
            "author": "Mindaugas \u017dak\u0161auskas",
            "body": "What about \"defragment\"?",
            "date": "2011-10-27T14:21:45.396+0000",
            "id": 16
        },
        {
            "author": "Robert Muir",
            "body": "setting affects 3.x:\n\nHere's my +1 for a hard backwards break to remove this name.",
            "date": "2011-11-03T22:17:48.882+0000",
            "id": 17
        },
        {
            "author": "Grant Ingersoll",
            "body": "How about compactIndex()?",
            "date": "2011-11-03T23:13:38.610+0000",
            "id": 18
        },
        {
            "author": "Michael McCandless",
            "body": "Patch.\n\nI picked the name 'mergeIfNeeded', and it requires you pass in the maxSegmentCount (so mergeIfNeeded(1) == what optimize() does today).\n\nAll tests pass, including Solr, but Solr has tons of user-facing references still to \"optimize\" that I'm not sure how to fix (I tried to remove all references to optimize in Lucene).\n\nI put nocommits for tests that need to be renamed... I'll do that at the last second so patching is easier.",
            "date": "2011-11-04T00:34:16.824+0000",
            "id": 19
        },
        {
            "author": "Yonik Seeley",
            "body": "bq. but Solr has tons of user-facing references still to \"optimize\" that I'm not sure how to fix\n\nThat's fine.  We probably shouldn't be changing Solr's external interfaces (and configuration options) for renamings like this.\n",
            "date": "2011-11-04T00:56:02.047+0000",
            "id": 20
        },
        {
            "author": "Robert Muir",
            "body": "Yonik: I'm not sure? Jan's comment really hits home at why I opened this issue.\n\nI think its worth considering \"optimize\" command to throw an exception in Solr for this reason... we can add an expert option like mergeIfNeeded instead?\n\nI really think optimize is very dangerous because it sounds magical, the kind of thing that tempts new users into getting terrible performance,\ninstead it should be an expert thing.",
            "date": "2011-11-04T00:59:55.904+0000",
            "id": 21
        },
        {
            "author": "Hoss Man",
            "body": "bq. I think its worth considering \"optimize\" command to throw an exception in Solr for this reason... we can add an expert option like mergeIfNeeded instead?\n\nI have mixed feelings on this ... Solr has really tried to ensure that the user level APIs (ie: HTTP params and the xml syntax) are either unaffected by under the cover changes, or provide good backcompat with warnings logged when people use \"deprecated\" syntax.\n\nBut I would suggest that we start by keeping this issue focused on nailing down the java level issues in the \"lucene\" layer and get that committed.  Then when we're sure it's done and settled and happy, create a new issue for tracking the solr level API changes, with considerations like:\n * should we log a deprecation warning to 3.x if <optimize> or param optimize=true is specified, and ignore in 4.x?\n * should the existing 'maxSegments' attribute became an option on \"commit\" or add a new explicit \"merge\" command?\n * what do we do with postOptimize events listener registrations? log a deprecation warning, or rename and fire them if/when a merge to a single segment happens?\n\n(my personal opinion, for any general change not just optimize, is to add new syntax to reflect the new world order, but as long as we *can* support the old syntax we should -- with anoying warning logs)",
            "date": "2011-11-04T01:21:01.436+0000",
            "id": 22
        },
        {
            "author": "Yonik Seeley",
            "body": "It's at least an order of magnitude more painful to change common external interfaces in Solr than in Lucene (or any other type-safe library).  \"optimize\" has been with us a very long time, and it should stay.  It should be both simple and effective enough to clarify the documentation if needed.  Changing the name would cause far more collective confusion and pain than the very small percent of people who might not understand when it's appropriate to call (and changing the name won't help them understand when it is appropriate!).\n\nOn a side note: optimize still does just that - an index with fewer segments and deleted documents is still more efficient to search.  We just need to make sure to document the downsides as well.",
            "date": "2011-11-04T01:37:30.487+0000",
            "id": 23
        },
        {
            "author": "Robert Muir",
            "body": "{quote}\nChanging the name would cause far more collective confusion and pain than the very small percent of people who might not understand when it's appropriate to call (and changing the name won't help them understand when it is appropriate!).\n{quote}\n\nAnd thats exactly my goal here: whatever it takes. I want to cause confusion so that people think twice before calling optimize. Because I totally disagree with you that its a small percentage of people that know when its appropriate to call, when integrations such as Jan's example call it after every commit: thats horrible.\n\nThats why I think we should rename it in lucene, rename it in solr, but if people start pushing back thats fine. \n\nI can totally take this up myself with the blogging/email list route instead and intentionally cause so much fucking confusion that nobody will ever use this again.\n\n",
            "date": "2011-11-04T01:48:14.807+0000",
            "id": 24
        },
        {
            "author": "Yonik Seeley",
            "body": "There should be *extremely* good reasons for changing Solr's external APIs - and this simply doesn't come close to rising to that level.",
            "date": "2011-11-04T01:58:46.168+0000",
            "id": 25
        },
        {
            "author": "Robert Muir",
            "body": "fine, then i'm +1 to mike's patch.\n\nIf solr wants to be slow, then it can stay slow, I'm gonna stop fighting it.\n",
            "date": "2011-11-04T02:01:00.003+0000",
            "id": 26
        },
        {
            "author": "Uwe Schindler",
            "body": "My proposal would be to leave \"optimize\" in Solr, but make it a no-op. No code will break and Solr will just drop a warning not in the log.",
            "date": "2011-11-04T07:25:38.139+0000",
            "id": 27
        },
        {
            "author": "Uwe Schindler",
            "body": "The same could be done in 3.x of Lucene to prevent hard backwards breaks. As optimize does nothing to your index thats visible to the API/IndexReader/..., we could also meke IndexWriter.optimize() a no-op in Lucene 3.x and document it in the javadocs to do nothing anymore and that its only there to support binary backwards.",
            "date": "2011-11-04T07:28:53.163+0000",
            "id": 28
        },
        {
            "author": "Robert Muir",
            "body": "{quote}\nvery small percent of people who might not understand when it's appropriate to call\n{quote}\n\nAre you saying only a small percentage of people use DataImportHandler or SpellChecker?\n\nBecause both of these optimize by default on any operation... ",
            "date": "2011-11-04T08:06:50.656+0000",
            "id": 29
        },
        {
            "author": "Uwe Schindler",
            "body": "Mike, about your patch:\n\nWould it make sense to remove the extra method completely from MergePolicy and simply do all in one method? By default, IW will call merge(maxSegments=Integer.MAX_VALUE) and when you call mergeIfNeeded(n) it would pass merge(maxSegments=n).\n\nOtherwise +1 to commmit. \n\nThe stupid and horrible default optimizes in Solr should be handled in another SOLR-xxx issue.",
            "date": "2011-11-04T09:02:44.400+0000",
            "id": 30
        },
        {
            "author": "Michael McCandless",
            "body": "OK let's leave this issue focused on Lucene only since changing Solr is contentious.\n\nbq. Would it make sense to remove the extra method completely from MergePolicy and simply do all in one method? \n\n+1, good idea!  I'll rework the patch.",
            "date": "2011-11-04T10:37:25.869+0000",
            "id": 31
        },
        {
            "author": "Mark Miller",
            "body": "Perhaps I am the only one, but I find these ifNeeded, mabyeThis, mabyeThat method names so ugly. I prefer JavaDoc for trying to catch the subtleties.\n\n+1 on compact as suggested by Grant or something like that. ",
            "date": "2011-11-04T11:40:10.244+0000",
            "id": 32
        },
        {
            "author": "Robert Muir",
            "body": "But names like compact/vacuum/etc imply that its some sort of necessary maintenance routine...",
            "date": "2011-11-04T11:46:13.900+0000",
            "id": 33
        },
        {
            "author": "Mark Miller",
            "body": "Vacuum may because it's part of the db vocabulary - I don't think compact does at all. Beyond that, that is what javadocs are for. Personally, I don't think we need to try and design the api for complete morons that just call methods without reading the javadoc for what they do.",
            "date": "2011-11-04T12:24:36.699+0000",
            "id": 34
        },
        {
            "author": "Mark Miller",
            "body": "And if we want to keep thinking of the complete moron, I'd make the same argument about mergeIfNeeded - the user might think these needs to be called all the time! My, it doesn't merge when needed? I better call this every couple seconds to make sure it merges when its needed! It's a ridiculous never ending path IMO.",
            "date": "2011-11-04T12:27:05.468+0000",
            "id": 35
        },
        {
            "author": "Robert Muir",
            "body": "I think a lot of damage has been done by the name being optimize: \ne.g.: why does an *incremental* DIH update trigger this by default?\n\nwhat sense does this make?\n\nYou can keep lying to yourself that the only problem is complete morons, i'm not buying it.",
            "date": "2011-11-04T13:02:49.236+0000",
            "id": 36
        },
        {
            "author": "Shai Erera",
            "body": "So now we ended up with mergeIfNeeded and maybeMerge()? At the start of this issue, it looks like we agreed to consolidate all methods under a single maybeMerge(). Mike suggested to have two variants of this, one that doesn't take maxNumSegments and one that does ... I'm fine with that too, as long as we have a single name.\n\nI also agree with Mark, all these maybe's/ifNeeded (IR has these now too !) should be part of the Javadocs, not the method names. For instance, IW.rollback() closes the IndexWriter, but the method is not called rollbackAndClose. IMO, that is even more confusing than the IfNeeded versions, because I do not anticipate the instance to be closed just because I rolled-back changes.\n\nIndexReader.openIfNeeded in fact does reopen() (the old version), but it's not called reopenIfNeeded. So we force the users to read the javadocs in order to understand that openIfNeeded reuses the unchanged segments from the given IndexReader and only opens the new ones ...\n\nNames are hard, and I think we should opt for simple and intuitive ones. Javadocs should be used to clarify what the method does in more details. I personally was never confused by optimize(), so I don't mind if it's kept. But apparently others were confused by it (have no idea why) ...\n\nI don't mind maybeMerge() (perhaps because it's not a new API), but if we want to remove the maybe-ness, let's call it something like invokeMergePolicy() (with and without maxNumSegments)? We can replace invoke by some other verb, maybe consultMP / runMerges ...?",
            "date": "2011-11-04T13:11:52.237+0000",
            "id": 37
        },
        {
            "author": "Yonik Seeley",
            "body": "bq. e.g.: why does an incremental DIH update trigger this by default?\n\nNot sure...  If they actually meant for this to happen, this just reinforces my point that the name of the call is not the issue.  The guys who wrote DIH absolutely know what optimize does - hence if it was renamed they would have simply called maybeMerge(1) or whatever today.\n\nAt the time it was written, and depending on what it was used for, maybe it did make sense.\n\nbq. You can keep lying to yourself that the only problem is complete morons, i'm not buying it.\n\nThat's exactly it - it's not morons, so a simple name change won't really help.  We need to document the *current* tradeoffs so people can make more informed decisions about when to optimize.  And some people will *still* chose to maybeMerge(1) when others think maybe they shouldn't.  That's OK.\n",
            "date": "2011-11-04T13:58:10.717+0000",
            "id": 38
        },
        {
            "author": "Robert Muir",
            "body": "{quote}\nAt the time it was written, and depending on what it was used for, maybe it did make sense.\n{quote}\n\nYou are missing the whole point, now it defaults to optimize on each incremental update, basically O(n^2) indexing performance,\nunless the *user* knows enough to know that optimize = shitty perf here and explicitly turn it off. and given its cool-sounding name,\nit discourages them from even questioning that it could be making things slow.\n\n",
            "date": "2011-11-04T16:05:46.434+0000",
            "id": 39
        },
        {
            "author": "Michael McCandless",
            "body": "\nHow about the name \"forceMerge(int)\" instead?\n\nFundamentally, this is a different operation from maybeMerge() because\nthat method only does \"natural\" merges, ie ones that the MP has\nselected on its own.\n\nWhereas forceMerge means you are forcing the MP to do merging that it\notherwise would not have naturally chosen to do.\n\nI don't like names like compact/defragment since they still imply this\nis a sort of necessary periodic maintenance that you are expected / need\nto call.\n\nThe fact is, Lucene has made excellent progress on getting good\nperformance on multi-segment indexes: Query rewriting (eg MTQ) and\nsearching is per-segment.  TieredMP now targets segments with\ndeletions, and can merge out-of-order, etc.  Reducing the index down\nto 1 segment is rarely justified given the cost (yes, there are times,\nlike a fully static index, but this is rare).\n\nThe goal here is to discourage \"typical\" users from calling\noptimize (\"expert\" users will of course find the method and use it,\nhopefully in the \"right\" cases).\n\nThe API is badly trappy today; we've seen this over and over now (I\njust got a private email a few days ago... when I asked why they\noptimize after every \"batch\" they said \"because it just seemed like\nthe right thing to do\").  We've all seen many users fall into this\ntrap.\n\nWe can try to debate why this is so... I don't think it's because they\nare \"morons\".  I think there are many other explanations.  EG, our own\nFAQs, javadocs, the Lucene in Action book, tutorials, etc., all\nfrequently \"suggested\" optimize in the past.  I think, also, users\noften don't realize Lucene has \"segments\" and that optimize means\nthese segments are \"fully rewritten\" and that this then implies O(N^2)\ncost if you call after every doc/batch, etc.  These things are obvious\nto Lucene developers, but not so to users.\n",
            "date": "2011-11-06T15:52:38.327+0000",
            "id": 40
        },
        {
            "author": "Michael McCandless",
            "body": "bq. For instance, IW.rollback() closes the IndexWriter, but the method is not called rollbackAndClose.\n\nI agree, this is bad, because it's unexpected that the IW is closed: I\nthink we should rename it to rollbackAndClose (I'll open a separate\nissue).\n",
            "date": "2011-11-06T15:59:08.574+0000",
            "id": 41
        },
        {
            "author": "Doron Cohen",
            "body": "bq. Perhaps I am the only one, but I find these ifNeeded, mabyeThis, mabyeThat method names so ugly. I prefer JavaDoc for trying to catch the subtleties.\n\nI feel that way too.\n\nBut a name change here seems in place, because as pointed above, there is an issue with current catchy name *optimize()*.\n\nMy personal preference between the names suggested above is Mike's last one: *forceMerge(int)*:\n- it describes what's done\n- does not suggest to do wonders\n- requires caller to think twice because of deciding to force a certain behavior",
            "date": "2011-11-06T17:17:30.758+0000",
            "id": 42
        },
        {
            "author": "Shai Erera",
            "body": "{quote}\nHow about the name \"forceMerge(int)\" instead?\n\nFundamentally, this is a different operation from maybeMerge() because\nthat method only does \"natural\" merges, ie ones that the MP has\nselected on its own.\n\nWhereas forceMerge means you are forcing the MP to do merging that it\notherwise would not have naturally chosen to do.\n{quote}\n\nI'm not sure that I agree ... I could set MP in such a way that forceMerge(1) would still do nothing. That's very simple in fact, and I do this today. I set LogMP's maxMergeMB(ForOptimize) to 4GB, which means that I never end up merging segments larger than that. I call optimize() whenever I can, but at some point, optimize will do nothing (if the indexing process stops), or after my index grew a lot, many segments won't be merged, and optimize/forceMerge(1) will actually end up with X+1 segments, where X is the number of segments that are too large for me to merge.\n\nTherefore I'm not sure that trading optimize for forceMerge is much better. Sure, it has a less cool name, but now I think it will be even more confusing, because I'll call forceMerge(1) and that won't do what I asked.\n\nI think that the problem is that we try to come up with names that reflect what API we IndexWriter should call on MP. That's why we try to distinguish between maybeMerge() and optimize(int). So maybe we should go for a more extreme change -- how about having one method merge() which takes a MergePolicy with a single method findSegmentsForMerge(). We will provide MPs that are good for 'regular' merges and 'optimize' and the user can pass whatever he wishes to do. The user can also pass the same MP instance to IWC, and that will control the regular merges IW does from time to time (we default to a 'regular' merging MP).\n\nJust a thought.",
            "date": "2011-11-06T19:02:11.707+0000",
            "id": 43
        },
        {
            "author": "Mark Miller",
            "body": "I like forceMerge. I'm not opposed to renaming optimize, just one of the candidates so far and some of the new method names in general. Optimize is not the best description IMO regardless of how catchy it is. It's not really optimal for NRT as just one of many points...",
            "date": "2011-11-06T21:06:46.630+0000",
            "id": 44
        },
        {
            "author": "Michael McCandless",
            "body": "Some quick googling uncovers depressing examples of over-optimizing:\n\nhttps://jira.duraspace.org/browse/FCREPO-155\n\nhttp://stackoverflow.com/questions/3912253/is-it-mandatory-to-optimize-the-lucene-index-after-write\n\nhttp://issues.liferay.com/browse/LPS-2944\n\nhttp://download.oracle.com/docs/cd/E19316-01/820-7054/girqf/index.html\n\nhttps://issues.sonatype.org/browse/MNGECLIPSE-2359\n\nhttp://blog.inflinx.com/tag/lucene\n\nThat last one has this fun comment:\n\n{noformat}\n  // Lucene recommends calling optimize upon completion of indexing writer.optimize();\n{noformat}\n",
            "date": "2011-11-06T21:17:29.650+0000",
            "id": 45
        },
        {
            "author": "Mark Miller",
            "body": "I'm not sure sure that is a strong case.\n\nThe ones that mention optimizing after loading all your data is practically what had been often recommended for some time. Can't say the same about optimizing after every add.\n\nHowever, up to most of Lucene 2, we still had JavaDoc that said:\n\n{quote}\nIf an index will not have more documents added for a while and optimal search performance is desired, then the optimize method should be called before the index is closed.\n{quote}\n\nBased on that, I'd likely think I should optimize after bulk loading up all my data like one of those links asks about.\n\nThe optimize javadoc itself even simply said:\n\n{quote}\nRequests an \"optimize\" operation on an index, priming the index for the fastest available search. Traditionally this has meant merging all segments into a single segment as is done in the default merge policy, but individaul merge policies may implement optimize in different ways.\n{quote}\n\nSince, much of this javadoc had gotten better. But it's no surprise that there are cases of confusion out there? Most of those are from before this javadoc was fixed - and even then the old code and javaodoc/advice are out there reverberating around on google.\n\nThe situation with the javadoc is much better today - someone shouldn't need to ask those questions, or have those problems, but the *javadoc* used to be a trap in showing this great optimize method and not properly explaining or warning about its use.\n\nCreating method names for cowboy method calling coders that don't read javadoc seems like the wrong approach to me.\n\nThough I'm still +1 on renaming optimize to something more fitting.",
            "date": "2011-11-06T22:31:27.316+0000",
            "id": 46
        },
        {
            "author": "Shai Erera",
            "body": "Well ... I don't like forceMerge for two reasons: (1) it may not actually force anything and (2) it takes a parameter maxNumSegments which is just one of the factors one would want to consider when doing optimize/merge. For instance, when I do index optimization, I cap the process by a time constraint and let it run until the time is exhausted. Given that today I can either call maybeMerge() or optimize(), I call optimize(), and I like it that I don't need to pass any 'fake' parameter, even though I'm aware that under the covers it does optimize(1).\n\nWhat about expungeDeletes? Why is it not called maybeExpungeDeletes? Because by tweaking MP settings I can make it leave some deletes in segments. And why isn't it called expungeDeletesThenMerge or expungeDeletesNoMerge (ala the now gone addIndexesNoOptimize)? Don't get me wrong (before anyone opens an issue to rename it too) - I like expungeDeletes! :)\n\nI feel that we mask from the user what happens under the covers when he calls any of the 3 methods (maybMerge, optimize, expungeDeletes). maybeMerge relate to mergeFactor as a bounding criteria (don't merge if there are aren't X segments at the same level), while optimize just uses it to determine how many segments to merge at once, and expungeDeletes ignores it altogether.\n\nSo if MP determines so much what will happen when IndexWriter calls it, why hide it from the method call? Instead of setting an MP once on IWC and hope that the settings I've done will match any future call to one of these methods, why not allow the user to pass the desired MP for the action he wants to perform? That way we can focus MP implementations on specific tasks.",
            "date": "2011-11-07T04:33:58.799+0000",
            "id": 47
        },
        {
            "author": "Michael McCandless",
            "body": "bq. I could set MP in such a way that forceMerge(1) would still do nothing. That's very simple in fact, and I do this today.\n\nSure, but remember: 1) this is the exception case (not the rule), and\n2) you are an expert user.\n\nWe should name our APIs according to what they \"typically\" do, not by\nthe exceptional cases, which can and should be handled by javadocs\n(for example, that you must close your IW if you hit OOME during\naddDocument).\n\nThe expert users (like you) who are bumping up against these\nexceptions can easily understand and handle them.\n\nI think forceMerge(int) does a pretty good job explaining what the MP\nis going to try to do.\n\nbq. I think that the problem is that we try to come up with names that reflect what API we IndexWriter should call on MP. \n\nRight, optimize() is really sugar for \"invoking the current MP and do\nwhatever it says\".\n\nbq. So maybe we should go for a more extreme change \u2013 how about having one method merge() which takes a MergePolicy with a single method findSegmentsForMerge().\n\nThis is a great idea!  But I think we should pursue it under a new\nissue, after renaming the optimize method?  It's a bigger change.\n\nIf we took this approach... I think IW would still need a \"default MP\"\nthat it uses to kick off natural merges over time?  (Ie, after a new\nsegment is flushed).\n\nAlternatively, we could have this extra MP sit fully \"outside\" of IW,\nand so instead of calling IW.merge(MP) you'd call MP.merge(IW), and\nthat \"foreign\" MP would register merges with IW?  Still, it's gonna\nget tricky, how the \"natural\" MP interacts with this foreign MP.\n\nOr... maybe we remove IW.optimize, and instead open up a method on\neach MP impl (eg MP.forceMerge(int)), and you invoke this method on\nthe MP instead?  This way you still have the one MP, but IW doesn't\nneed to expose hard-to-name sugar?  Still sounds tricky though... the\nMP would ask IW to maybeMerge\n",
            "date": "2011-11-07T17:52:05.587+0000",
            "id": 48
        },
        {
            "author": "Shai Erera",
            "body": "bq. Sure, but remember: 1) this is the exception case (not the rule)\n\nI disagree ... I find myself more and more these days telling people to limit their merge size because of performance issues, whether it's for optimize/maybeMerge. Therefore I don't think it's the exception case, or will remain like that for long.\n\nbq. I think forceMerge(int) does a pretty good job explaining what the MP is going to try to do.\n\nIs that a Javadoc statement? Because we could have just fixed optimize() javadocs without adding API that sort of commits to something that may not happen.\n\nHow about naming it doMaintenance?\n\n{code}\nIf we took this approach... I think IW would still need a \"default MP\"\nthat it uses to kick off natural merges over time? (Ie, after a new\nsegment is flushed).\n{code}\n\nSure, we will provide the best MP for doing natural/regular merges which will be the default of IWC.\n\nI agree this route is bigger than just renaming optimize(), and I don't think that we need to change the interaction between IW and MP. But let's handle that in a separate issue.",
            "date": "2011-11-08T06:36:28.696+0000",
            "id": 49
        },
        {
            "author": "Michael McCandless",
            "body": "\n{quote}\nbq. Sure, but remember: 1) this is the exception case (not the rule)\n\nI disagree ... I find myself more and more these days telling people to limit their merge size because of performance issues, whether it's for optimize/maybeMerge. Therefore I don't think it's the exception case, or will remain like that for long.\n{quote}\n\nBut today, in 3.x or trunk (ie TieredMergePolicy), if you call\nforceMerge(N) this will in fact merge away until you have <= N\nsegments.\n\nI think if you use either LogDoc/ByteSizeMergePolicy, forceMerge also\ndoes what it says.  It's only if you change their maxMBForOptimize from\nthe default, and you have a large enough index to hit that limit, that\nforceMerge(1) may in fact produce more than one segment.\n\nSo, sure, if you go and change the settings, swap in a different\nMergePolicy, etc., you can make it so IW.forceMerge(int) does\nsomething totally different.  But that's the exception, not the rule;\nthat's what the \"experts\" do, not the normal users who use the\ndefaults.\n\n{quote}\nbq. I think forceMerge(int) does a pretty good job explaining what the MP is going to try to do.\n\nIs that a Javadoc statement? Because we could have just fixed optimize() javadocs without adding API that sort of commits to something that may not happen.\n{quote}\n\nI think in the javadocs we should explain that forceMerge just asks\nthe MP to pick merges, passing the minSegmentCount, ie explain the\n\"exception case\" via javadocs and let the method name explain the\ncommon case.  I think this is in general how we should name our\nmethods...\n\nbq. How about naming it doMaintenance?\n\nI don't really like that choice, for the same reason I don't like\ndefragment/compact: it implies you (the app) are expected to\nperiodically call it, whereas forced merging is very much an optional\noperation since Lucene works so well against multi-segment indexes\nthese days.\n\n{quote}\nbq. If we took this approach... I think IW would still need a \"default MP\" that it uses to kick off natural merges over time? (Ie, after a new segment is flushed).\n\nSure, we will provide the best MP for doing natural/regular merges which will be the default of IWC.\n\nI agree this route is bigger than just renaming optimize(), and I don't think that we need to change the interaction between IW and MP. But let's handle that in a separate issue.\n{quote}\n\nCan you open a new issue so we can explore the foreign-MP idea?\nReplacing optimize/forceMerge and expungeDeletes with a new\n\"merge(MP)\" seems compelling.\n\nLet's leave this issue on the simple renaming....\n",
            "date": "2011-11-08T23:49:51.694+0000",
            "id": 50
        },
        {
            "author": "Shai Erera",
            "body": "bq. Can you open a new issue so we can explore the foreign-MP idea?\n\nI will.",
            "date": "2011-11-09T08:16:51.761+0000",
            "id": 51
        },
        {
            "author": "Michael McCandless",
            "body": "OK, LUCENE-3569 will explore the foreign MergePolicy approach.\n\nBack to this issue... we won't be able to find a name that everyone\nloves, of course (this is why naming is the hardest part!).\n\nBut forceMerge got at least some traction (3 people OK'd it), and it\ndoes explain what you get from Lucene today, out of the box.  I think\nit's a good improvement over what we have today (optimize).  Progress\nnot perfection...\n\nShai, are you absolutely dead set against the name \"forceMerge\"?  I\nmean it's clear you'd like to do a bigger change (LUCENE-3569), but in\nthe mean time, forceMerge is at least better than optimize?\n\nAnd if you are dead set against it, can you enumerate some alternative\nnames?  We need to find a name that nobody hates (hopefully\npossible)... not one that everybody loves (not possible).\n\nNaming is the hardest part ;)\n",
            "date": "2011-11-10T11:50:24.231+0000",
            "id": 52
        },
        {
            "author": "Shai Erera",
            "body": "bq. Shai, are you absolutely dead set against the name \"forceMerge\"?\n\nNo, I am not dead set against it. Feel free to proceed with forceMerge for now, because I don't want to hold up this issue.\n\nObviously I'm on the minority side ...",
            "date": "2011-11-10T12:58:30.106+0000",
            "id": 53
        },
        {
            "author": "Michael McCandless",
            "body": "OK thanks Shai. I'll work up a new patch...",
            "date": "2011-11-10T13:19:54.990+0000",
            "id": 54
        },
        {
            "author": "Michael McCandless",
            "body": "OK, new patch with \"forceMerge\".  I think it's ready to commit!\n\nI left the MergePolicy method separate (renamed to findForcedMerges);\nI'm not sure we should merge it with the findMerges since that one\nfinds \"natural\" merges.  But we can explore on a new issue... this\npatch is immense and \"rote\" renaming so I plan commit soon...\n\nThe patch should be applyable; I generated with \"svn diff\n--show-copies-as-adds\" (svn 1.7).\n",
            "date": "2011-11-10T18:38:04.902+0000",
            "id": 55
        },
        {
            "author": "Uwe Schindler",
            "body": "Bulk close after release of 3.5",
            "date": "2011-11-27T12:29:30.083+0000",
            "id": 56
        }
    ],
    "component": "",
    "description": "I think users see the name optimize and feel they must do this, because who wants a suboptimal system? but this probably just results in wasted time and resources.\n\nmaybe rename to collapseSegments or something?",
    "hasPatch": true,
    "hasScreenshot": false,
    "id": "LUCENE-3454",
    "issuetypeClassified": "REFACTORING",
    "issuetypeTracker": "IMPROVEMENT",
    "priority": "Major",
    "product": "LUCENE",
    "project": "LUCENE",
    "summary": "rename optimize to a less cool-sounding name",
    "systemSpecification": true,
    "version": "3.4, 4.0-ALPHA"
}