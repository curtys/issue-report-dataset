{
    "comments": [
        {
            "author": "Mark Miller",
            "body": "There are two highlighting modes: highlight entire spans or highlight first and last word of each span. For the highlight first and last word of span it would probably be better to change QuerySpansExtractor.getSpansFromPhraseQuery so that it creates a series of near spans instead of a single near span with multiple clauses.",
            "date": "2007-02-04T18:25:20.330+0000",
            "id": 0
        },
        {
            "author": "Mark Harwood",
            "body": "Looks like a good start, Mark - thanks for contributing this!\n\nI've had a quick play and have identified the following issues:\n\n1) Fieldname \"contents\" shouldn't be hardcoded into the Highlighter - different analyzers can behave differently for different fields (see PerFieldAnalyzerWrapper). Either pass a fieldname parameter or do as the existing highlighter does and take a TokenStream. The latter approach has the advantage of being able to avoid re-analysis and make use of any stored TermVectors (see TokenSources.java)\n2) Analyzers which produce overlapping tokens (see Synonym analyzer in existing highlighter Junit test) are problematic in the existing code. I remember the \"TokenGroup\" class in the existing highlighter was an approach to help cater for these \"overlap\" scenarios.\n3) Without wishing to resurrect the whole 1.4 vs 1.5 debate I beleive Lucene still targets Java 1.4. \n\nTo rectify these points it's not clear to me if it would be quicker to use your code or adapt the existing highlighter code to use spans.\nThoughts?\n\nThanks, again,\nMark\n\n\n\n\n\n ",
            "date": "2007-02-04T21:29:05.218+0000",
            "id": 1
        },
        {
            "author": "Mark Miller",
            "body": "Sorry about all that Mark H. This was literally just some test code that I quickly shoved into an api similar to your existing highlighter. If you decided that it should be something considered on it's own I would certainly have quite a bit further to go. Mostly I just put it up for your evaluation on extending the current highlighter with this highlight method.\n\n>1) Fieldname \"contents\" shouldn't be hardcoded into the Highlighter - different analyzers can behave differently for different fields (see >PerFieldAnalyzerWrapper). Either pass a fieldname parameter or do as the existing highlighter does and take a TokenStream. The latter approach >has the advantage of being able to avoid re-analysis and make use of any stored TermVectors (see TokenSources.java)\n\nI don't have a great solution for this right now. I need to read the TokenStream at least twice due to the MemoryIndex extracting the spans. Unfortunately, it seems I can copy the tokens to a list or pass them to the MemoryIndex -- I cannot do both. The MemoryIndex is also looking for a field name...so while I changed the api to take a TokenStream, I have not resolved also needing the field name. I am hoping you have some good comments. To get around reading the TokenStream twice I used the horribly hackey but quick-for-me method of adding a method to MemoryIndex that accepts a List of Tokens. Any ideas?\n\n2) Analyzers which produce overlapping tokens (see Synonym analyzer in existing highlighter Junit test) are problematic in the existing code. I remember the \"TokenGroup\" class in the existing highlighter was an approach to help cater for these \"overlap\" scenarios.\n\nI always attack this last <G>. Seems a simple fix: if position increment equals 0 skip printing out the token. It passes your test which I have added to my test code, but I am not totally confident it is perfect yet.\n\n3) Without wishing to resurrect the whole 1.4 vs 1.5 debate I beleive Lucene still targets Java 1.4.\n\nJust me being lazy. I swear I have seen Contrib stuff that says 1.5. I have gone through and stripped out all of the 1.4 except for StringBuilder for the moment.\n\n>To rectify these points it's not clear to me if it would be quicker to use your code or adapt the existing highlighter code to use spans.\n>Thoughts? \n\nDepends entirely on what you think. I am sure I can fix all of the issues you mention (with a little advice <G>), but I am pretty new to this type of thing and perhaps you just want to start from scratch in order to achieve span highlighting with the existing highlighter. It may just be that the way I am doing this is not very compatible with the way you currently fragment and score.\n\nI have added an updated Highlighter.java and HighlighterTest.java. The MemoryIndex problem remains...so it either has to be fixed or the modified MemoryIndex must be used.\n\n- Mark m",
            "date": "2007-02-04T23:36:44.093+0000",
            "id": 2
        },
        {
            "author": "Otis Gospodnetic",
            "body": "There is indeed some Java 1.5 code in contrib/  I believe the gdata-server uses 1.5 classes.  I think that's okay for contrib.",
            "date": "2007-02-05T18:59:49.766+0000",
            "id": 3
        },
        {
            "author": "Mark Harwood",
            "body": ">>Sorry about all that Mark H\nNo need for any apologies - all help is gratefully received!\nI don't mean to criticise your efforts or seem picky - I just wanted to record my findings somewhere useful if we were to consider working a solution up from this \"test code\" rather than tweaking the current highlighter - I'm still uncertain about the best approach. I also thought it might be useful to point the potential issues out to you if you were already reliant on using this code somewhere.\n\n>>I need to read the TokenStream at least twice\n>>I used the horribly hackey but quick-for-me method of adding a method to MemoryIndex that accepts a List of Tokens. Any ideas? \n\nI'm not sure about modifying MemoryIndex. It should be easy enough to create a subclass of TokenStream - (\"CachedTokenStream\" perhaps?) which takes a real TokenStream in it's constructor and delegates all \"next\" calls to it (and also records them in a List) for the the first use. This can then be \"rewound\" and re-used to run through the same set of tokens held in the list  from the first run.\n\n\n>>if position increment equals 0 skip printing out the token...but I am not totally confident it is perfect yet. \n\nI think it's possible some of the more Byzantine analyzers may have a position increment >0 but overlap in terms of their byte offsets. I'd need to check the old Junit tests to be sure on this. Welcome to my hell!\n\nThanks again for your help.\nMark H",
            "date": "2007-02-05T19:43:14.491+0000",
            "id": 4
        },
        {
            "author": "Mark Miller",
            "body": "Removed 1.5 dependencies, fixed api ",
            "date": "2007-02-05T22:13:01.971+0000",
            "id": 5
        },
        {
            "author": "Mark Miller",
            "body": "I switched to accepting an analyzer and a field name. I need the field name anyway for the MemoryIndex.\n\n I agree that modifying MemoryIndex was horrible and I have removed that dependency (just did it as a 'quickfix'). \n\nI used the CachedTokenStream anyway to avoid analyzing twice (once for MemoryIndex and again for Highlighter use. Thanks for the idea...shows how bright I am having missed it <g>).\n\nI removed all of the 1.5 code.\n\nThe code is probably fairly usable right now then. I think synonyms work fine unless a case does exist like you suggested.\n\nSo I suppose we have 4 options:\n\n1. I extend and polish the code (needs more test cases, most of mine where written using my query parser) and it is used independently for full document highlighting based on spans. (I would like to add google cache like coloring)\n\n2. The code is either merged with the existing highlighter or gutted to create a single highlighter that can fragment based on spans or based on the original term based approach.\n\n3. The code is ignored and someone else starts fresh adding span support to the existing highlighter.\n\n4. The code languishes in purgatory and we await the unknown.\n\n- Mark M\n\n",
            "date": "2007-02-05T22:23:44.613+0000",
            "id": 6
        },
        {
            "author": "Mark Miller",
            "body": "Updated code to address deficiency in highlighting BooleanQueries.\n\nUse the following latest classes:\n\nCachedTokenStream\nDefaultEncoder\nEncoder\nFormatter\nHighlighter\nQuerySpansExtractor\nSimpleFormatter\nHighlighterTest",
            "date": "2007-02-16T01:07:17.611+0000",
            "id": 7
        },
        {
            "author": "Mark Miller",
            "body": "Using an Analyzer that produces multiple tokens at the same position does not yet operate correctly if used at query time. Using such a 'synonym' analyzer for indexing and a non 'synonym' analyzer for searching will work fine.",
            "date": "2007-02-16T01:10:31.327+0000",
            "id": 8
        },
        {
            "author": "Mark Miller",
            "body": "I had some free time today and came back this issue. I was so set on my own needs to start on this that I completely ignored looking closely at the contrib highlighter code. I went back and read over it this morning and am in the middle of a new solution. The new solution is in the form of new SpanQueryScorer that extends Scorer and plugs into the original contrib highlighter code. I have adapted almost all of the original tests (still a few to go) and so far they all still pass using the SpanQueryScorer. There is no guarantee yet that Spans will not be chopped up, but I am sure there is a way to share Span info with a Fragmenter if you wanted to rectify this (I may get to it). I also have not implemented a scoring properly yet...at the moment any term that is found returns a score of 1, and each unique term in a fragment contributes 1 to the fragment score. I will look at going further here, but I will be posting the code first after I convert the rest of the relevant tests and add a few Span Query tests.\n\nI am pretty confident this will be a great solution for 'actual hit' highlighting with the already tried and true contrib Highlighter, fragments and all.\n\n-Mark",
            "date": "2007-02-18T00:03:21.515+0000",
            "id": 9
        },
        {
            "author": "Mark Harwood",
            "body": ">>I am pretty confident this will be a great solution \n\nGreat stuff, Mark. Sorry I've been out of the loop on this recently and not participating as much as I'd like - just too tied up with other work. \nI look forward to seeing your work!\n\nCheers,\nMark H",
            "date": "2007-02-18T00:44:29.866+0000",
            "id": 10
        },
        {
            "author": "Mark Miller",
            "body": "Howdy Mark H, I have not got into making new SpanQuery tests yet, but at this point I could use some help/guidance. All of the original highlighter tests are passing with the new SpanScorer except for two: \n\n1. testFieldSpecificHighlighting\n\nThis will not pass the second assertion (ignore fields) because when i add the TokenStream to a MemoryIndex I have to add it to a field. I am stumped on getting around this one.\n\n2. testOverlapAnalyzer2\n\nPasses the first bunch but then fails on one. This is because I am looking up terms based on position since the Spans do not return the term text. The first assertion failing is looking for 'hi-<b>speed</b>' but finds '<b>hi-speed</b>' because both 'speed' and 'hi-speed' are at position 0...consequently both score a 1. Any thoughts? I was thinking about gathering all possible terms in the SpanQueryExtractor and someone using them...\n\nBeyond that, I am sure you can find plenty of other things to point out . Have at me <g>\n\nAny ideas on scoring would be appreciated as well.\n\nFeel free to run with this on your own if you have time as well...or run with it a bit and pass it back, or just provide some guidance as I go...whatever works out best for you.\n\n- Mark M",
            "date": "2007-02-18T21:44:31.071+0000",
            "id": 11
        },
        {
            "author": "Mark Miller",
            "body": "By the way...I apologize the file list is so messy now.\n\nYou just need:\n\nSpanScorer\nSpanQueryExtractor\nCachedTokenStream\nSpanHighlighterTest\n\nand there is the dependency on MemoryIndex",
            "date": "2007-02-18T21:46:19.187+0000",
            "id": 12
        },
        {
            "author": "Mark Miller",
            "body": "Almost at the holy grail here. Everything works except the optional ignoring fields in the Query object. Scores work, all other tests pass, and even better there is no more limitation of only highlighting the first and last term in a Span -- instead all correct terms in each Span will be highlighted. The only change to the existing code I had to make was to add a parameter to scoreToken(Token token) -- I had to add int position.\n\nI still think it is very feasible to pass info from this SpanScorer to a Fragmenter so that the Freagmenter can attempt to avoid splitting up Spans.\n\nThe current code will correctly highlight pretty much any standard or span query ( I think <g>) based on 'actual' hits using the exisiting contrib highlighter code...I have yet to write out the new extensive Span tests and I would appreciate it if some others would go over the code for some obvious improvements, but this is almost ready.\n\nGet the latests:\nSpanScorer\nSpanQueryExtractor\nCachedTokenStream\nSpanHighlighterTest \nWeightedSpanTerm\nHighlighter\n\n- Mark",
            "date": "2007-02-20T22:18:02.435+0000",
            "id": 13
        },
        {
            "author": "Karl Wettin",
            "body": "Mark, I'll take a look at this any year now. I think the code can be used or tweaked to act as \"term order suggestion\" and \"untokenized cosmetic suggestion from stored values\" in my didyoumean-patch.\n\nIs there some documentation that describes this patch in a  chronologically ordered text rather than \"just\" the java docs? Some simple package level html would probably help me to get started.",
            "date": "2007-02-20T22:37:11.724+0000",
            "id": 14
        },
        {
            "author": "Mark Miller",
            "body": "I have a patch coming tonight. It fixes a few odd mistakes and has a little more documentation. I had wanted to subpackage it into spanscorer for now, but it appears I can't make a patch with a new folder so that is out. Should I merge my package.html documentation with the one currently in highlighter? Also, I am not sure how a contrib that depends on another contrib should work build file wise (SpanScorer depends on MemoryIndex). I just made up something that works for now.\n\nThis new patch will be off the trunk so now the RangeQuery test fails as it does with the original QueryScorer...you cannot highlight a constantrangequery to my knowledge.\n\nYou also cannot ignore the fields in the query as you can with QueryScorer so that test fails. The only way that I can see doing this is to have the option in your query parser of ignoring all fields and just using one field name during parsing. Send the field-normal Query to search, and then make a field-neutered query for highlighting. That is the approach I will be taking with my query parser. I sure wish there was something better though.\n\nIll post the patch when I get out of work.\n\n- Mark",
            "date": "2007-02-22T13:18:33.106+0000",
            "id": 15
        },
        {
            "author": "Mark Miller",
            "body": "Forget all the .java files...just get spanhighlighter.patch and apply to the trunk.\n\nStill looking for pointers on how to handle to build.xml",
            "date": "2007-02-23T00:03:18.267+0000",
            "id": 16
        },
        {
            "author": "Mark Harwood",
            "body": "Hi Mark,\nI found a little time to look at the span Highlighter the other night and was struggling with some missing bits and pieces (updated Scorer, missing SynonymAnalyzer etc) so only got as far as getting it all to compile before I ran out of time. Hopefully the patch will make life easier - will investigate when I have another chance.\n\nAs for the build.xml - have a look at XMLQueryParser's build.xml in contrib. This has a dependency on the \"queries\" contrib module added to the build.xml.\n\nCheers\nMark H",
            "date": "2007-02-23T08:27:10.414+0000",
            "id": 17
        },
        {
            "author": "Mark Miller",
            "body": "Yeah the patch should take care of all of that...I would have started with a patch, but this was literally my first and it took me a bit to figure it all out, especially with eclipses subclipse plugin using absolute paths instead of relative in the patch..then I was trying forever to add a new package before finding out I can't add a folder to a patch...but now that I got it all worked out it should make life much easier for anyone trying this <g> I will use patches from now on.\n\nThanks for the build.xml info and for taking a look.",
            "date": "2007-02-23T11:52:41.342+0000",
            "id": 18
        },
        {
            "author": "Mark Miller",
            "body": "Patch version 2\n\nChanged to correct build.xml, removed some unneeded code\n\nHas been working well for me personally, could still use some additional span highlighting tests\n",
            "date": "2007-02-28T01:08:02.987+0000",
            "id": 19
        },
        {
            "author": "Mark Miller",
            "body": "This patch tries another approach instead of changing the existing Highlighter api. The result is that if you call getBestFragments more than once, you must call reset() on the SpanScorer between each call. Whether this is better than modifying the existing api, I am not sure.\n\nThis patch also adds a new SimpleSpanFragmenter that fragments based on size, but ensures that Spans are not broken up. This class might not be perfect yet.",
            "date": "2007-03-06T22:28:35.153+0000",
            "id": 20
        },
        {
            "author": "Mark Miller",
            "body": "I have finally come up with a way to ignore fields and so the final test (testFieldSpecificHighlighting) passes for this. Now all original Highlighter tests pass with this patch. Pass null as the field to SpanScorer and fields will be ignored during highlighting.\n\nSpanScorer now has the same behavior as the QueryScorer except that actual hits are highlighted.\n\nI have also made a small fix to the SimpleSpanFragmenter.\n\nI am still not sure if it is better to change the Highlighter API or require the kind of nasty call to reset the SpanScorer between calls to getBestFragments.\n\nI have used a zip file this time. It contains the patch plus an index folder that holds a new class called TermModifier. This was necessary because I cannot add folders to the patch, but TermModifier needs to be in the org.apache.lucene.index package. First apply then patch, then add the index folder to the correct place in the Highlighter contrib section.\n\nNot a lot left to do here. What do you think Mark H? \n\n- Mark",
            "date": "2007-03-07T22:36:59.976+0000",
            "id": 21
        },
        {
            "author": "Mark Harwood",
            "body": "Hi Mark,\nGot the code patched and running here.\nJunit seems to work fine but I feel a little uncomfortable about use of the TermModifier class. Using this has the potentially undesirable side-effect of changing the client's query field. If they plan on re-running the same query this could be a problem.\n\nI'll need to have a think if there is a better solution to this.\n\nCheers,\nMark",
            "date": "2007-03-10T23:04:51.590+0000",
            "id": 22
        },
        {
            "author": "Mark Miller",
            "body": "Hey Mark,\n\nI wasn't too happy about TermModifier either since I am basically violating encapsulation...TermModifier basically makes field public. I really don't see how it is possible to ignore fields in another way though. If you can think of a way, that would be awesome . At a minimum, the Term fields could be set back to their original value after doing the Span search...I wouldn't think that would be much of a performance hit.\n\n- Mark",
            "date": "2007-03-10T23:34:51.251+0000",
            "id": 23
        },
        {
            "author": "Mark Harwood",
            "body": ">>At a minimum, the Term fields could be set back to their original value after doing the Span search..\n\nHmm. If the query is being reused in a multi-threaded server environment this wouldn't fly.\n\n>>I really don't see how it is possible to ignore fields in another way though\n\nI can think of one. Your current approach is based on modifying the query to suit the MemoryIndex content. Another approach may be to modify the MemoryIndex content to suit the query. Your code creates a MemoryIndex when presented with the text of a field. If it recognised it was being used in \"field-insensitive mode\" it could extract the query terms and create a MemoryIndex field for each unique fieldname in the set of query terms - using the same source text (a CachedTokenStreamAnalyzer  could be used to avoid excessive tokenization of this text)\nThis approach would of course use some more memory but avoids the unpleasantness of changing Query objects' contents.\nI haven't fully considered the implications of this idea yet - initial thoughts?\n\nCheers\nMark",
            "date": "2007-03-12T19:33:40.499+0000",
            "id": 24
        },
        {
            "author": "Mark Miller",
            "body": "\"Another approach may be to modify the MemoryIndex content to suit the query. Your code creates a MemoryIndex when presented with the text of a field. If it recognised it was being used in \"field-insensitive mode\" it could extract the query terms and create a MemoryIndex field for each unique fieldname in the set of query terms\"\n\nThis should work fine. I had dismissed it ( and again butted heads with it for a while now that you mentioned it) because I couldn't see the forest through the trees. I kept thinking, this is just not going to work with a Span query that has terms from different fields. Over and over I thought that. How can I ignore fields in a SpanQuery. Now it hits me, rather embarrassingly, such a SpanQuery doesn't make sense at all.\n\nI will try your approach and submit a new patch.\n\n- Mark",
            "date": "2007-03-12T22:22:43.147+0000",
            "id": 25
        },
        {
            "author": "Mark Harwood",
            "body": ">>How can I ignore fields in a SpanQuery. Now it hits me, rather embarrassingly, such a SpanQuery doesn't make sense at all. \n\nJust to make sure we're talking about the same thing. Yes, I too came to the obvious realisation that a single SpanQuery cannot test content from more than one field - but I don't think that is something we were trying to support here. The requirement (as I understand it) is to support a scenario where a SpanQuery  was testing only one field, say the \"body\" field and yet the user wanted to see any matches that just so happened to occur in another field, say the \"title\" field. Nowhere in the query was there a suggestion of any criteria mandatory or otherwise testing the \"title\" field - the user just wanted to highlight the title field for additional decoration.\nIn this scenario we have the challenge of taking the \"body\" query terms and using them to highlight \"title\" field content. A \"match\" would have to disregard the original choice of field name but would still require that  the positions of term text adhered to the SpanQuery logic.\n\nHope this makes sense\n\nMark",
            "date": "2007-03-12T23:38:15.729+0000",
            "id": 26
        },
        {
            "author": "Mark Miller",
            "body": "Yup, we are on the same page. I was just buried in the code at the time, and having stared at your code that ignores the field for each Term I was not  thinking from a high level but was instead stuck on the process of ignoring fields in a similar manner. For whatever reason it never dawned on me that we don't have to worry about a Span that has Terms with different field values. After staring at your suggestion long enough, my brain de-fogged.\n\nI will submit an updated patch tomorrow.\n\n- Mark",
            "date": "2007-03-12T23:57:20.377+0000",
            "id": 27
        },
        {
            "author": "Mark Miller",
            "body": "Just for thought, what about a SpanOr query with two sub Span queries that target different fields? Too obscure to care about?\n\nI will post the new patch later tonight.\n\n- Mark",
            "date": "2007-03-14T18:16:41.827+0000",
            "id": 28
        },
        {
            "author": "Mark Miller",
            "body": "Bah, that last comment is rubbish again. Of course that will work alright. Everything is looking sharp.\n\nOn another note though, what do you think about the restriction of having to reset the SpanScorer between calls to getBestFragments? Is this preferable to an api change?\n\n- Mark",
            "date": "2007-03-14T18:26:50.717+0000",
            "id": 29
        },
        {
            "author": "Mark Miller",
            "body": "Apologize for the delay on this -- I was pulled into a busy product launch.\n\nThis adds the final piece, replacing TermModifer with multiple Memory Indexes.\n\nI also did a little refactoring, especially in the SpansExtractor.\n\nAll tests now pass and I have been using this succesfully for some time now.\n\nFor anyone new following this issue, ignore all of the files except for this one: spanhighlighter5.patch\n\n- Mark",
            "date": "2007-04-10T01:06:05.720+0000",
            "id": 30
        },
        {
            "author": "Sean O'Connor",
            "body": "I was able to apply the spanhighlighter5.patch. I'm inexperienced with ant and svn, so I assume the slight troubles I had were self-inflicted; I mention them in case they are of any help.\n\nI might have missed something, but my MemoryIndex.java seemed to be missing the implementation of the abstract isPayloadAvailable() method from TermPositions. That was causing my build to fail, so I added the method, simply returning false.\n\nAfter that change, the tests run, and life was good again. I do get a failed test at org.apache.lucene.search.highlight.HighlighterTest.testGetRangeFragments(HighlighterTest.java:137), but it looks like that might be expected. The search is \"[kannedy TO kznnedy]\".\n\nI am now looking into getting the total number of hits for a given query (for un-normalized scoring), and the hit positions (saved for larger scale analysis and browsing). I have code that does this, but hope I can improve on my existing approach by using this highlighting patch.\nThanks,\n\nSean\n",
            "date": "2007-04-10T17:56:01.764+0000",
            "id": 31
        },
        {
            "author": "Mark Miller",
            "body": "Sorry Sean, I forgot to mention that the patch is off of the latest \nLucene trunk code.\n\nThe range query test should fail because they switched the query parser \nto return a constant score query instead of a range query. Cannot \nhighlight a constant score query.\n\n- Mark\n\n",
            "date": "2007-04-10T18:09:34.564+0000",
            "id": 32
        },
        {
            "author": "Sean O'Connor",
            "body": "Thanks Mark. I had the trunk from a few days ago (perhaps a week), so that was just me being lazy : -).\n\nIs there anything I should be aware of the: parser.setUseOldRangeQuery(true); in doSearching(String queryString)? [about\u00a0 line 890 in SpanHighlighterTest.java]\n\nI've read the javadocs which explain it a bit, but I don't think a understand enough to infer why you use it in the SpanHighterTest.java. If I can (relatively) safely ignore that, I will.\n\nSean\n\n\nMark Miller (JIRA) wrote:\n    [ [1]https://issues.apache.org/jira/browse/LUCENE-794?page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#action_12487860 ] \n\nMark Miller commented on LUCENE-794:\n------------------------------------\n\nSorry Sean, I forgot to mention that the patch is off of the latest \nLucene trunk code.\n\nThe range query test should fail because they switched the query parser \nto return a constant score query instead of a range query. Cannot \nhighlight a constant score query.\n\n- Mark\n\n\n\n  \nSpanScorer and SimpleSpanFragmenter for Contrib Highlighter\n-----------------------------------------------------------\n\n                Key: LUCENE-794\n                URL: [2]https://issues.apache.org/jira/browse/LUCENE-794\n            Project: Lucene - Java\n         Issue Type: Improvement\n         Components: Other\n           Reporter: Mark Miller\n           Priority: Minor\n        Attachments: CachedTokenStream.java, CachedTokenStream.java, CachedTokenStream.java, DefaultEncoder.java, Encoder.java, Formatter.java, Highlighter.java, Highlighter.java, Highlighter.java, Highlighter.java, Highlighter.java, HighlighterTest.java, HighlighterTest.java, HighlighterTest.java, HighlighterTest.java, MemoryIndex.java, QuerySpansExtractor.java, QuerySpansExtractor.java, QuerySpansExtractor.java, QuerySpansExtractor.java, SimpleFormatter.java, spanhighlighter.patch, spanhighlighter2.patch, spanhighlighter3.patch, spanhighlighter5.patch, spanhighlighter_patch_4.zip, SpanHighlighterTest.java, SpanHighlighterTest.java, SpanScorer.java, SpanScorer.java, WeightedSpanTerm.java\n\n\nThis patch adds a new Scorer class (SpanQueryScorer) to the Highlighter package that scores just like QueryScorer, but scores a 0 for Terms that did not cause the Query hit. This gives 'actual' hit highlighting for the range of SpanQuerys and PhraseQuery. There is also a new Fragmenter that attempts to fragment without breaking up Spans.\nSee [3]http://issues.apache.org/jira/browse/LUCENE-403 for some background.\nThere is a dependency on MemoryIndex.\n    \n\n  \n\n----------------------------------------------------------------------------------------\n[1] https://issues.apache.org/jira/browse/LUCENE-794?page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#action_12487860\n[2] https://issues.apache.org/jira/browse/LUCENE-794\n[3] http://issues.apache.org/jira/browse/LUCENE-403\n",
            "date": "2007-04-11T03:56:32.688+0000",
            "id": 33
        },
        {
            "author": "Mark Miller",
            "body": "I use that to make the Range Query test pass. The old style Range Query \nis highlightable.\n",
            "date": "2007-04-11T09:59:32.787+0000",
            "id": 34
        },
        {
            "author": "Sean O'Connor",
            "body": "Mark,\n   Can you point me in the right direction? I want to find ALL hits (not just the top xx), and their location in the text. \n\n    I think the functionality exists in your patch, or could be easily extended. I just can't seem to get my head around where to start. \nThanks,\n\nSean\n",
            "date": "2007-05-16T23:19:44.343+0000",
            "id": 35
        },
        {
            "author": "Mark Miller",
            "body": "Updated the patch to version 6. Apply against Lucene trunk.\n\n- Updated CachedTokenStream to implement reset() instead of rewind()\n- Removed rewind checks in CachedTokenStream\n\n- Reordered QuerySpansExtractor constructors and added one\n- QuerySpansExtractor now interns field name for faster comparisons against Token fields\n\n",
            "date": "2007-05-29T00:32:29.374+0000",
            "id": 36
        },
        {
            "author": "Michael Busch",
            "body": "Hi Mark,\n\nI don't know the details of your patch. I just saw your class \nCachedTokenStream and was wondering if you're aware of \nthe new class CachingTokenFilter in the analysis package?\nMaybe you could use that?",
            "date": "2007-05-29T00:42:57.152+0000",
            "id": 37
        },
        {
            "author": "Mark Miller",
            "body": "Thanks Michael -- I was not aware and will certainly make the change in the next patch I put up.",
            "date": "2007-05-29T00:59:23.337+0000",
            "id": 38
        },
        {
            "author": "Mark Miller",
            "body": "Minor update to straighten a few things out.\n\n- Replaced custom CachingTokenStream with Lucene's CachingTokenFilter\n- Some refactoring in the SpanExtractor (now WeightedSpanTermExtractor)\n- Updated some stale JavaDoc",
            "date": "2007-06-01T14:41:26.981+0000",
            "id": 39
        },
        {
            "author": "Mark Miller",
            "body": "I plan on one more release and than I am finished.\n\nI need to optimize the scoring (stop looking at positions for terms that are not position sensitive)\n\nMake a couple unit tests to check for a bug I suspect\n\nTurn the javadoc's into something I am actually proud of.\n\nI would wait for this final patch before taking a look at this Mark H.\n\nI apologize for being so incremental on this issue...lesson learned.\n\n- Mark",
            "date": "2007-06-05T20:05:53.957+0000",
            "id": 40
        },
        {
            "author": "Mark Miller",
            "body": "\npatch version 8 : Apply to root dir of trunk\n\n- Fixed a bug that was caused when a query had the same term multiple times\n- Added a unit test for the bug just mentioned\n- Improved performance by not converting Querys that are not position sensitive to SpanQuerys. Non position sensitive Query clauses are treated the same way the standard Scorer would treat them.\n- Some refactoring based on the previous change.\n- Improved some of the JavaDoc comments",
            "date": "2007-06-19T21:25:02.514+0000",
            "id": 41
        },
        {
            "author": "Mark Miller",
            "body": "patch version 9 : Apply to root dir of trunk \n\nVarious small improvements.\n\nBe sure to use the recently updated CachingTokenFilter for optimal performance.",
            "date": "2007-06-27T21:22:16.393+0000",
            "id": 42
        },
        {
            "author": "Otis Gospodnetic",
            "body": "Mark, wow, long list of files up there.  I can't tell which ones are still relevant.  Ah, only  spanhighlighter9.patch, right?\n\nIt looks like all files in that patch are new files, that is, this is a parallel highlighter implementation - we can leave the old one in there and commit yours without worrying about breaking the old one.  Could you add Apache license headers to all files, switch to 2 spaces for indentation, and then I think this can get committed?\n\nOh, and since contrib can be java 1.5+, I think you can use StringBuilder instead of StringBuffer, etc.\n",
            "date": "2007-07-26T23:38:11.087+0000",
            "id": 43
        },
        {
            "author": "Mark Miller",
            "body": "Requested changes have been made. Only relevant file now is spanhighlighter10.patch.\n\nThis is a parallel implementation...it uses all of the current Highlighter classes. Really, it is just a new Scorer implementation that scores position sensitive queries based on correct positions for a hit.\n\nThe whole approach was radically changed from the StringBuilder version, so all code is still Java 1.4 compatible.\n\nI have been using this extensively with great success for a few months now.",
            "date": "2007-07-27T01:34:57.347+0000",
            "id": 44
        },
        {
            "author": "Andy Liu",
            "body": "I gave this patch a whirl, and it looks great.\n\nI do see one problem.  Say a document contains:\n\nx y z a b y z\n\nand the query is:\n\n\"x y z\"\n\nthe highlighter will return (with terms in brackets denoting highlighted terms):\n\n[x] [y] [z] a b [y] [z]\n\nSince the last y and z are not part of the full phrase, they should not be highlighted.",
            "date": "2007-09-12T13:59:42.326+0000",
            "id": 45
        },
        {
            "author": "Mark Miller",
            "body": "I believe the issue is that turning a PhraseQuery into a representative Span query is only an approximate conversion.\n\nI will look into whether or not I can improve this.\n\nThanks for the feedback.\n\n- Mark",
            "date": "2007-09-12T15:32:08.137+0000",
            "id": 46
        },
        {
            "author": "Mark Miller",
            "body": "I made up a quick test to identify the behavior but did not duplicate your results:\n\nThe results of your example:\n\ndoc in index: x y z a b y z\n\nSearching for: \"x y z\"\n\t\nResult: <b>x</b> <b>y</b> <b>z</b> a b y z\n\nCould you post some code demonstrating the problem?\n\n",
            "date": "2007-09-12T16:05:49.671+0000",
            "id": 47
        },
        {
            "author": "Andy Liu",
            "body": "Hmm, I tried it again and now it's working correctly.  Maybe I had interpreted the output incorrectly.  Sorry for the false alarm.",
            "date": "2007-09-12T16:48:18.341+0000",
            "id": 48
        },
        {
            "author": "Andy Liu",
            "body": "Ah, I wasn't crazy.  I had the test data wrong.  Here's the code I'm using to produce the failing result:\n\n        String text = \"y z x y z a b\";\n\n        Analyzer analyzer = new StandardAnalyzer();\n        QueryParser parser = new QueryParser(\"body\", analyzer);\n        Query query = parser.parse(\"\\\"x y z\\\"\");\n        \n        CachingTokenFilter tokenStream = new CachingTokenFilter(analyzer.tokenStream(\"body\", new StringReader(text)));\n        Highlighter highlighter = new Highlighter(new SpanScorer(query, \"body\", tokenStream));\n        highlighter.setTextFragmenter(new NullFragmenter());\n        tokenStream.reset();\n\n        String result = highlighter.getBestFragments(tokenStream, text, 1, \"...\");\n        System.out.println(result);\n\nThis produces:\n\n<B>y</B> <B>z</B> <B>x</B> <B>y</B> <B>z</B> a b\n\nThe beginning y and z shouldn't be highlighted.\n\nIf I change the the beginning y and z to x and y, I get the correct result:\n\n\"x y x y z a b\" => x y <B>x</B> <B>y</B> <B>z</B> a b\n\nHere's a couple other failing results:\n\n\"z x y z a b\" => <B>z</B> <B>x</B> <B>y</B> <B>z</B> a b\n\"z a x y z a b\" => <B>z</B> a <B>x</B> <B>y</B> <B>z</B> a b\n\nFYI, I'm using the latest version of Lucene.",
            "date": "2007-09-13T15:12:05.077+0000",
            "id": 49
        },
        {
            "author": "Mark Miller",
            "body": "Thanks a lot Andy. As I suspected, the issue is that the conversion from PhraseQuery to SpanQuery is inexact. I have updated the code to handle this case though. If a PhraseQuery has 0 slop then the created Span query will now force an inorder match. This should be a nice improvement to the PhraseQuery to SpanQuery approximation.\n\nPatch with fix and new junit test attached.\n\npatch 11\n\n- Mark",
            "date": "2007-09-13T15:52:20.829+0000",
            "id": 50
        },
        {
            "author": "Mark Miller",
            "body": "Nice little addition courtesy of Michael Goddard:\n\n\"...In our Lucene work, we took the approach of indexing all fields into a single field, \"FULLTEXT\", which is the default field for queries.  Our query syntax is such that a user can combine clauses against named fields with clauses with no field specified.  When we go to highlight such queries, if a given clause is against this FULLTEXT field but we're highlighting text in the TITLE field, we'd still like for matching terms to be highlighted...\"\n\nThanks for the patch Micahael.\n\nThere is a new constructor that allows you to specify a default field. Terms from this field will be highlighted regardless of the specific field you are highlighting.\n\nOnly file to worry about in that huge mess of files listed above is spanhighlighter12.patch.",
            "date": "2007-10-19T14:47:47.406+0000",
            "id": 51
        },
        {
            "author": "Mark Miller",
            "body": "Anything anyone wants to see to further this issue? It seems like a no brainer to add to the current contrib Highlighter...at this point, more than a few people are using it. Suggestions, criticisms, interest ?",
            "date": "2007-11-25T05:05:44.521+0000",
            "id": 52
        },
        {
            "author": "Michael Goddard",
            "body": "Mark,\n\nI did a little bit more with this since I needed support for highlighting queries containing ConstantScoreRangeQuery's.  Would you be interested in looking at those changes?\n",
            "date": "2007-11-26T14:27:47.357+0000",
            "id": 53
        },
        {
            "author": "Mark Harwood",
            "body": "Makes sense to commit it to me.\nI want to spend some time reviewing this in more detail once I'm through with contributing the new web-based version of Luke.\nAt a quick glance, does the new Junit test in this patch encompass both old and new Highlighter tests? In which case should we remove the old Junit test if they overlap?\n",
            "date": "2007-11-28T09:44:16.136+0000",
            "id": 54
        },
        {
            "author": "Mark Miller",
            "body": "Michael: I would love to take a look. I've got the code you sent me and I will go through it soon.\n\nMark: That is an issue that should probably be cleaned up. A lot of tests are shared, the new SpanScorer just requires some different, odd,  setup that made it easier to copy and change the test file.  I will spend some time trying to combine them into one test file to avoid the overlap.",
            "date": "2007-11-28T13:18:19.815+0000",
            "id": 55
        },
        {
            "author": "Otis Gospodnetic",
            "body": "I re-skimmed this JIRA issue just now.  Other than the final cleanup that Marks mention, any reason this is not yet in svn?\n",
            "date": "2008-01-10T04:04:03.741+0000",
            "id": 56
        },
        {
            "author": "Grant Ingersoll",
            "body": "How should this relate to LUCENE-663?  Seems like that one also covers other kinds of queries?  I'm no expert in highlighting, but it seems like there is at least 3 different issues in JIRA for enabling things like phrase queries, etc.   Should we try to consolidate these?",
            "date": "2008-01-14T20:58:29.145+0000",
            "id": 57
        },
        {
            "author": "Grant Ingersoll",
            "body": "Never mind, I went back and read the thread at http://lucene.markmail.org/message/p4gfxewk6jcqfxxj?q=highlighter+list:org%2Eapache%2Elucene%2Ejava-user\nwhich I think accounts for this approach and makes sense to me.",
            "date": "2008-01-14T21:46:14.361+0000",
            "id": 58
        },
        {
            "author": "Michael Goddard",
            "body": "Mark,\n\nI've still got a little work to do on it, but would like to also include support for highlighting of RangeQuery within SpanNearQuery.  I have a new SpanQuery subclass which helps, and will post that to see if it merits inclusion within Lucene.  In conjunction with that, I'd have one last \"else if\" clause to add to the patch covered by this issue.  Basically, I'm trying to make a case for the work covered in this Jira issue being committed, since it's very useful to me.\n",
            "date": "2008-01-14T22:37:47.123+0000",
            "id": 59
        },
        {
            "author": "Mark Miller",
            "body": "Hows that work coming Michael? I have started turning the two test classes into one and I'd like to get together one final patch with your new work when I am done.\n\nI have checked out your code that adds ConstantScoreRangQuery support and it looks great. Great idea there.",
            "date": "2008-01-23T02:51:29.753+0000",
            "id": 60
        },
        {
            "author": "Michael Goddard",
            "body": "Mark,\n\nThanks for looking at that.  I just entered a new Jira issue for the new work,\n\n  https://issues.apache.org/jira/browse/LUCENE-1148\n\nwhich seems to work well enough with the most recent spanhighlighter_patch code, since  it already contains a clause to handle SpanQuery.  So, no need to wait on anything from me.\n\n  Mike\n",
            "date": "2008-01-24T15:40:42.878+0000",
            "id": 61
        },
        {
            "author": "Michael Goddard",
            "body": "Relocated the fir.close() to after the extract(bq, terms) call.  Problem had manifested itself as a org.apache.lucene.store.AlreadyClosedException, but should be fixed via this patch.\n\n",
            "date": "2008-01-24T22:22:33.821+0000",
            "id": 62
        },
        {
            "author": "Mark Miller",
            "body": "This patch gets rid of the separate SpanScorer test class and combines all test in HighlighterTest. Almost all of the tests are now run twice - once with the standard QueryScorer and once with the new SpanScorer.\n\nThanks to all for the bug fixes and contributions.\n\n- Mark",
            "date": "2008-01-26T21:44:59.440+0000",
            "id": 63
        },
        {
            "author": "Nicolas Dessaigne",
            "body": "Mark,\n\nI added a few lines of code to the WeightedSpanTermExtractor.extract method to handle DisjunctionMaxQuery instances. I didn't take the time to make a patch against your new version but the code is pretty simple:\n\n{code}\n...\n} else if (query instanceof DisjunctionMaxQuery) {}}\n\tMap disjunctTerms = new HashMap();\n\tfor (Iterator iterator = ((DisjunctionMaxQuery) query).iterator(); iterator.hasNext();) {\n\t\textract((Query) iterator.next(), disjunctTerms);\n\t}\n\tterms.putAll(disjunctTerms);\n} else {\n...\n{code}",
            "date": "2008-01-28T10:14:53.690+0000",
            "id": 64
        },
        {
            "author": "Mark Miller",
            "body": "Thanks, looks great.\n\nNew patch with posted code.",
            "date": "2008-01-28T12:36:17.869+0000",
            "id": 65
        },
        {
            "author": "Mark Miller",
            "body": "Hey Mark H, any chance you will have some time to look at this soon?\n\nNow that the test classes have been merged, any change to the current contrib test class will break this patch.\n\nI think everything is good except that we might want to alert which Highlighter version caused the Junit test to fail., since almost every test is run with both the standard and new Span Highlighter. I may just be nitpicking there though.",
            "date": "2008-02-19T21:47:29.701+0000",
            "id": 66
        },
        {
            "author": "Mark Harwood",
            "body": "Will do. I'm taking a quick look now but should have more time tomorrow.\n\nThanks,\nMark",
            "date": "2008-02-19T22:17:13.136+0000",
            "id": 67
        },
        {
            "author": "Mark Harwood",
            "body": "Couple of quick comments from a first look.\n\n* I amended the new unit test, stripped out all new \"Span\" related tests and compared running it against 2.3 highlighter code and this patch. On this rough test it looks like the new implementation is slightly faster executing these tests (2.6 seconds vs 3.0). Good stuff.\n\n* The general advice on using the Highlighter is to call it with re-written queries in order to highlight fuzzy queries etc. That being the case, the support for ConstantScoreRangeQuery in WeightedSpanTermExtractor is not likely to work because ConstantScoreRangeQuery rewrites to a ConstantScoreQuery and therefore can't be inspected for terms.\n\nHope to spend some more time looking at this tomorrow.",
            "date": "2008-02-19T23:46:29.156+0000",
            "id": 68
        },
        {
            "author": "Mark Miller",
            "body": "Good catch right off Mark. Appreciate you looking into this so quickly <g> You've got a darn quick eye for problems.\n\nHey Michael G. How are you dealing with the rewrite issue for the ConstantScoreRangeQuery? I assume you just are not using rewrite? Any comments on this?",
            "date": "2008-02-20T00:53:47.752+0000",
            "id": 69
        },
        {
            "author": "Mark Harwood",
            "body": "Actually is it worth trying to resolve this ConstantScoreRangeQuery issue?\n\n1) A large range can produce a lot of terms - extracting these would bloat memory and slow down highlighting. \n2) The sorts of \"quantity\" fields that are subject to ranges (prices, dates, lat-lon coordinates) don't typically need highlighting anyway because:\n    a) range criteria is normally mandatory (so ALL results are expected to match the range and highlighting matches is unnecessary)\n    b) Quantities are normally held in dedicated fields with only one value. Unlike free-text fields there's no need for the user's eye to scan large amounts of information looking for the \"hit\" so, again highlighting/summarising is generally less useful.\n\nGiven the unavoidable performance overhead this introduces and the sneaking suspicion that it's not useful anyway is this worth supporting?\n\nWould be keen to know what the scenario was that introduced this as a requirement.",
            "date": "2008-02-20T22:05:29.422+0000",
            "id": 70
        },
        {
            "author": "Mike Klaas",
            "body": "This may be largely irrelevant, but Solr has a ConstantScorePrefixQuery which has similar issues (but _should_ be highlighted most of the time).\n\nIt might find its way into lucene core one day.",
            "date": "2008-02-21T00:00:42.048+0000",
            "id": 71
        },
        {
            "author": "Michael Goddard",
            "body": "I'm fairly certain that Mark H.'s comments are correct, but somehow I was getting highlighting.  ConstantScoreRangeQuery was the query I'd used initially, but I had to later introduce a SpanRangeQuery which I could embed in SpanNearQuery instances.  And, yes, we have users who need this perverse combination.  They have a query syntax which is very expressive and enables them to nest \"proximity\" (SpanNearQuery) queries to an arbitrary depth; they can even embed numeric range queries within any of these sub-queries.  The requirement is mainly cultural, arising out of the long time use of a pure boolean text engine.  Still, over the past fifteen or so years, the user base has developed a fairly large body of \"literature\" -- queries they use to find certain things -- and they don't want to throw all of that away.  I agree that this type of thing is sort of specialized, but I thought there might just be a few others out there with similar needs.  The need to highlight all of this is due to the fact that several tools are use to post-process search results and visualize them.\n\nI really appreciate the attention you guys have given to this.  There's the background from my end.\n\nThanks.\n",
            "date": "2008-02-21T01:20:22.772+0000",
            "id": 72
        },
        {
            "author": "Mark Miller",
            "body": "Thanks Michael,\n\nSeems we can drop it to me then.\n\nI don't know that the performance would be that bad - you are only extracting the terms from an index with a single document, so there is not likely to be *that* many terms. \n\nbut,\n\nInitially I thought that highlighting something like the Date would be nice as it would visually indicate that piece's involvement in selecting the document...but as Mark points out, its really not that helpful at all.\n\nSince Micahel doesn't even need it anymore, it seems we prob shouldn't even keep it as configurable. Just drop it then?\n\n- Mark",
            "date": "2008-02-21T01:51:14.874+0000",
            "id": 73
        },
        {
            "author": "Mark Harwood",
            "body": ">>This may be largely irrelevant, but Solr has a ConstantScorePrefixQuery which has similar issues\n\nNo, very relevant. Only yesterday I had a user with exactly the same highlighting problem\n\n>>it seems we prob shouldn't even keep it as configurable. Just drop it then?\n\nMy nightmare scenario is systems where people are using ConstantScoreRangeQuery in their queries to do both latitude and longitude ranges over large areas - that's a lot of terms. I'd at least want the option of NOT loading them all into RAM at once when highlighting.\n\nMaybe we could look at having different highlight \"matchers\". The existing approach of keeping a big bag of query terms becomes a \"TermsMatcher\" (simply looks up tokens in a HashSet of terms), You can imagine a new \"PrefixMatcher\" which would examine tokens using \"startsWith\" and a \"RangeMatcher\" examine tokens using just a start and end term. However, there's  a danger we could end up re-implementing a lot of query logic so maybe the relevant queries/filters could implement a \"Matcher\" interface to enable the same logic that is used when scanning TermEnum at query time to be used by the Highlighter when looking at TokenStreams i,e. something like this:\ninterface Matcher\n{\n   boolean matches(String value)\n}\nNeeds some more thought yet but it could be an approach.",
            "date": "2008-02-21T08:16:54.141+0000",
            "id": 74
        },
        {
            "author": "Paul Elschot",
            "body": "One way to solve the problem of many terms in a range or a prefix query is by indexing terms in a hierarchy of prefixes, for example for a date CCYYMMDD can be indexed as all of C, CC, CCY, CCYY, CCYYMM, CCYYMMD and CCYYMMDD on the same position.\nThen for a range and prefix queries the query analyzer can construct an OR over as few terms as possible.\nQuery search and highlighting would work faster and still correct as they are based on the term positions.\n",
            "date": "2008-02-21T15:59:47.183+0000",
            "id": 75
        },
        {
            "author": "Benjamin Keil",
            "body": "This is a patch that applies on top of  SpanHighlighter-01-28-2008.patch in order to highlight MutliPhraseQueries",
            "date": "2008-03-09T01:11:25.506+0000",
            "id": 76
        },
        {
            "author": "Mark Miller",
            "body": "Another attempt at putting this to bed.\n\nAdded the MultiPhraseQuery support patch above - thanks!\nUpdated some code to stop using deprecated methods.\nMade highlighting ConstantScoreRangeQuerys optional, defaulting to false.\n\n- Mark",
            "date": "2008-03-10T11:55:21.415+0000",
            "id": 77
        },
        {
            "author": "Otis Gospodnetic",
            "body": "Hey, is this 14-month old (impressive persistence, MM) piece of work ready to be committed?",
            "date": "2008-04-21T03:48:44.502+0000",
            "id": 78
        },
        {
            "author": "Mark Harwood",
            "body": "Just tried the latest of everything- patch applies cleanly, Junit test passes and I've just run my own additional side-by-side tests with my content to see the effects of new phrase support and without.\n\nLooks good to me - unless there are any objections I'll go ahead and commit.",
            "date": "2008-04-21T20:16:08.230+0000",
            "id": 79
        },
        {
            "author": "Maurizio",
            "body": "Hi,\nprobably I'm missing something, I'm not sure this is the right place to ask my question, but I can't understand how patch mechanism works.\nFirst, I downloaded source code from http://svn.apache.org/repos/asf/lucene/java/trunk/contrib/highlighter/, then I tried to apply every patches listed above.\nI wrote a trivial bash script for apply patches (I'm assuming that these one are not cumulative patch), but unsuccessfully.\n \nthanks in advance...\n\nMaurizio\n\n\npatch.sh\n/*-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/\n#!/bin/sh\npatch -p2 < spanhighlighter.patch\npatch -p2 < spanhighlighter2.patch\npatch -p2 < spanhighlighter3.patch\npatch -p2 < spanhighlighter4.patch\nunzip spanhighlighter_patch_4.zip\nmv index src/java/org/apache/lucene/\npatch -p2 < spanhighlighter5.patch\npatch -p2 < spanhighlighter6.patch\npatch -p2 < spanhighlighter7.patch\npatch -p2 < spanhighlighter8.patch\npatch -p2 < spanhighlighter9.patch\npatch -p2 < spanhighlighter10.patch\npatch -p2 < spanhighlighter11.patch\npatch -p2 < spanhighlighter12.patch\npatch -p2 < spanhighlighter_24_January_2008.patch\npatch -p2 < SpanHighlighter-01-26-2008.patch\npatch -p2 < SpanHighlighter-01-28-2008.patch\npatch -p2 < MultiPhraseQueryExtraction.patch\npatch -p2 < SpanHighlighter-02-10-2008.patch\npatch -p2 < MultiPhraseQueryExtraction.patch\n\n",
            "date": "2008-04-29T14:42:35.656+0000",
            "id": 80
        },
        {
            "author": "Steve Rowe",
            "body": "Hi Maurizio, \n\nSpanHighlighter-02-10-2008.patch should contain everything - start again with a clean checkout and apply only this patch.",
            "date": "2008-04-29T14:56:34.899+0000",
            "id": 81
        },
        {
            "author": "Brian Whitman",
            "body": "hi, after checking out lucene trunk and applying the 02-10-2008 patch I am getting this during \"ant dist\":\n\n [javac] /Users/bwhitman/outside/lucene/java/trunk/contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java:35: package org.apache.lucene.index.memory does not exist\n\nAny ideas? The patch does say \"relies on MemoryIndex\" but that was committed a long time ago and is in contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java in lucene trunk.\n\n\n",
            "date": "2008-04-29T17:00:11.263+0000",
            "id": 82
        },
        {
            "author": "Maurizio",
            "body": "@Steven\nthanks a lot, now it's working\n@Brian\nlooking for lucene-memory-x.x.x.jar",
            "date": "2008-04-29T17:54:13.375+0000",
            "id": 83
        },
        {
            "author": "Brian Whitman",
            "body": "Ah, got it. You have to ant dist before applying the patch to build the memory jar, then apply the patch and ant again.\n",
            "date": "2008-04-29T18:22:51.401+0000",
            "id": 84
        },
        {
            "author": "Mark Harwood",
            "body": "Committed as part of r652164.\n\nThanks for all your hard work and putting up with my limited availability/support, Mark. \nI owe you a beer..",
            "date": "2008-04-29T22:08:03.683+0000",
            "id": 85
        },
        {
            "author": "Mark Harwood",
            "body": "Committed as part of r652164.",
            "date": "2008-04-29T22:08:28.289+0000",
            "id": 86
        },
        {
            "author": "Brian Whitman",
            "body": "I must be missing something, but after your commit, I did a clean checkout of lucene trunk, did an ant dist and am getting the same MemoryIndex problem as I reported above. Before I could just apply the patch after doing the ant dist first but now that the patch is in trunk I can't get around that. How are you compiling lucene now from trunk?\n\n",
            "date": "2008-04-29T22:18:05.512+0000",
            "id": 87
        },
        {
            "author": "Hoss Man",
            "body": "bq. You have to ant dist before applying the patch to build the memory jar, then apply the patch and ant again.\n\nthis seems like a bug/inconsistency in the new contrib/highlighter/build.xml\n\nit added a \"buildHighlighter\" target which takes care of the dependency in building contrib/memory ... this isn't the way this is normally handled in contrib build.xml files because it's a non standard target name that people (and the contrib walking code) don't know about.\n\nxml-query-parser has a better example of doing this same kind of dependency...\n\n<target name=\"compile-core\" depends=\"build-queries, common.compile-core\" />",
            "date": "2008-04-29T23:24:45.862+0000",
            "id": 88
        },
        {
            "author": "Mark Miller",
            "body": "Darn...waited just too long to comment on this. I had noticed two tiny things: there is a System.out if a query is not recognized by the Query to Span converter.  Also, the get weightedTerms call might want to accept a cachingtokenfilter rather than a tokenstream...I don't think this is a biggie though...just avoids double wrapping in a cachingtokenfilter if that is what is passed in. Someone mentioned that one on the list a few days ago. Neither issues are a big deal, but would be nice to get the System.out out of there...sorry I missed it in the patch.\n\nAlso,\n\nSorry about the bad build file Hoss :( I swear I copied it off another contrib (I didn't know how to do it frankly), so I can't explain why its so incorrect. Maybe I have accumulated too much of this beer I keep demanding and dont remember changing things for the worse...",
            "date": "2008-04-30T00:07:57.472+0000",
            "id": 89
        },
        {
            "author": "Mark Miller",
            "body": "Here is a kill on the System.out.\n\nI should make a new issue right?",
            "date": "2008-04-30T00:46:29.690+0000",
            "id": 90
        },
        {
            "author": "Otis Gospodnetic",
            "body": "Probably no need for a new issue, just commit the fix.\nBut I also noticed that CHANGES.txt has no mention of LUCENE-794.  Somebody forgot to mention the fix there?  It's not too late :)\n\n",
            "date": "2008-05-10T15:38:27.344+0000",
            "id": 91
        },
        {
            "author": "Otis Gospodnetic",
            "body": "Regarding issues with building this, I am seeing the same thing, both for contrib/highlighter and contrib/xml-query-parser.  Running \"ant compile-core\" from within those dirs does not work and running \"ant build-contrib\" also fails.\n\nThe problem in both is with the dependency (on contrib/memory and contrib/queries.  Here is what fixes xml-query-parser:\n\nInstead of:\n..... inheritall=\"false/>\n\nUse this:\n......inheritall=\"true\" dir=\"../queries\" />\n\nAnd a similar thing for contrib/highlighter.\nI'll commit both fixes shortly.\n",
            "date": "2008-05-14T05:28:00.566+0000",
            "id": 92
        },
        {
            "author": "Tavi Nathanson",
            "body": "Hi,\n\nI'm new to Lucene and the highlighter, so I apologize if my question is obvious. In any case, I'm trying to allow phrase highlighting in my instance of Lucene, so I applied this patch to 2.3.2. I'm confused, though, about the structure of SpanScorer vs. QueryScorer. Why does SpanScorer require the stream of source text tokens (i.e. SpanScorer(Query query, String field, CachingTokenFilter cachingTokenFilter)) while QueryScorer does not (i.e. QueryScorer(Query query, String fieldName))?\n\nIntuitively, if QueryScorer is scoring based on the number of unique query terms found in the document, wouldn't the stream of source text tokens be necessary for this calculation? I'm wondering a) why is this not necessary in QueryScorer? and b) what makes it necessary in SpanScorer? I'm having some trouble understanding the code, and was wondering if I could get any guidance :).\n\nThanks!\n\nTavi",
            "date": "2008-06-23T23:50:08.092+0000",
            "id": 93
        },
        {
            "author": "Mark Miller",
            "body": "FYI: This has been applied to the trunk as well.\n\nThe SpanScorer needs a TokenStream because it shoves the stream into a\nMemoryIndex and transforms the query into a Span approximation to find hit\npositions. This approach was used for compatibility with the current API.\n\nThe QueryScorer simply +scores each Token that is in the query as well as\nthe TokenStream - so it just needs to extract the terms from the query and\nfind overlap with the TokenStream passed to the getFragments method. This is\nnot position sensitive.\n\nThe SpanScorer works the same way, but it also fills the MemoryIndex and\ngets matching Spans so that Terms in the wrong position score a 0 during\nHighlighter Term scoring (again getBestFragments or whatever).\n\nThe approach was mainly dictated by the old API. Fitting into the current\nAPI seemed the most practical/efficient way to get a position sensitive\nHighlighter in the short term.\n\nOn Mon, Jun 23, 2008 at 7:51 PM, Tavi Nathanson (JIRA) <jira@apache.org>\n\n",
            "date": "2008-06-24T01:39:45.228+0000",
            "id": 94
        },
        {
            "author": "Tavi Nathanson",
            "body": "Hey everyone,\n\nI'm having some trouble getting SpanScorer to act the way I'd like for proper highlighting, and I'm wondering if anyone has any suggestions.\n\nI have two fields: text_raw and text_stemmed. text_raw, as the name suggests, stores unstemmed (tokenized) text while text_stemmed stores stemmed (tokenized) text.\n\nI have queries that look over both fields. For, example, I may have the query +(text_raw:\"apple sauce\" text_stemmed:orange). This query matches \"apple sauce oranges\" but it does not match \"apples sauces orange\" (because \"apple sauce\" is not stemmed). I'd like to be able to highlight accordingly: I want \"apple,\" \"sauce,\" and \"oranges\" to all be highlighted.\n\nSo, even though it is in fact the raw text that ends up getting highlighted, I'm looking for a way to build SpanScorer such that I don't need to limit myself to one field (\"field\" is one of the arguments to the constructor).\n\nThanks!\n\nTavi\n",
            "date": "2008-07-08T05:02:25.151+0000",
            "id": 95
        },
        {
            "author": "Mark Miller",
            "body": "Hey Tavi,\n\nTry passing null as the field.\n\n- Mark\n\n\n",
            "date": "2008-07-08T11:06:33.703+0000",
            "id": 96
        }
    ],
    "component": "core/other",
    "description": "This patch adds a new Scorer class (SpanQueryScorer) to the Highlighter package that scores just like QueryScorer, but scores a 0 for Terms that did not cause the Query hit. This gives 'actual' hit highlighting for the range of SpanQuerys, PhraseQuery, and  ConstantScoreRangeQuery. New Query types are easy to add. There is also a new Fragmenter that attempts to fragment without breaking up Spans.\n\nSee http://issues.apache.org/jira/browse/LUCENE-403 for some background.\n\nThere is a dependency on MemoryIndex.",
    "hasPatch": true,
    "hasScreenshot": false,
    "id": "LUCENE-794",
    "issuetypeClassified": "RFE",
    "issuetypeTracker": "IMPROVEMENT",
    "priority": "Minor",
    "product": "LUCENE",
    "project": "LUCENE",
    "summary": "Extend contrib Highlighter to properly support PhraseQuery, SpanQuery,  ConstantScoreRangeQuery",
    "systemSpecification": true,
    "version": ""
}